{"ast":null,"code":"!function (e) {\n  \"object\" == typeof module && \"undefined\" != typeof module.exports ? module.exports = e : e();\n}(function () {\n  (window.webpackJsonpFusionCharts = window.webpackJsonpFusionCharts || []).push([[3], {\n    460: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t.DragArea = t.Radar = t.HeatMap = t.BoxAndWhisker2D = t.CandleStick = t.DragNode = t.MSStepLine = t.MultiAxisLine = t.MultilevelPie = t.SelectScatter = t.WaterFall2D = t.Kagi = t.Dragline = t.Dragcolumn2d = t.Inversemsline = t.Inversemscolumn2d = t.Inversemsarea = t.Errorscatter = t.Errorline = t.Errorbar2d = t.Mssplinearea = t.Msspline = t.MSSplineDy = t.Splinearea = t.Logmsline = t.LogStackedColumn2d = t.Logmscolumn2d = t.Spline = undefined;\n\n      var a = O(o(455)),\n          r = O(o(461)),\n          n = O(o(467)),\n          i = O(o(468)),\n          l = O(o(456)),\n          s = O(o(457)),\n          c = O(o(458)),\n          u = O(o(459)),\n          p = O(o(469)),\n          h = O(o(472)),\n          d = O(o(476)),\n          g = O(o(480)),\n          f = O(o(481)),\n          m = O(o(482)),\n          v = O(o(483)),\n          b = O(o(492)),\n          y = O(o(498)),\n          x = O(o(499)),\n          w = O(o(504)),\n          k = O(o(507)),\n          C = O(o(511)),\n          N = O(o(541)),\n          S = O(o(544)),\n          E = O(o(553)),\n          A = O(o(564)),\n          D = O(o(572)),\n          T = O(o(584)),\n          L = O(o(497)),\n          _ = O(o(248)),\n          P = O(o(252));\n\n      function O(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      t.Spline = a[\"default\"], t.Logmscolumn2d = r[\"default\"], t.LogStackedColumn2d = i[\"default\"], t.Logmsline = n[\"default\"], t.Splinearea = l[\"default\"], t.MSSplineDy = c[\"default\"], t.Msspline = s[\"default\"], t.Mssplinearea = u[\"default\"], t.Errorbar2d = p[\"default\"], t.Errorline = h[\"default\"], t.Errorscatter = d[\"default\"], t.Inversemsarea = g[\"default\"], t.Inversemscolumn2d = f[\"default\"], t.Inversemsline = m[\"default\"], t.Dragcolumn2d = v[\"default\"], t.Dragline = b[\"default\"], t.Kagi = y[\"default\"], t.WaterFall2D = x[\"default\"], t.SelectScatter = w[\"default\"], t.MultilevelPie = k[\"default\"], t.MultiAxisLine = C[\"default\"], t.MSStepLine = N[\"default\"], t.DragNode = S[\"default\"], t.CandleStick = E[\"default\"], t.BoxAndWhisker2D = A[\"default\"], t.HeatMap = D[\"default\"], t.Radar = T[\"default\"], t.DragArea = L[\"default\"], t[\"default\"] = {\n        name: \"powercharts\",\n        type: \"package\",\n        requiresFusionCharts: !0,\n        extension: function extension(e) {\n          e.addDep(_[\"default\"]), e.addDep(P[\"default\"]), e.addDep(a[\"default\"]), e.addDep(r[\"default\"]), e.addDep(i[\"default\"]), e.addDep(n[\"default\"]), e.addDep(l[\"default\"]), e.addDep(c[\"default\"]), e.addDep(s[\"default\"]), e.addDep(u[\"default\"]), e.addDep(p[\"default\"]), e.addDep(h[\"default\"]), e.addDep(d[\"default\"]), e.addDep(g[\"default\"]), e.addDep(f[\"default\"]), e.addDep(m[\"default\"]), e.addDep(v[\"default\"]), e.addDep(b[\"default\"]), e.addDep(y[\"default\"]), e.addDep(x[\"default\"]), e.addDep(w[\"default\"]), e.addDep(k[\"default\"]), e.addDep(C[\"default\"]), e.addDep(N[\"default\"]), e.addDep(S[\"default\"]), e.addDep(E[\"default\"]), e.addDep(A[\"default\"]), e.addDep(D[\"default\"]), e.addDep(T[\"default\"]), e.addDep(L[\"default\"]);\n        }\n      };\n    },\n    461: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(462)),\n          r = i(o(402)),\n          n = i(o(331));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"LogMSColumn2d\";\n        }, t.prototype.getName = function () {\n          return \"LogMSColumn2d\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Multi-series Log Column Chart\", t.defaultDatasetType = \"column\", t.enablemousetracking = !0;\n        }, t.prototype.getDSGroupdef = function () {\n          return r[\"default\"];\n        }, t.prototype.getDSdef = function () {\n          return n[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    462: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(354)),\n          r = i(o(463)),\n          n = o(118);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.registerFactory(\"axis\", r[\"default\"], [\"canvas\"]), o;\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"MsLog\";\n        }, t.prototype._feedAxesRawData = function () {\n          var e,\n              t,\n              o = this.getFromEnv(\"dataSource\"),\n              a = this.getFromEnv(\"chart-attrib\");\n          return e = this.getSpecificxAxisConf(), \"1\" === (t = this.getSpecificyAxisConf()).base && (t.base = 10, t.logBase = 10), t.minorDivlinecolor = (0, n.pluck)(a.minordivlinecolor, t.divLineColor), t.minorDivLineThickness = (0, n.pluck)(a.minordivlinethickness, 1), t.minorDivLineAlpha = (0, n.pluck)(a.minordivlinealpha, t.divLineAlpha / 2), e.vtrendlines = o.vtrendlines, t.trendlines = o.trendlines, {\n            yAxisConf: [t],\n            xAxisConf: [e]\n          };\n        }, t.prototype.getSpecificxAxisConf = function () {\n          var e = this.getFromEnv(\"chart-attrib\"),\n              t = this.getBasexAxisConf();\n          return t.showZeroPlane = e.showvzeroplane, t.zeroPlaneThickness = e.vzeroplanethickness, t.zeroPlaneAlpha = e.vzeroplanealpha, t.showAxisLine = (0, n.pluckNumber)(e.showxaxisline, e.showaxislines, e.drawAxisLines, 0), t.axisLineColor = (0, n.pluck)(e.xaxislinecolor, e.axislinecolor, \"#000000\"), t.isReverse = !1, t.showAlternateGridColor = (0, n.pluckNumber)(e.showalternatevgridcolor, 0), t.numDivLines = e.numvdivlines, t.maxLabelHeight = e.maxlabelheight, t.axisName = e.xaxisname, t.setAdaptiveMin = e.setadaptivexmin, t.showLimits = e.showvlimits, t.showDivLineValues = (0, n.pluckNumber)(e.showvdivlinevalues, e.showvdivlinevalues), t;\n        }, t.prototype.getSpecificyAxisConf = function () {\n          var e = this.getFromEnv(\"chart-attrib\"),\n              t = this.config.is3D ? n.chartPaletteStr.chart3D : n.chartPaletteStr.chart2D,\n              o = !!(0, n.pluckNumber)(e.invertyaxis, 0),\n              a = this.getFromEnv(\"color-manager\");\n          return {\n            isVertical: !0,\n            isReverse: !o,\n            isOpposit: !1,\n            outCanfontFamily: (0, n.pluck)(e.outcnvbasefont, e.basefont, \"Verdana,sans\"),\n            outCanfontSize: (0, n.pluckFontSize)(e.outcnvbasefontsize, e.basefontsize, 10),\n            outCancolor: (0, n.pluck)(e.outcnvbasefontcolor, e.basefontcolor, a.getColor(t.baseFontColor)).replace(/^#? ([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: e.yaxisnamepadding,\n            axisValuePadding: e.yaxisvaluespadding,\n            axisNameFont: e.yaxisnamefont,\n            axisNameFontSize: e.yaxisnamefontsize,\n            axisNameFontColor: e.yaxisnamefontcolor,\n            axisNameFontBold: e.yaxisnamefontbold,\n            axisNameFontItalic: e.yaxisnamefontitalic,\n            axisNameBgColor: e.yaxisnamebgcolor,\n            axisNameBorderColor: e.yaxisnamebordercolor,\n            axisNameAlpha: e.yaxisnamealpha,\n            axisNameFontAlpha: e.yaxisnamefontalpha,\n            axisNameBgAlpha: e.yaxisnamebgalpha,\n            axisNameBorderAlpha: e.yaxisnameborderalpha,\n            axisNameBorderPadding: e.yaxisnameborderpadding,\n            axisNameBorderRadius: e.yaxisnameborderradius,\n            axisNameBorderThickness: e.yaxisnameborderthickness,\n            axisNameBorderDashed: e.yaxisnameborderdashed,\n            axisNameBorderDashLen: e.yaxisnameborderdashlen,\n            axisNameBorderDashGap: e.yaxisnameborderdashgap,\n            axisNameWidth: e.yaxisnamewidth,\n            useEllipsesWhenOverflow: e.useellipseswhenoverflow,\n            rotateAxisName: (0, n.pluckNumber)(e.rotateyaxisname, 1),\n            axisName: e.yaxisname,\n            divLineColor: (0, n.pluck)(e.divlinecolor, a.getColor(t.divLineColor)),\n            divLineAlpha: (0, n.pluck)(e.divlinealpha, a.getColor(\"divLineAlpha\")),\n            divLineThickness: (0, n.pluckNumber)(e.divlinethickness, 2),\n            divLineIsDashed: Boolean((0, n.pluckNumber)(e.divlinedashed, e.divlineisdashed, 0)),\n            divLineDashLen: (0, n.pluckNumber)(e.divlinedashlen, 4),\n            divLineDashGap: (0, n.pluckNumber)(e.divlinedashgap, 2),\n            showAlternateGridColor: (0, n.pluckNumber)(e.showalternatehgridcolor, 1),\n            alternateGridColor: (0, n.pluck)(e.alternatehgridcolor, a.getColor(\"altHGridColor\")),\n            alternateGridAlpha: (0, n.pluck)(e.alternatehgridalpha, a.getColor(\"altHGridAlpha\")),\n            numDivLines: e.numdivlines,\n            axisMinValue: e.yaxisminvalue,\n            axisMaxValue: e.yaxismaxvalue,\n            setAdaptiveMin: e.setadaptiveymin,\n            adjustDiv: e.adjustdiv,\n            labelStep: e.yaxisvaluesstep,\n            showAxisValues: (0, n.pluckNumber)(e.showyaxisvalues, e.showyaxisvalue),\n            showLimits: (0, n.pluckNumber)(e.showyaxislimits, e.showlimits, this.showLimits),\n            showDivLineValues: (0, n.pluckNumber)(e.showdivlinevalues, e.showdivlinevalue),\n            showZeroPlane: e.showzeroplane,\n            zeroPlaneColor: e.zeroplanecolor,\n            zeroPlaneThickness: e.zeroplanethickness,\n            zeroPlaneAlpha: e.zeroplanealpha,\n            showZeroPlaneValue: e.showzeroplanevalue,\n            trendlineColor: e.trendlinecolor,\n            trendlineToolText: e.trendlinetooltext,\n            trendlineThickness: e.trendlinethickness,\n            trendlineAlpha: e.trendlinealpha,\n            showTrendlinesOnTop: e.showtrendlinesontop,\n            showAxisLine: (0, n.pluckNumber)(e.showyaxisline, e.showaxislines, e.drawAxisLines, 0),\n            axisLineThickness: (0, n.pluckNumber)(e.yaxislinethickness, e.axislinethickness, 1),\n            axisLineAlpha: (0, n.pluckNumber)(e.yaxislinealpha, e.axislinealpha, 100),\n            base: e.base,\n            logBase: e.logbase,\n            axisLineColor: (0, n.pluck)(e.yaxislinecolor, e.axislinecolor, \"#000000\"),\n            showMinorDivLineValues: (0, n.pluckNumber)(e.showminordivlinevalues, 0),\n            numMinorDivLines: e.numminordivlines\n          };\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    463: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t = e.getChildren(\"canvas\")[0],\n            o = t.getChildren(\"axisRefVisualCartesian\")[0],\n            i = {\n          zoomable: !0,\n          pannable: !0\n        },\n            l = e._feedAxesRawData(),\n            s = void 0,\n            c = void 0,\n            u = function u() {\n          return o.asyncDraw();\n        };\n\n        (0, a.componentFactory)(e, r[\"default\"], \"yAxis\", 1, l.yAxisConf), (0, a.componentFactory)(e, n[\"default\"], \"xAxis\", 1, l.xAxisConf), s = e.getChildren(\"yAxis\")[0], c = e.getChildren(\"xAxis\")[0], s.setLinkedItem(\"canvas\", t), c.setLinkedItem(\"canvas\", t), o.setLinkedItem(s.getId(), s), o.setLinkedItem(c.getId(), c), o.addExtEventListener(\"visiblerangeset\", u, c), o.addExtEventListener(\"visiblerangeset\", u, s), t.attachAxis(c, !1, e.zoomX ? i : {}), t.attachAxis(s, !0, e.zoomY ? i : {}), e._setCategories();\n      };\n      var a = o(118),\n          r = i(o(464)),\n          n = i(o(321));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n    },\n    464: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = u(o(294)),\n          r = u(o(465)),\n          n = u(o(298)),\n          i = u(o(466)),\n          l = o(118),\n          s = o(122),\n          c = o(301);\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = function h(e) {\n        return null !== e && e !== l.UNDEF && \"\" !== e && !isNaN(e);\n      },\n          d = {\n        wrtVisible: !0\n      },\n          g = l.preDefStr.POSITION_START,\n          f = l.preDefStr.POSITION_TOP,\n          m = l.preDefStr.POSITION_BOTTOM,\n          v = l.preDefStr.POSITION_END,\n          b = function b() {\n        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],\n            t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        if (0 === e.length) return [];\n        var o = e.length - 1,\n            a = t.length - 1,\n            r = [e[o]];\n\n        for (o--; o >= 0;) {\n          t[a] > e[o] ? (r.push(t[a]), a--) : (r.push(e[o]), o--);\n        }\n\n        return r;\n      },\n          y = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.config.scale = new r[\"default\"](), o.config.labelMap = [], o;\n        }\n\n        return p(t, e), t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.base = 10, t.showMinorDivLineValues = 1, t.numMinorDivLines = l.UNDEF;\n        }, t.prototype.getName = function () {\n          return \"log\";\n        }, t.prototype.configureAttributes = function (t) {\n          var o,\n              a = this.config,\n              r = this.getFromEnv(\"number-formatter\"),\n              n = this.getFromEnv(\"color-manager\");\n          e.prototype.configureAttributes.call(this, t), o = a.rawAttr, a.minorDivlinecolor = (0, s.convertColor)((0, l.pluck)(o.minorDivlinecolor, n.getColor(\"divLineColor\")), (0, l.pluckNumber)(o.minorDivLineAlpha, n.getColor(\"divLineAlpha\") / 2)), a.axisMinValue = r.getCleanValue(o.axisMinValue), a.axisMaxValue = r.getCleanValue(o.axisMaxValue), a.minorTicks = [], a.axisMinValue <= 0 && (a.axisMinValue = l.UNDEF), a.axisMaxValue <= 0 && (a.axisMaxValue = l.UNDEF), this.getScale().setBase(a.base), a.minorDivLineThickness = (0, l.pluckNumber)(o.minorDivLineThickness, 1), a.band.isDraw = 0;\n        }, t.prototype.generateTicks = function () {\n          var e = this.getScale().ticks();\n          return this.config._allTicks = e.slice(), e;\n        }, t.prototype.generateMinorTicks = function () {\n          var e = this.config,\n              t = e.base,\n              o = (0, i[\"default\"])(e.ticks),\n              a = void 0,\n              r = [],\n              n = Math.log(t) / Math.log(10),\n              l = Number(e.numMinorDivLines) || n % 1 ? 4 : 8,\n              s = t > 1 ? -1 : 1,\n              c = void 0,\n              u = void 0,\n              p = void 0,\n              h = void 0;\n          return o.forEach(function (e) {\n            var o = e[0],\n                n = e[1];\n\n            for (t > 1 ? c = Math.ceil(Math.log(n) / Math.log(t)) : t > 0 && t < 1 && (c = Math.floor(Math.log(n) / Math.log(t))), p = Math.pow(t, c) - Math.pow(t, c + s), u = p / (l + 1), a = 1; a <= l; ++a) {\n              o <= (h = Math.pow(t, c + s) + u * a) && n >= h && r.push(h);\n            }\n          }), r;\n        }, t.prototype._setAxisRange = function (e) {\n          var t = e.min,\n              o = t === undefined ? .1 : t,\n              a = e.max,\n              r = a === undefined ? 1 : a,\n              n = this.getScale().setDomain([o, r]).nice(),\n              i = this.config,\n              l = i.axisRange;\n          i.ticks = this.generateTicks(), i.minorTicks = this.generateMinorTicks();\n          var s = n.getDomain();\n          o = s[0], r = s[1], l.max = r, l.min = o, this.setVisibleConfig(o, r);\n        }, t.prototype.setDataLimit = function (e, t) {\n          var o,\n              a,\n              r = this.config,\n              n = r.axisMaxValue,\n              i = r.axisMinValue;\n          h(i) && Number(i) <= t && (t = i), h(n) && Number(n) >= e && (e = n), 0 === t && (t = 1), 0 === e && (e = r.base);\n          var s = this.getTrendLineLimits();\n          o = s[0], a = s[1];\n          var c = (0, l.extent)([o, a, t, e], function (e) {\n            return Number(e);\n          });\n          t = c[0], e = c[1], this._setAxisRange({\n            min: t,\n            max: e\n          });\n        }, t.prototype._parseLabel = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              s,\n              c,\n              u,\n              p,\n              h,\n              y,\n              x,\n              w,\n              k,\n              C = this.config,\n              N = this.getFromEnv(\"chart\").config,\n              S = C.axisRange,\n              E = C.isOpposit,\n              A = C.labels,\n              D = A.style,\n              T = C.isVertical,\n              L = S.max,\n              _ = S.min,\n              P = N.canvasBottom,\n              O = N.canvasLeft,\n              V = N.canvasRight,\n              M = N.canvasTop,\n              F = C.labelPadding,\n              I = this.getFromEnv(\"number-formatter\"),\n              B = C.labelMaxH,\n              R = C.labelMaxW,\n              j = C.axisStartPosition,\n              G = this.components,\n              H = C.minorTicks;\n          if (D.lineHeight && -1 !== (n = D.lineHeight).indexOf(\"px\") && (n = n.replace(\"px\", \"\"), n = parseFloat(n)), C.labels.isDraw) for (k = 1 !== this.getZoom(), w = G.labels, e = C.labels.step ? S.tickInterval * C.labels.step : S.tickInterval, r = C.labels.rotation, a = this.getVisibleConfig(), G.labelIndexArr = [], C.allTicks = c = b(C.ticks, C.minorTicks), x = T ? B : R, u = c.length, t = 0; t < u; t++) {\n            if (p = c[t], h = this.getPixel(p, d), (!(H.indexOf(p) >= 0) || C.showMinorDivLineValues) && !(y && h > y - x && h < y + x) && (!k || !(p < a.minValue || p > a.maxValue)) && (C.labels.drawNormalVal || C.labels.drawLimitVal && (p === _ || p === L)) && (C.labels.drawNormalVal || p === _ || p === L) && (C.labels.drawLimitVal || p !== _ && p !== L) && (0 !== C.showZeroPlaneValue || 0 !== C.showZeroPlane || 0 !== p)) {\n              if (1 === C.showZeroPlane && 1 === C.showZeroPlaneValue && (p < 0 && p + e > 0 || p > 0 && p - e < 0)) if (T) {\n                if (h + B >= this.getPixel(0, d) && this.getPixel(0, d) >= h - B) continue;\n              } else if (h + R >= this.getPixel(0, d) && this.getPixel(0, d) >= h - R) continue;\n              s = {\n                fill: D.color,\n                \"font-size\": D.fontSize\n              }, T ? (o = \"\" + (C.numberFormatterFn ? I[C.numberFormatterFn] : C.isPercent ? I.percentValue : I.yAxis).call(I, p), i = C.hasCategory && C.categories.category[t].labelPadding || 0, s[\"text-anchor\"] = E ? g : v, s.text = o, s.x = E ? (j || V) + F : (j || O) - F, s.y = i ? h + i : h, y = s.y) : (o = \"\" + (C.numberFormatterFn ? I[C.numberFormatterFn] : C.isPercent ? I.percentValue : I.xAxis).call(I, p), i = C.hasCategory && Number(C.categories.category[t].labelPadding) || 0, s.text = o, s.x = h, s.y = E ? (j || M) - F : (j || P) + F, i && (s.y += i), r ? (s[\"text-anchor\"] = E ? g : v, s[\"vertical-align\"] = \"middle\") : s[\"vertical-align\"] = E ? m : f, y = s.x), A.shiftX && (s.x += A.shiftX), A.shiftY && (s.y += A.shiftY), s.transform = (0, l.getSuggestiveRotation)(r, s.x, s.y), G.labelIndexArr.push(t), w[t] = w[t] || {\n                config: {\n                  props: {\n                    label: {}\n                  }\n                }\n              }, w[t].config.props.label.attr = s, w[t].config.props.label.css = o.css, w[t].config.value = p;\n            }\n          }\n        }, t.prototype._drawLabel = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c,\n              u = this,\n              p = u.config,\n              h = u.getFromEnv(\"animationManager\"),\n              d = p.labels.style,\n              g = p.axisContainer,\n              f = [],\n              m = u.components,\n              v = m.labelIndexArr,\n              b = {\n            fontFamily: d.fontFamily,\n            fontSize: d.fontSize,\n            fontWeight: d.fontWeight,\n            fontStyle: d.fontStyle,\n            lineHeight: d.lineHeight\n          };\n\n          if (p.labels.isDraw) {\n            for (c = m.labels, g.css(b), l = v.length, t = 0; t < l; t++) {\n              o = (s = c[e = v[t]].config.value) + \"_label\", i = u.getGraphicalElement(o), f.push(o), i = this.addGraphicalElement(o, h.setAnimation({\n                container: g,\n                el: i || \"text\",\n                attr: c[e].config.props.label.attr,\n                data: {\n                  value: s\n                },\n                component: this,\n                label: \"text\",\n                css: c[e].config.props.label.css\n              }));\n            }\n\n            a = (0, n[\"default\"])(p.labelMap, f);\n          } else a = p.labelMap;\n\n          p.labelMap = f, function (t) {\n            for (e = 0; e < t.length; ++e) {\n              (r = u.getGraphicalElement(t[e])) && u.removeGraphicalElement(r);\n            }\n          }(a);\n        }, t.prototype._getVMaxLabelDimention = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s = this.config,\n              c = this.getFromEnv(\"chart\"),\n              u = this.getFromEnv(\"smartLabel\"),\n              p = this.getFromEnv(\"number-formatter\"),\n              h = s.labels.style,\n              d = 0;\n\n          for (u.useEllipsesOnOverflow(c.config.useEllipsesWhenOverflow), u.setStyle({\n            fontSize: h.fontSize,\n            fontFamily: h.fontFamily,\n            lineHeight: h.lineHeight,\n            fontWeight: h.fontWeight\n          }), i = s.isPercent ? p.percentValue : p.xAxis, s.allTicks = e = b(s.ticks, s.minorTicks), t = e.length, a = 0; a < t; a++) {\n            l = e[a], r = \"\" + i.call(p, l), n = u.getOriSize(r), this.components.labels[a] = {\n              config: {\n                width: n.width,\n                height: n.height,\n                props: {\n                  label: {}\n                }\n              }\n            }, r.length > d && (o = n, d = r.length);\n          }\n\n          return o;\n        }, t.prototype._getHMaxLabelDimention = function () {\n          return this._getVMaxLabelDimention();\n        }, t.prototype.getCleanValue = function (e) {\n          var t = null;\n          return (e = Math.abs(e)) > 0 && (t = this.getFromEnv(\"number-formatter\").getCleanValue(e)), t;\n        }, t;\n      }(a[\"default\"]);\n\n      y.prototype.getTrendLineLimits = c.getTrendLineLimits, t[\"default\"] = y;\n    },\n    465: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = n(o(317)),\n          r = o(315);\n\n      function n(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function i(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var l = function l(e, t) {\n        return (t = Math.log(t / e)) ? function (o) {\n          return Math.log(o / e) / t;\n        } : (0, a[\"default\"])(t);\n      },\n          s = function s(e, t) {\n        return e < 0 ? function (o) {\n          return -Math.pow(-t, o) * Math.pow(-e, 1 - o);\n        } : function (o) {\n          return Math.pow(t, o) * Math.pow(e, 1 - o);\n        };\n      },\n          c = function c(e) {\n        return isFinite(e) ? +(\"1e\" + e) : e < 0 ? 0 : e;\n      },\n          u = function u(e) {\n        return 10 === e ? c : e === Math.E ? Math.exp : function (t) {\n          return Math.pow(e, t);\n        };\n      },\n          p = function p(e) {\n        return e === Math.E ? Math.log : 10 === e ? Math.log10 : 2 === e ? Math.log2 : function (t) {\n          return Math.log(t) / Math.log(e);\n        };\n      },\n          h = function h(e) {\n        return function (t) {\n          return -e(-t);\n        };\n      },\n          d = function (e) {\n        function t() {\n          var o;\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), (o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this, l, s)), o).setDomain([1, 10]), o.base = 10, o.logs = p(o.base), o.pows = u(o.base), o;\n        }\n\n        return i(t, e), t.prototype._rescaleLog = function () {\n          return this.logs = p(this.base), this.pows = u(this.base), this.getDomain()[0] < 0 && (this.logs = h(this.logs), this.pows = h(this.pows)), this;\n        }, t.prototype.setBase = function () {\n          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n          return this.base = Number(e), this._rescaleLog();\n        }, t.prototype.getBase = function () {\n          return this.base;\n        }, t.prototype.setDomain = function () {\n          var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 10];\n          return e.prototype.setDomain.call(this, t), this._rescaleLog();\n        }, t.prototype.nice = function () {\n          var e,\n              t,\n              o = this.getDomain(),\n              a = o[0],\n              r = o[1],\n              n = this.base;\n          return a === r && (a -= a / 100), e = Math.log(a) / Math.log(n), t = Math.log(r) / Math.log(n), (e % 1 || t % 1) && (a <= r ? (a = this.pows(Math.floor(e)), r = this.pows(Math.ceil(t))) : (a = this.pows(Math.ceil(e)), r = this.pows(Math.floor(t))), this.setDomain([a, r])), this;\n        }, t.prototype.ticks = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i = this.getDomain(),\n              l = i[0],\n              s = i[1],\n              c = 1,\n              u = 0,\n              p = [],\n              h = this.base;\n          if (l <= 0 || s <= 0) return p;\n\n          if (l > s) {\n            var d = this.getDomain();\n            s = d[0], l = d[1], c = 0;\n          }\n\n          for (h > 1 ? (t = e = Math.ceil(Math.log(s) / Math.log(h)), o = Math.floor(Math.log(l) / Math.log(h))) : h > 0 && h < 1 && (e = Math.floor(Math.log(s) / Math.log(h)), t = Math.ceil(Math.log(l) / Math.log(h)), o = e), r = e, n = t; n >= o; --n) {\n            l <= (a = this.pows(r)) && s >= a && (p[u++] = a), h > 1 ? r-- : r++;\n          }\n\n          return c ? p.reverse() : p;\n        }, t.prototype.copy = function () {\n          return (0, r.copyScale)(this, new t().setBase(this.base));\n        }, t;\n      }(n(r)[\"default\"]);\n\n      t[\"default\"] = d;\n    },\n    466: function _(e, t, o) {\n      \"use strict\";\n\n      function a(e, t) {\n        return [e, t];\n      }\n\n      t.__esModule = !0, t[\"default\"] = function (e, t) {\n        null !== t && void 0 !== t || (t = a);\n\n        for (var o = 0, r = e.length - 1, n = e[0], i = new Array(r < 0 ? 0 : r); o < r;) {\n          i[o] = t(n, n = e[++o]);\n        }\n\n        return i;\n      };\n    },\n    467: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(462)),\n          r = i(o(346)),\n          n = o(428);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.defaultPlotShadow = 1, o;\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"LogMSLine\";\n        }, t.prototype.getName = function () {\n          return \"LogMSLine\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Multi-series Line Chart\", t.defaultDatasetType = \"line\", t.zeroplanethickness = 1, t.enablemousetracking = !0, t.zeroplanealpha = 40, t.showzeroplaneontop = 0, t.enablemousetracking = !0, t.defaultcrosslinethickness = 1, n._setDefaultConfig.call(this);\n        }, t.prototype.getDSGroupdef = function () {}, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    468: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = n(o(461)),\n          r = n(o(409));\n\n      function n(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function i(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var l = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return i(t, e), t.getName = function () {\n          return \"LogStackedColumn2d\";\n        }, t.prototype.getName = function () {\n          return \"LogStackedColumn2d\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Stacked Log Column Chart\", t.isstacked = !0;\n        }, t.prototype.getDSGroupdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = l;\n    },\n    469: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(354)),\n          r = i(o(402)),\n          n = i(o(470));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.showValues = 0, o.isErrorChart = !0, o.eiMethods = {}, o;\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"ErrorBar2D\";\n        }, t.prototype.getName = function () {\n          return \"ErrorBar2D\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Error Bar Chart\", t.hasLegend = !0, t.defaultDatasetType = \"errorbar2d\", t.enablemousetracking = !0;\n        }, t.prototype.getDSGroupdef = function () {\n          return r[\"default\"];\n        }, t.prototype.getDSdef = function () {\n          return n[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    470: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t._checkPointerOverPlot = t._checkPointerOverErrorBar = t._firePlotEvent = t._rolloutResponseSetter = t._rolloverResponseSetter = t.removePlots = t._getHoveredPlot = undefined;\n      var a = o(118),\n          r = o(122),\n          n = s(o(331)),\n          i = o(125),\n          l = s(o(471));\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var u,\n          p,\n          h,\n          d,\n          g,\n          f = a.preDefStr.colors.AAAAAA,\n          m = a.preDefStr.ROUND,\n          v = a.preDefStr.PERCENTAGESTRING,\n          b = a.preDefStr.pStr,\n          y = a.preDefStr.sStr,\n          x = function x(e, t, o, a) {\n        var r = t.graphics,\n            n = t.errorBarHovered,\n            i = r && r.element,\n            l = e.getFromEnv(\"animationManager\"),\n            s = i && i.getData();\n        !n && i && 0 !== s.showHoverEffect && (l.setAnimationState(\"mouseOver\"), l.setAnimation({\n          el: i,\n          label: \"rect\",\n          component: a,\n          attr: i.getData().setRolloverAttr,\n          doNotRemove: !0\n        })), i && e.plotEventHandler(i, o, \"DataPlotRollOver\");\n      },\n          w = function w(e, t, o, a) {\n        var r = t.graphics,\n            n = t.errorBarHovered,\n            i = r && r.element,\n            l = e.getFromEnv(\"animationManager\"),\n            s = i && i.getData();\n        !n && i && 0 !== s.showHoverEffect && (l.setAnimationState(\"mouseOut\"), l.setAnimation({\n          el: i,\n          label: \"rect\",\n          component: a,\n          attr: i.getData().setRolloutAttr,\n          doNotRemove: !0\n        })), i && e.plotEventHandler(i, o, \"DataPlotRollOut\");\n      };\n\n      (0, i.addDep)({\n        name: \"errorbar2DColumnAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"].column\n      }), (0, i.addDep)({\n        name: \"errorbar2DErrorAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"].error\n      });\n\n      var k = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"errorBar2D\";\n        }, t.prototype.ErrorValueConfigure = function () {\n          var e,\n              t,\n              o,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              m,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V = this.config,\n              M = V.JSONData,\n              F = M.data,\n              I = F && F.length,\n              B = this.getFromEnv(\"chart-attrib\"),\n              R = this.components.data,\n              j = (0, a.parseUnsafeString)(B.yaxisname),\n              G = (0, a.parseUnsafeString)(B.xaxisname),\n              H = (0, a.pluckNumber)(B.seriesnameintooltip, 1),\n              W = (0, a.parseUnsafeString)((0, a.pluck)(B.tooltipsepchar, \", \")),\n              z = this.getFromEnv(\"number-formatter\"),\n              U = -Infinity,\n              J = Infinity,\n              K = this.getFromEnv(\"xAxis\").getTicksLen(),\n              q = Math.min(K, I),\n              Y = function Y(t) {\n            var r;\n            return V.showTooltip ? null === d ? r = !1 : void 0 !== t ? (s = [1, 2, 3, 4, 5, 6, 7, 99, 100, 101, 102, 120, 121], c = {\n              yaxisName: j,\n              xaxisName: G,\n              formattedValue: o.toolTipValue,\n              errorValue: h,\n              errorDataValue: o.errorToolTipValue,\n              errorPercentValue: o.errorPercentValue,\n              errorPercentDataValue: o.errorPercentValue,\n              positiveErrorValue: o.positiveErrorToolTipValue,\n              negativeErrorValue: o.negativeErrorToolTipValue,\n              label: o.label\n            }, r = (0, a.parseTooltext)(t, s, c, e, B, M)) : (H && (i = (0, a.getFirstValue)(M && M.seriesname)), r = i ? i + W : \"\", r += o.label ? o.label + W : \"\") : r = !1, r;\n          };\n\n          for (V.showTooltip = (0, a.pluckNumber)(B.showtooltip, 1), V.errorInPercent = l = (0, a.pluckNumber)(M.errorinpercent, B.errorinpercent), V.showValues = (0, a.pluckNumber)(M.showvalues, B.showvalues, 0), V.errorBarShadow = m = (0, a.pluckNumber)(B.errorbarshadow, B.showshadow, 1), V.ignoreEmptyDatasets = (0, a.pluckNumber)(M.ignoreemptydatasets, 0), S = (0, a.pluckNumber)(B.halferrorbar, 1), V.notHalfErrorBar = !(0, a.pluckNumber)(B.halferrorbar, 1), p = (0, r.getFirstAlpha)((0, a.pluck)(M.errorbaralpha, B.errorbaralpha, V.plotfillalpha)), V.errorBarWidthPercent = (0, a.pluckNumber)(M.errorbarwidthpercent, B.errorbarwidthpercent, 70), V.errorBarColor = (0, r.convertColor)((0, r.getFirstColor)((0, a.pluck)(M.errorbarcolor, B.errorbarcolor, f)), p), V.errorBarThickness = (0, a.pluckNumber)(M.errorbarthickness, B.errorbarthickness, 1), V.shadowOpacity = m ? p / 250 : 0, V.parentYAxis = x = (0, a.pluck)(M.parentyaxis && M.parentyaxis.toLowerCase(), b) === y ? 1 : 0, V.cumulativeValueOnErrorBar = (0, a.pluckNumber)(M.cumulativevalueonerrorbar, B.cumulativevalueonerrorbar, 1), O = 0; O < q; O++) {\n            (t = R[O]) && (e = F && F[O], o = t && t.config, _ = void 0, P = void 0, void 0 !== (0, a.pluckNumber)(e.value) && (t || (t = R[O] = {\n              graphics: {}\n            }), t.config || (o = R[O].config = {}), w = o.setValue, o.setErrorValue = h = z.getCleanValue(e.errorvalue), o.errorInPercent = (0, a.pluckNumber)(e.errorinpercent, l, 0), o.errorInPercent && (o.setErrorValue = h = (0, a.pluckNumber)((h / 100 * w).toFixed(2))), o.cumulativeValueOnErrorBar = (0, a.pluckNumber)(e.cumulativevalueonerrorbar, V.cumulativeValueOnErrorBar, 1), o.positiveErrorValue = z.getCleanValue((0, a.pluckNumber)(e.positiveerrorvalue, e.errorvalue)), o.errorInPercent && o.positiveErrorValue && (o.positiveErrorValue = (0, a.pluckNumber)((o.positiveErrorValue / 100 * w).toFixed(2))), o.positiveCumulativeErrorValue = w + (0, a.pluckNumber)(o.positiveErrorValue, o.setErrorValue), o.negativeErrorValue = z.getCleanValue((0, a.pluckNumber)(e.negativeerrorvalue, e.errorvalue)), o.errorInPercent && o.negativeErrorValue && (o.negativeErrorValue = (0, a.pluckNumber)((o.negativeErrorValue / 100 * w).toFixed(2))), o.negativeCumulativeErrorValue = w - (0, a.pluckNumber)(o.negativeErrorValue, o.setErrorValue), o.errorToolTipValue = z.dataLabels(h, x), o.negativeErrorToolTipValue = z.dataLabels(o.negativeErrorValue, x), o.negativeCumulativeErrorTooltipValue = z.dataLabels(o.negativeCumulativeErrorValue, x), o.positiveErrorToolTipValue = z.dataLabels(o.positiveErrorValue, x), o.positiveCumulativeErrorTooltipValue = z.dataLabels(o.positiveCumulativeErrorValue, x), o.errorPercentValue = Math.round(h / w * a.HUNDREDSTRING * a.HUNDREDSTRING) / a.HUNDREDSTRING + v, D = o.cumulativeValueOnErrorBar, o.notHalfErrorBar = V.notHalfErrorBar, o.halfErrorBar = S, o.showValue = (0, a.pluckNumber)(e.showvalue, V.showValues), o.hasErrorValue = void 0 !== (0, a.pluckNumber)(e.errorvalue) ? 1 : 0, k = o.errorValue = h, u = o.errorToolTipValue, d = u, n = Y(g = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, M.errorplottooltext, B.errorplottooltext, d)))), _ = P = void 0, (g = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, M.errorplottooltext, B.errorplottooltext, o.positiveErrorToolTipValue)))) && o.positiveErrorToolTipValue && (_ = Y(g)), (g = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, M.errorplottooltext, B.errorplottooltext, o.negativeErrorToolTipValue)))) && o.negativeErrorToolTipValue && (P = Y(g)), D && ((g = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, M.errorplottooltext, B.errorplottooltext, o.positiveCumulativeErrorTooltipValue)))) && o.positiveCumulativeErrorTooltipValue && (T = Y(g)), (g = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, M.errorplottooltext, B.errorplottooltext, o.negativeCumulativeErrorTooltipValue)))) && o.negativeCumulativeErrorTooltipValue && (L = Y(g))), E = o.positiveErrorValue, A = o.negativeErrorValue, (e.positiveerrorvalue || e.negativeerrorvalue) && (o.halfErrorBar = 0, o.notHalfErrorBar = !0), C = w + (null !== E ? E : h), N = w - (o.halfErrorBar ? 0 : A < 0 && w < 0 ? 0 : null !== A ? A : h), U = Math.max(U, C, N), J = Math.min(J, C, N), o.errorValueArr = [], null === o.positiveErrorValue && (o.positiveErrorValue = void 0), k = -o.positiveErrorValue, o.errorValueArr.push({\n              errorValue: k,\n              tooltext: D ? T : _ || n,\n              errorEdgeBar: !0\n            }), o.errorValueArr.push({\n              errorValue: k,\n              tooltext: _ || n\n            }), o.notHalfErrorBar && (k = o.negativeErrorValue, o.errorValueArr.push({\n              errorValue: k,\n              tooltext: D ? L : P || n,\n              errorEdgeBar: !0\n            }), o.errorValueArr.push({\n              errorValue: k,\n              tooltext: P || n\n            }))));\n          }\n\n          V.maxValue = U, V.minValue = J;\n        }, t.prototype.drawErrorValue = function () {\n          var e,\n              t,\n              o,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V = this.getJSONIndex(),\n              M = this.config,\n              F = this.getState(\"visible\"),\n              I = this.getFromEnv(\"chart\"),\n              B = this.getFromEnv(\"yAxis\"),\n              R = this.components.data,\n              j = M.errorBarThickness,\n              G = M.errorBarWidthPercent,\n              H = M.errorBarColor,\n              W = M.shadowOpacity,\n              z = this.getContainer(\"errorPlotGroup\"),\n              U = this.getContainer(\"errorShadowGroup\"),\n              J = M.scrollMinVal,\n              K = M.scrollMaxVal,\n              q = function q(e) {\n            return function () {\n              \"disappearing\" === e ? this.hide() : this.show();\n            };\n          },\n              Y = this.getFromEnv(\"animationManager\");\n\n          for (t = J; t < K; t++) {\n            if ((l = R[t]) && (_ = l.trackerConfig, (O = l.errorTrackerConfig = {}).errorTrackerArr = [], s = (c = l && l.config) && c.setValue, void 0 !== l)) if (l && (void 0 === s || null === s || \"\" === c.errorValue || void 0 === c.errorValue || null === c.errorValue && null === c.positiveErrorValue && null === c.negativeErrorValue)) for (w = l.graphics.error && l.graphics.error.length, o = 0; o < w; o++) {\n              l.graphics.error && l.graphics.error[o] && (Y.setAnimation({\n                el: l.graphics.error[o],\n                label: \"path\",\n                callback: q(\"disappearing\")\n              }), l.graphics.error[o].shadow({\n                opacity: 0\n              }));\n            } else {\n              for (l.errorBar && delete l.errorBar, v = c.errorValueArr, O.errorLen = w = v.length, !l.graphics.error && (l.graphics.error = []), C = V + \"_\" + t, r = c.setLink, S = s < 0, E = l._xPos, A = l._yPos, D = l._width, T = l._height, i = S ? A + T : A, n = E + D / 2, l.errorBar || (l.errorBar = []); w--;) {\n                N = null, O.errorTrackerArr[w] = {}, b = v[w], O.errorTrackerArr[w].tooltext = b.tooltext, L = b.errorStartValue, x = isNaN(L) ? i : B.getPixel(L), null === (y = b.errorValue) || isNaN(y) ? l.graphics.error && l.graphics.error[w] && Y.setAnimation({\n                  el: l.graphics.error[w],\n                  label: \"path\",\n                  callback: q(\"disappearing\")\n                }).shadow({\n                  opacity: 0\n                }) : (k = D * (G / 100) / 2, f = F ? -1 : 0, g = B.getPixel(B.getValue(isNaN(L) ? A : x) + y * f, {\n                  wrtVisible: !0\n                }), S && (g += T), p = g, h = n, P = (j = (0, a.pluckNumber)(b.errorBarThickness, j)) > 5 ? j / 2 : 2.5, p = Math.round(g) + j % 2 / 2, h = Math.round(n) + j % 2 / 2, l.errorBar[w] || (l.errorBar[w] = []), b.errorEdgeBar ? (d = [\"M\", h - k, p, \"H\", h + k], l.errorBar[w][1] = {\n                  _xPos: h - k - P,\n                  _yPos: p - P,\n                  _height: 2 * P,\n                  _width: 2 * (k + P),\n                  _toolText: b.tooltext\n                }) : (d = [\"M\", h, x, \"V\", p], l.errorBar[w][0] = {\n                  _xPos: h - P,\n                  _yPos: p < x ? p : x,\n                  _height: Math.abs(x - p),\n                  _width: 2 * P,\n                  _toolText: b.tooltext\n                }), e = {\n                  path: d,\n                  stroke: H = (0, a.pluck)(b.errorBarColor, H),\n                  \"stroke-width\": j,\n                  cursor: r ? \"pointer\" : \"\",\n                  \"stroke-linecap\": m\n                }, u = !l.graphics.error[w] && F ? \"appearing\" : F ? \"updating\" : \"disappearing\", N = l.graphics.error[w] = Y.setAnimation({\n                  el: l.graphics.error[w] || \"path\",\n                  container: z,\n                  component: this,\n                  attr: e,\n                  label: \"path\",\n                  state: u,\n                  callback: q(u)\n                }).shadow({\n                  opacity: W\n                }, U), I.config.enablemousetracking && N.data(\"groupId\", C).data(\"eventArgs\", _.eventArgs));\n              }\n\n              if (!c.notHalfErrorBar) for (o = 2; o < 4; o++) {\n                l.graphics.error && l.graphics.error[o] && Y.setAnimation({\n                  el: l.graphics.error[o],\n                  label: \"path\",\n                  callback: q(\"disappearing\")\n                }).shadow({\n                  opacity: 0\n                });\n              }\n            }\n          }\n        }, t.prototype._firePlotEvent = function (e, t, o) {\n          var a = this.getFromEnv(\"chart\"),\n              r = this.components.data[t],\n              n = this.getFromEnv(\"toolTipController\"),\n              i = r.graphics.element,\n              l = r.errorBarHovered,\n              s = r.config.setLink;\n          if (i) switch (e) {\n            case \"mouseover\":\n              this._decideTooltipType(t, o), x(a, r, o, this), s && (i.node.style.cursor = \"pointer\");\n              break;\n\n            case \"mouseout\":\n              n.hide(this.config.currentToolTip), w(a, r, o, this), s && (i.node.style.cursor = \"default\");\n              break;\n\n            case \"click\":\n              a.plotEventHandler(i, o);\n              break;\n\n            case \"mousemove\":\n              this._decideTooltipType(t, o), l && !r._isRollover ? (0 !== i.showHoverEffect && i.attr(i.getData().setRolloutAttr), r._isRollover = !0, r._isRollout = !1) : l || r._isRollout || (0 !== i.showHoverEffect && i.attr(i.getData().setRolloverAttr), r._isRollover = !1, r._isRollout = !0);\n          }\n        }, t.prototype._checkPointerOverErrorBar = function (e, t, o) {\n          var a,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d = this.components.data,\n              g = d[e];\n          if (g && (r = g.errorBar)) for (i = r && r.length; i--;) {\n            for (l = (n = r[i]) && n.length; l--;) {\n              if (n[l] && n[l]._xPos && (c = n[l]._xPos, u = n[l]._yPos, p = n[l]._height, h = n[l]._width, s = n[l]._toolText, a = t >= c && t <= c + h && o >= u && o <= u + p)) return {\n                pointIndex: e,\n                hovered: a,\n                pointObj: d[e],\n                toolText: s\n              };\n            }\n          }\n        }, t.prototype._checkPointerOverPlot = function (e, t, o) {\n          var a,\n              r,\n              n = this.components.data,\n              i = this.getFromEnv(\"chart-attrib\"),\n              l = this.config.JSONData,\n              s = n[e],\n              c = s && s.config;\n          if (s) return a = l.plottooltext || i.plottooltext ? \"\" : c.toolTipValue, (r = this._checkPointerOverErrorBar(e, t, o)) ? (s.errorBarHovered = !0, c.finalTooltext = r.toolText) : (r = this._checkPointerOverColumn(e, t, o), s.errorBarHovered = !1, r && (c.finalTooltext = !1 !== c.toolText && c.toolText + a)), r;\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o, a;\n          return o = this.getFromEnv(\"xAxis\").getValue(e), (a = Math.round(o)) - o > 0 ? this._checkPointerOverPlot(a, e, t) || this._checkPointerOverPlot(a - 1, e, t) : this._checkPointerOverPlot(a + 1, e, t) || this._checkPointerOverPlot(a, e, t);\n        }, t.prototype.removePlots = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.components,\n              n = r.removeDataArr,\n              i = r.pool || (r.pool = {\n            element: [],\n            hotElement: [],\n            label: []\n          }),\n              l = n.length,\n              s = this.getFromEnv(\"animationManager\");\n\n          for (o = 0; o < l; o++) {\n            if (e = n[0], n.splice(0, 1), e && e.graphics) {\n              for ((t = e.graphics).element && t.element.hide() && t.element.shadow({\n                opacity: 0\n              }), a = 0; a < 4; a++) {\n                t.error && t.error[a] && s.setAnimation({\n                  el: t.error[a],\n                  label: \"path\"\n                });\n              }\n\n              e.graphics.element && (i.element = i.element.concat(e.graphics.element)), e.graphics.hotElement && (i.hotElement = i.hotElement.concat(e.graphics.hotElement)), e.graphics.label && (i.label = i.label.concat(e.graphics.label));\n            }\n          }\n\n          r.pool = i;\n        }, t;\n      }(n[\"default\"]);\n\n      t.removePlots = u = k.prototype.removePlots, t._getHoveredPlot = p = k.prototype._getHoveredPlot, t._firePlotEvent = h = k.prototype._firePlotEvent, t._checkPointerOverPlot = d = k.prototype._checkPointerOverPlot, t._checkPointerOverErrorBar = g = k.prototype._checkPointerOverErrorBar, t._getHoveredPlot = p, t.removePlots = u, t._rolloverResponseSetter = x, t._rolloutResponseSetter = w, t._firePlotEvent = h, t._checkPointerOverErrorBar = g, t._checkPointerOverPlot = d, t[\"default\"] = k;\n    },\n    471: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(332),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        column: {\n          \"initial.dataset.errorBar2D\": n[\"default\"][\"initial.dataset.column\"]\n        },\n        error: {\n          \"initial.dataset.errorBar2D\": function initialDatasetErrorBar2D() {\n            return {\n              \"path.appearing\": [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }]\n            };\n          }\n        }\n      };\n    },\n    472: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(354)),\n          r = o(428),\n          n = i(o(473));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.useErrorGroup = !0, o.isErrorChart = !0, o.hasAnchor = !0, o.defaultPlotShadow = 1, o.axisPaddingLeft = 0, o.axisPaddingRight = 0, o.canvasPaddingModifiers = [\"anchor\", \"errorbar\"], o;\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"ErrorLine\";\n        }, t.prototype.getName = function () {\n          return \"ErrorLine\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Error Line Chart\", t.defaultDatasetType = \"errorline\", r._setDefaultConfig.call(this), this.zeroplanethickness = 1, this.zeroplanealpha = 40, t.showzeroplaneontop = 0, t.defaultcrosslinethickness = 1, t.enablemousetracking = !0;\n        }, t.prototype.getDSGroupdef = function () {}, t.prototype.getDSdef = function () {\n          return n[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    473: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = o(118),\n          r = o(122),\n          n = o(470),\n          i = u(o(346)),\n          l = o(125),\n          s = u(o(474)),\n          c = u(o(475));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = a.preDefStr.colors.AAAAAA,\n          d = a.preDefStr.ROUND,\n          g = a.preDefStr.PERCENTAGESTRING,\n          f = \"rgba(192,192,192,\" + (a.isIE ? .002 : 1e-6) + \")\",\n          m = Math,\n          v = m.round,\n          b = m.min,\n          y = m.max,\n          x = m.abs,\n          w = a.hasTouch ? a.TOUCH_THRESHOLD_PIXELS : a.CLICK_THRESHOLD_PIXELS;\n      (0, l.addDep)({\n        name: \"errorlineErrorAnimation\",\n        type: \"animationRule\",\n        extension: s[\"default\"]\n      }), (0, l.addDep)({\n        name: \"errorlineLineAnimation\",\n        type: \"animationRule\",\n        extension: c[\"default\"]\n      });\n\n      var k = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return p(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"errorLine\";\n        }, t.prototype.ErrorValueConfigure = function () {\n          var e,\n              t,\n              o,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              d,\n              f,\n              m,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P = this.getFromEnv(\"chart\"),\n              O = this.config,\n              V = P.config,\n              M = O.parentYAxis,\n              F = O.JSONData,\n              I = F.data,\n              B = P.getFromEnv(\"dataSource\").chart,\n              R = this.getFromEnv(\"xAxis\").getTicksLen(),\n              j = this.components.data,\n              G = this.getFromEnv(\"number-formatter\"),\n              H = O.linethickness,\n              W = -Infinity,\n              z = Infinity,\n              U = (0, a.parseUnsafeString)(B.yaxisname),\n              J = (0, a.parseUnsafeString)(B.xaxisname),\n              K = (0, a.pluck)(B.tooltipsepchar, \", \"),\n              q = (0, a.pluckNumber)(B.seriesnameintooltip, 1),\n              Y = function Y(t) {\n            var r;\n            return V.showtooltip ? null === c ? r = !1 : void 0 !== t ? (E = [1, 2, 3, 4, 5, 6, 7, 99, 100, 101, 102], A = {\n              yaxisName: U,\n              xaxisName: J,\n              formattedValue: o.toolTipValue,\n              errorValue: s,\n              errorDataValue: o.errorToolTipValue,\n              errorPercentValue: o.errorPercentValue,\n              errorPercentDataValue: o.errorPercentValue,\n              label: o.label\n            }, r = (0, a.parseTooltext)(t, E, A, e, B, F)) : (q && (D = (0, a.getFirstValue)(F && F.seriesname)), r = D ? D + K : \"\", r += o.label ? o.label + K : \"\") : r = !1, r;\n          };\n\n          for (O.errorBarShadow = x = (0, a.pluckNumber)(B.errorbarshadow, B.showshadow, 1), O.ignoreEmptyDatasets = (0, a.pluckNumber)(F.ignoreemptydatasets, 0), O.notHalfErrorBar = !(0, a.pluckNumber)(B.halferrorbar, 1), i = (0, r.getFirstAlpha)((0, a.pluck)(F.errorbaralpha, B.errorbaralpha, O.alpha)), O.errorBarWidth = (0, a.pluckNumber)(F.errorbarwidth, B.errorbarwidth, 5), O.errorBarColor = (0, r.convertColor)((0, r.getFirstColor)((0, a.pluck)(F.errorbarcolor, B.errorbarcolor, h)), i), l = (0, a.pluckNumber)(F.errorbarthickness, B.errorbarthickness, 1), O.errorBarThickness = l > H ? H : l, O.shadowOpacity = x ? i / 250 : 0, O.errorInPercent = T = (0, a.pluckNumber)(F.errorinpercent, B.errorinpercent), O.cumulativeValueOnErrorBar = (0, a.pluckNumber)(F.cumulativevalueonerrorbar, B.cumulativevalueonerrorbar, 1), _ = 0; _ < R; _++) {\n            e = I && I[_], I && e && (t = j[_], o = t && t.config, t || (t = j[_] = {\n              graphics: {}\n            }), t.config || (o = j[_].config = {}), C = o.setValue, o.notHalfErrorBar = O.notHalfErrorBar, s = G.getCleanValue(e.errorvalue), o.errorToolTipValue = G.dataLabels(s, M), o.setErrorValue = o.errorValue = N = s, o.hasErrorValue = void 0 !== (0, a.pluckNumber)(e.errorvalue) ? 1 : 0, n = o.errorToolTipValue, c = n, L = Y(u = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, F.errorplottooltext, B.errorplottooltext, c)))), o.errorInPercent = (0, a.pluckNumber)(e.errorinpercent, T, 0), o.errorInPercent && (o.setErrorValue = s = (0, a.pluckNumber)((s / 100 * C).toFixed(2))), o.cumulativeValueOnErrorBar = S = (0, a.pluckNumber)(e.cumulativevalueonerrorbar, O.cumulativeValueOnErrorBar, 1), o.positiveErrorValue = G.getCleanValue((0, a.pluckNumber)(e.positiveerrorvalue, e.errorvalue)), o.errorInPercent && o.positiveErrorValue && (o.positiveErrorValue = (0, a.pluckNumber)((o.positiveErrorValue / 100 * C).toFixed(2))), o.positiveCumulativeErrorValue = C + (0, a.pluckNumber)(o.positiveErrorValue, o.setErrorValue), o.negativeErrorValue = G.getCleanValue((0, a.pluckNumber)(e.negativeerrorvalue, e.errorvalue)), o.errorInPercent && o.negativeErrorValue && (o.negativeErrorValue = (0, a.pluckNumber)((o.negativeErrorValue / 100 * C).toFixed(2))), o.negativeCumulativeErrorValue = C - (0, a.pluckNumber)(o.negativeErrorValue, o.setErrorValue), o.errorToolTipValue = G.dataLabels(s, M), o.negativeErrorToolTipValue = G.dataLabels(o.negativeErrorValue, M), o.negativeCumulativeErrorTooltipValue = G.dataLabels(o.negativeCumulativeErrorValue, M), o.positiveErrorToolTipValue = G.dataLabels(o.positiveErrorValue, M), o.positiveCumulativeErrorTooltipValue = G.dataLabels(o.positiveCumulativeErrorValue, M), o.errorPercentValue = v(s / C * a.HUNDREDSTRING * a.HUNDREDSTRING) / a.HUNDREDSTRING + g, f = m = void 0, (u = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, F.errorplottooltext, B.errorplottooltext, o.positiveErrorToolTipValue)))) && o.positiveErrorToolTipValue && (f = Y(u)), (u = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, F.errorplottooltext, B.errorplottooltext, o.negativeErrorToolTipValue)))) && o.negativeErrorToolTipValue && (m = Y(u)), (e.positiveerrorvalue || e.negativeerrorvalue) && (o.halfErrorBar = 0, o.notHalfErrorBar = !0), S && ((u = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, F.errorplottooltext, B.errorplottooltext, o.positiveCumulativeErrorTooltipValue)))) && o.positiveCumulativeErrorTooltipValue && (p = Y(u)), (u = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(e.errorplottooltext, F.errorplottooltext, B.errorplottooltext, o.negativeCumulativeErrorTooltipValue)))) && o.negativeCumulativeErrorTooltipValue && (d = Y(u))), w = C + (null !== o.positiveErrorValue ? o.positiveErrorValue : s), k = C - (o.halfErrorBar ? 0 : o.negativeErrorValue < 0 && C < 0 ? 0 : null !== o.negativeErrorValue ? o.negativeErrorValue : s), W = y(W, w, k), z = b(z, w, k), null === s && (s = void 0), o.errorValueArr = [], null === o.positiveErrorValue && (o.positiveErrorValue = void 0), N = -o.positiveErrorValue, o.errorValueArr.push({\n              errorValue: N,\n              tooltext: S ? p : f || L,\n              errorEdgeBar: !0\n            }), o.errorValueArr.push({\n              errorValue: N,\n              tooltext: f || L\n            }), o.notHalfErrorBar && (N = o.negativeErrorValue, o.errorValueArr.push({\n              errorValue: N,\n              tooltext: S ? d : m || L,\n              errorEdgeBar: !0\n            }), o.errorValueArr.push({\n              errorValue: N,\n              tooltext: m || L\n            })), o.toolText = Y(o.setTooltext));\n          }\n\n          O.maxValue = W, O.minValue = z;\n        }, t.prototype._show = function () {\n          var e = this.chart,\n              t = this.yAxis,\n              o = this.graphics && this.graphics.container,\n              a = this.graphics && this.graphics.dataLabelContainer,\n              r = this.graphics && this.graphics.errorGroupContainer,\n              n = this.graphics && this.graphics.errorShadowContainer;\n          e._chartAnimation(), o.lineGroup.show(), o.anchorGroup.show(), o.anchorShadowGroup.show(), o.lineShadowGroup.show(), a.show(), this.setState(\"visible\", !0), r && r.show(), n && n.show(), this._conatinerHidden = !1, e._setAxisLimits(), t.draw(), e._drawDataset();\n        }, t.prototype._hide = function () {\n          var e = this.chart,\n              t = this.yAxis;\n          e._chartAnimation(), this.setState(\"visible\", !1), e._setAxisLimits(), t.draw(), e._drawDataset();\n        }, t.prototype.draw = function () {\n          e.prototype.draw.call(this), this.drawErrorValue();\n        }, t.prototype.drawErrorValue = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              g,\n              m,\n              b,\n              y,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _ = this.config,\n              P = this.getFromEnv(\"xAxis\").getTicksLen(),\n              O = this.getState(\"visible\"),\n              V = this.getFromEnv(\"yAxis\"),\n              M = this.components.data,\n              F = _.errorBarThickness,\n              I = _.errorBarWidth,\n              B = _.errorBarColor,\n              R = _.shadowOpacity,\n              j = this.getContainer(\"errorPlotGroup\"),\n              G = this.getContainer(\"errorShadowGroup\"),\n              H = F > 5 ? F / 2 : 2.5,\n              W = this.getFromEnv(\"animationManager\"),\n              z = function z(e) {\n            return function () {\n              \"disappearing\" === e && this.hide();\n            };\n          };\n\n          for (t = 0; t < P; t++) {\n            if (c = (u = (s = M[t]) && s.config) && u.setValue, void 0 !== s && void 0 !== c && null !== c) {\n              if ((L = s.errorTrackerConfig = {}).errorTrackerArr = [], y = u.errorValueArr, L.errorLen = S = y.length, !s.graphics.error && (s.graphics.error = []), !s.graphics.errorTracker && (s.graphics.errorTracker = []), \"\" === u.errorValue || void 0 === u.errorValue || null === u.errorValue && null === u.positiveErrorValue && null === u.negativeErrorValue) for (a = 0; a < S; a++) {\n                s.graphics.error && s.graphics.error[a] && W.setAnimation({\n                  el: s.graphics.error[a] || \"path\",\n                  label: \"path\",\n                  component: this,\n                  callback: z(\"disappearing\")\n                }).shadow({\n                  opacity: 0\n                });\n              } else {\n                for (n = u.setLink, D = s._xPos, l = T = s._yPos, i = D, s.errorBar && delete s.errorBar, s.errorBar = []; S--;) {\n                  A = null, L.errorTrackerArr[S] = {}, k = y[S], L.errorTrackerArr[S].tooltext = k.tooltext, N = l, null === (C = k.errorValue) || isNaN(C) ? s.graphics.error && s.graphics.error[S] && (s.graphics.error[S].hide(), s.graphics.error[S].shadow({\n                    opacity: 0\n                  })) : (E = I / 2, b = O ? 1 : 0, p = m = T + (V.getPixel(0) - V.getPixel(1)) * C * b, h = i, p = v(m) + F % 2 / 2, h = v(i) + F % 2 / 2, s.errorBar[S] || (s.errorBar[S] = []), k.errorEdgeBar ? (g = [\"M\", h - E, p, \"H\", h + E], s.errorBar[S][1] = {\n                    _xPos: h - E - H,\n                    _yPos: p - H,\n                    _height: 2 * H,\n                    _width: 2 * (E + H),\n                    _toolText: k.tooltext\n                  }) : (g = [\"M\", h, N, \"V\", p], s.errorBar[S][0] = {\n                    _xPos: h - H,\n                    _yPos: p < N ? p : N,\n                    _height: x(N - p),\n                    _width: 2 * H,\n                    _toolText: k.tooltext\n                  }), e = {\n                    path: g,\n                    stroke: B,\n                    \"stroke-width\": F,\n                    cursor: n ? \"pointer\" : \"\",\n                    \"stroke-linecap\": d\n                  }, r = !s.graphics.error[S] && O ? \"appearing\" : O ? \"updating\" : \"disappearing\", A = s.graphics.error[S] = W.setAnimation({\n                    el: s.graphics.error[S] || \"path\",\n                    state: r,\n                    attr: e,\n                    label: \"path\",\n                    component: this,\n                    container: j,\n                    callback: z(r)\n                  }), \"disappearing\" !== r && A.show(), A && A.shadow({\n                    opacity: R\n                  }, G), L.errorTrackerArr[S].attr = {\n                    path: g,\n                    stroke: f,\n                    \"stroke-width\": F < w ? w : F,\n                    cursor: n ? \"pointer\" : \"\"\n                  });\n                }\n\n                if (!u.notHalfErrorBar) for (a = 2; a < 4; a++) {\n                  s.graphics.error && s.graphics.error[a] && W.setAnimation({\n                    el: s.graphics.error[a] || \"path\",\n                    label: \"path\",\n                    component: this,\n                    callback: z(\"disappearing\")\n                  }).shadow({\n                    opacity: 0\n                  });\n                }\n              }\n            } else if (s && s.graphics.error) for (o = 0; o < s.graphics.error.length; o++) {\n              s.graphics.error && s.graphics.error[o] && W.setAnimation({\n                el: s.graphics.error[o] || \"path\",\n                label: \"path\",\n                component: this,\n                callback: z(\"disappearing\")\n              }).shadow({\n                opacity: 0\n              });\n            }\n          }\n        }, t.prototype._firePlotEvent = function (e, t, o) {\n          n._firePlotEvent.call(this, e, t, o);\n        }, t.prototype._checkPointerOverErrorBar = function (e, t, o) {\n          return n._checkPointerOverErrorBar.call(this, e, t, o);\n        }, t.prototype._checkPointerOverPlot = function (e, t, o) {\n          var a,\n              r = this.components.data[e],\n              n = r && r.config;\n          if (r) return (a = this.isWithinShape(r, e, t, o)) ? (r.errorBarHovered = !1, n.finalTooltext = !1 !== n.toolText && n.toolText) : (a = this._checkPointerOverErrorBar(e, t, o)) && (r.errorBarHovered = !0, n.finalTooltext = a.toolText), a;\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          return n._getHoveredPlot.call(this, e, t);\n        }, t.prototype.getCanvasPadding = function () {\n          var e,\n              t,\n              o,\n              r,\n              n,\n              i,\n              l = .5 * this.config.errorBarWidth,\n              s = this.components || {},\n              c = this.getFromEnv(\"chart\"),\n              u = c.config.dataLabelStyle,\n              p = s.data || [],\n              h = p[0],\n              d = p[p.length - 1],\n              g = {},\n              f = c.getFromEnv(\"smartLabel\"),\n              m = {\n            paddingLeft: 0,\n            paddingRight: 0\n          };\n          return h && (i = (e = h.config).showValue, o = e && e.anchorProps || {}, i && (t = e.displayValue, f.useEllipsesOnOverflow(c.config.useEllipsesWhenOverflow), f.setStyle(u), g = f.getOriSize(t)), e.setValue && (r = y((0, a.pluckNumber)(o.radius, 0), l) + (0, a.pluckNumber)(o.borderThickness, 0), n = (g.width || 0) / 2), m.paddingLeft = y(r, n)), d && (i = (e = d.config).showValue, o = e && e.anchorProps || {}, i && (t = e.displayValue, f.setStyle(u), g = f.getOriSize(t)), e.setValue && (r = y((0, a.pluckNumber)(o.radius, 0), l) + (0, a.pluckNumber)(o.borderThickness, 0), n = (g.width || 0) / 2), m.paddingRight = y(r, n)), m;\n        }, t.prototype.removePlots = function () {\n          n.removePlots.call(this);\n        }, t;\n      }(i[\"default\"]);\n\n      t[\"default\"] = k;\n    },\n    474: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.errorLine\": function initialDatasetErrorLine() {\n          return {\n            \"path.appearing\": function pathAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                startEnd: {\n                  start: .5,\n                  end: 1\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"*\": null\n          };\n        }\n      };\n    },\n    475: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"*.dataset.errorLine\": n[\"default\"][\"*.dataset.line\"]\n      };\n    },\n    476: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = n(o(414)),\n          r = n(o(477));\n\n      function n(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function i(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var l = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.isXY = !0, o.defaultZeroPlaneHighlighted = !1, o.useErrorGroup = !0, o.isErrorChart = !0, o.hasAnchor = !0, o.initAnimation = !0, o;\n        }\n\n        return i(t, e), t.getName = function () {\n          return \"ErrorScatter\";\n        }, t.prototype.getName = function () {\n          return \"ErrorScatter\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Error Scatter Chart\", t.defaultDatasetType = \"errorscatter\", t.enablemousetracking = !0;\n        }, t.prototype.getDSGroupdef = function () {}, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = l;\n    },\n    477: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = u(o(418)),\n          r = o(118),\n          n = o(122),\n          i = u(o(419)),\n          l = o(125),\n          s = u(o(478)),\n          c = u(o(479));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = r.preDefStr.colors.AAAAAA,\n          d = r.preDefStr.ROUND,\n          g = r.preDefStr.PERCENTAGESTRING,\n          f = \"M\";\n      (0, l.addDep)({\n        name: \"errorscatterAnimation\",\n        type: \"animationRule\",\n        extension: s[\"default\"]\n      }), (0, l.addDep)({\n        name: \"errorscatterErrorAnimation\",\n        type: \"animationRule\",\n        extension: c[\"default\"]\n      });\n\n      var m = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return p(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"errorScatter\";\n        }, t.prototype.ErrorValueConfigure = function () {\n          var e,\n              t,\n              o,\n              a,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              d,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H,\n              W,\n              z,\n              U,\n              J,\n              K,\n              q,\n              Y,\n              X,\n              Q,\n              Z,\n              $,\n              ee,\n              te,\n              oe,\n              ae = this.getFromEnv(\"chart\"),\n              re = this.config,\n              ne = re.JSONData,\n              ie = this.getFromEnv(\"dataSource\").categories && this.getFromEnv(\"dataSource\").categories[0].category,\n              le = this.getFromEnv(\"chart-attrib\"),\n              se = ne.data,\n              ce = se && se.length || 0,\n              ue = this.components.data,\n              pe = this.getFromEnv(\"number-formatter\"),\n              he = (0, r.pluck)(le.tooltipsepchar, \", \"),\n              de = (0, r.parseUnsafeString)(le.yaxisname),\n              ge = (0, r.parseUnsafeString)(le.xaxisname),\n              fe = re.parentYAxis,\n              me = -Infinity,\n              ve = +Infinity,\n              be = me,\n              ye = ve,\n              xe = ve,\n              we = me,\n              ke = function ke(t, a) {\n            var n;\n            return re.showTooltip ? null === N ? n = !1 : void 0 !== t ? (D = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109], T = {\n              yaxisName: de,\n              xaxisName: ge,\n              yDataValue: N,\n              xDataValue: o.label,\n              formattedValue: o.toolTipValue,\n              horizontalErrorValue: y,\n              horizontalErrorDataValue: w,\n              verticalErrorValue: x,\n              verticalErrorDataValue: k,\n              horizontalErrorPercentValue: E,\n              verticalErrorPercentValue: A,\n              label: o.label,\n              errorValue: a,\n              errorDataValue: a,\n              errorPercentValue: o.errorPercentValue,\n              errorPercentDataValue: o.errorPercentValue\n            }, n = (0, r.parseTooltext)(t, D, T, e, le, ne)) : null === N ? n = !1 : (re.seriesNameInTooltip && (L = (0, r.getFirstValue)(ne && ne.seriesname)), n = L ? L + he : \"\", n += C.x ? pe.xAxis(C.x) + he : \"\", n += o.toolTipValue) : n = !1, n;\n          };\n\n          for (re.errorBarShadow = i = (0, r.pluckNumber)(le.errorbarshadow, le.showshadow, 0), re.ignoreEmptyDatasets = (0, r.pluckNumber)(ne.ignoreemptydatasets, 0), re.notHalfErrorBar = !(0, r.pluckNumber)(le.halferrorbar, 1), re.errorBarAlpha = (0, n.getFirstAlpha)((0, r.pluck)(ne.errorbaralpha, le.errorbaralpha)), re.errorBarWidth = l = (0, r.pluckNumber)(ne.errorbarwidth, le.errorbarwidth, 5), re.errorBarColor = s = (0, n.convertColor)((0, n.getFirstColor)((0, r.pluck)(ne.errorbarcolor, le.errorbarcolor, h)), void 0), re.errorBarThickness = a = (0, r.pluckNumber)(ne.errorbarthickness, le.errorbarthickness, 1), re.shadowOpacity = i ? NaN : 0, re.halfHorizontalErrorBar = c = (0, r.pluckNumber)(le.halfhorizontalerrorbar, 1), re.halfVerticalErrorBar = u = (0, r.pluckNumber)(le.halfverticalerrorbar, 1), void 0 === re.initAnimation && (re.initAnimation = ae.initAnimation), p = (0, r.pluck)(ne.horizontalerrorbaralpha, ne.errorbaralpha, le.horizontalerrorbaralpha, void 0), d = (0, r.pluckNumber)(ne.verticalerrorbaralpha, ne.errorbaralpha, le.verticalerrorbaralpha, void 0), f = (0, n.convertColor)((0, r.pluck)(ne.horizontalerrorbarcolor, ne.errorbarcolor, le.horizontalerrorbarcolor, s), p), m = (0, n.convertColor)((0, r.pluck)(ne.verticalerrorbarcolor, ne.errorbarcolor, le.verticalerrorbarcolor, s), d), v = (0, r.pluckNumber)(ne.horizontalerrorbarthickness, ne.errorbarthickness, le.horizontalerrorbarthickness, a), b = (0, r.pluckNumber)(ne.verticalerrorbarthickness, ne.errorbarthickness, le.verticalerrorbarthickness, a), re.horizontalErrorBarWidth = (0, r.pluckNumber)(ne.horizontalerrorbarwidth, le.horizontalerrorbarwidth, l), re.verticalErrorBarWidth = (0, r.pluckNumber)(ne.verticalerrorbarwidth, le.verticalerrorbarwidth, l), re.cumulativeValueOnErrorBar = (0, r.pluckNumber)(ne.cumulativevalueonerrorbar, le.cumulativevalueonerrorbar, 1), oe = 0; oe < ce; oe++) {\n            se && (e = se && se[oe], t = ue[oe], o = t && t.config, t || (t = ue[oe] = {\n              graphics: {}\n            }), t.config || (o = ue[oe].config = {}), C = o.setValue, o.errorValue = e.errorvalue, o.cumulativeValueOnErrorBar = $ = (0, r.pluckNumber)(e.cumulativevalueonerrorbar, re.cumulativeValueOnErrorBar, 1), o.hErrorValue = y = pe.getCleanValue((0, r.pluck)(e.horizontalerrorvalue, e.errorvalue)), w = pe.xAxis(y), o.vErrorValue = x = pe.getCleanValue((0, r.pluck)(e.verticalerrorvalue, e.errorvalue)), k = pe.dataLabels(x), o.hPositiveErrorValue = I = pe.getCleanValue((0, r.pluck)(e.horizontalpositiveerrorvalue, e.positiveerrorvalue, y)), o.hNegativeErrorValue = F = pe.getCleanValue((0, r.pluck)(e.horizontalnegativeerrorvalue, e.negativeerrorvalue, y)), o.vPositiveErrorValue = M = pe.getCleanValue((0, r.pluck)(e.verticalpositiveerrorvalue, e.positiveerrorvalue, x)), o.vNegativeErrorValue = K = pe.getCleanValue((0, r.pluck)(e.verticalnegativeerrorvalue, e.negativeerrorvalue, x)), E = Math.round(y / C.x * r.HUNDREDSTRING * r.HUNDREDSTRING) / r.HUNDREDSTRING + g, A = Math.round(x / C.y * r.HUNDREDSTRING * r.HUNDREDSTRING) / r.HUNDREDSTRING + g, R = pe.dataLabels(I, fe), B = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, R))), H = pe.dataLabels(F, fe), U = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, H))), z = pe.dataLabels(M, fe), X = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, z))), te = pe.dataLabels(K, fe), ee = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, te))), j = Q = Z = q = void 0, $ && (G = pe.dataLabels(C.x + I, fe), j = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, G))), W = pe.dataLabels(C.x - F, fe), Q = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, W))), J = pe.dataLabels(C.y + M, fe), Z = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, J))), Y = pe.dataLabels(C.y - K, fe), q = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(e.errorplottooltext, ne.errorplottooltext, le.errorplottooltext, Y)))), ie && ie[oe] && (o.label = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(ie[oe].tooltext, ie[oe].label)))), e.horizontalpositiveerrorvalue || e.positiveerrorvalue || e.horizontalnegativeerrorvalue || e.negativeerrorvalue ? o.halfHorizontalErrorBar = c = 0 : o.halfHorizontalErrorBar = c = re.halfHorizontalErrorBar, e.verticalpositiveerrorvalue || e.positiveerrorvalue || e.verticalnegativeerrorvalue || e.negativeerrorvalue ? o.halfVerticalErrorBar = u = 0 : o.halfVerticalErrorBar = u = re.halfVerticalErrorBar, null !== C.x && (_ = C.x + Number(I), P = C.x - (c ? 0 : Number(F)), we = Math.max(we, _, P), xe = Math.min(xe, _, P)), null !== C.y && (_ = C.y + Number(M), P = C.y - (u ? 0 : Number(K)), be = Math.max(be, _, P), ye = Math.min(ye, _, P)), o.useHorizontalErrorBar = (0, r.pluckNumber)(e.usehorizontalerrorbar, ne.usehorizontalerrorbar, le.usehorizontalerrorbar, 0), o.useVerticalErrorBar = (0, r.pluckNumber)(e.useverticalerrorbar, ne.useverticalerrorbar, le.useverticalerrorbar, 1), o.errorValueConf = {}, (O = o.errorValueConf.horizontal = {}).mandatory = {}, O.mandatory.marker = {\n              errorValue: -(null === I ? void 0 : I),\n              tooltext: ke(B, R),\n              errorBarColor: f,\n              isHorizontal: !0,\n              errorBarThickness: v,\n              shadowOpacity: i ? p / 250 : 0\n            }, O.mandatory.limit = {\n              errorValue: -(null === I ? void 0 : I),\n              tooltext: $ ? ke(j, G) : ke(B, R),\n              errorBarColor: f,\n              isHorizontal: !0,\n              errorBarThickness: v,\n              shadowOpacity: i ? p / 250 : 0,\n              errorEdgeBar: !0\n            }, O.optional = {}, O.optional.marker = {\n              errorValue: F,\n              tooltext: ke(U, H),\n              errorBarColor: f,\n              isHorizontal: !0,\n              errorBarThickness: v,\n              shadowOpacity: i ? p / 250 : 0\n            }, O.optional.limit = {\n              errorValue: F,\n              tooltext: $ ? ke(Q, W) : ke(U, H),\n              errorBarColor: f,\n              isHorizontal: !0,\n              errorBarThickness: v,\n              shadowOpacity: i ? p / 250 : 0,\n              errorEdgeBar: !0\n            }, (V = o.errorValueConf.vertical = {}).mandatory = {}, V.mandatory.marker = {\n              errorValue: -(null === M ? void 0 : M),\n              tooltext: ke(X, z),\n              errorBarColor: m,\n              errorBarThickness: b,\n              shadowOpacity: i ? d / 250 : 0\n            }, V.mandatory.limit = {\n              errorValue: -(null === M ? void 0 : M),\n              tooltext: $ ? ke(Z, J) : ke(X, z),\n              errorBarColor: m,\n              errorBarThickness: b,\n              shadowOpacity: i ? d / 250 : 0,\n              errorEdgeBar: !0\n            }, V.optional = {}, V.optional.marker = {\n              errorValue: K,\n              tooltext: ke(ee, te),\n              errorBarColor: m,\n              errorBarThickness: b,\n              shadowOpacity: i ? d / 250 : 0\n            }, V.optional.limit = {\n              errorValue: K,\n              tooltext: $ ? ke(q, Y) : ke(ee, te),\n              errorBarColor: m,\n              errorBarThickness: b,\n              shadowOpacity: i ? d / 250 : 0,\n              errorEdgeBar: !0\n            }, C = o.setValue, N = o.formatedVal, re.showTooltip ? void 0 !== o.setTooltext ? (D = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 99, 100, 101, 102, 103, 104, 105, 106, 107, 109], T = {\n              yaxisName: de,\n              xaxisName: ge,\n              yDataValue: N,\n              xDataValue: o.label,\n              formattedValue: o.toolTipValue,\n              horizontalErrorValue: y,\n              horizontalErrorDataValue: w,\n              verticalErrorValue: x,\n              verticalErrorDataValue: k,\n              horizontalErrorPercentValue: E,\n              verticalErrorPercentValue: A,\n              label: o.label\n            }, S = (0, r.parseTooltext)(o.setTooltext, D, T, e, le, ne)) : null === N ? S = !1 : (re.seriesNameInTooltip && (L = (0, r.getFirstValue)(ne && ne.seriesname)), S = L ? L + he : \"\", S += C.x ? pe.xAxis(C.x) + he : \"\", S += o.toolTipValue) : S = !1, o.toolText = S);\n          }\n\n          re.xMax = we, re.xMin = xe, re.yMin = ye, re.yMax = be;\n        }, t.prototype.drawErrorValue = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              g,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H,\n              W,\n              z,\n              U,\n              J = this.config.JSONData,\n              K = this.config,\n              q = J.data,\n              Y = q && q.length,\n              X = this.getState(\"visible\"),\n              Q = this.getFromEnv(\"xAxis\"),\n              Z = this.getFromEnv(\"yAxis\"),\n              $ = this.components.data,\n              ee = K.shadowOpacity,\n              te = this.getContainer(\"errorPlotGroup\"),\n              oe = this.getContainer(\"errorShadowGroup\"),\n              ae = this.getFromEnv(\"animationManager\"),\n              re = [],\n              ne = function ne(e) {\n            return function () {\n              \"disappearing\" === e && this.hide();\n            };\n          };\n\n          for (t = 0; t < Y; t++) {\n            if ((U = (h = $[t]).errorTrackerConfig = {}).errorTrackerArr = [], g = (v = h && h.config) && v.setValue, G = v.errorValueConf, void 0 !== h && void 0 !== g && null !== g && G) {\n              if (z = Object.keys(a = h.graphics), null === v.vErrorValue && null === v.vPositiveErrorValue && null === v.vNegativeErrorValue) for (j = 0; j < z.length; j++) {\n                z[j].match(/error-horizontal-/) && (ae.setAnimation({\n                  el: a[z[j]],\n                  state: \"disappearing\",\n                  callback: ne(\"disappearing\")\n                }), a[z[j]].shadow({\n                  opacity: 0\n                }));\n              }\n              if (null === v.hErrorValue && null === v.hPositiveErrorValue && null === v.vPositiveErrorValue) for (j = 0; j < z.length; j++) {\n                z[j].match(/error-vertical-/) && (ae.setAnimation({\n                  el: a[z[j]],\n                  state: \"disappearing\",\n                  callback: ne(\"disappearing\")\n                }), a[z[j]].shadow({\n                  opacity: 0\n                }));\n              }\n              if (!(null === v.hErrorValue && null === v.vErrorValue && v.hPositiveErrorValue && v.hNegativeErrorValue && v.vPositiveErrorValue && v.vNegativeErrorValue)) for (H in c = v.setLink, F = h._xPos, p = h._yPos, u = F, G) {\n                if (G.hasOwnProperty(H)) for (A in D = G[H]) {\n                  if (D.hasOwnProperty(A)) for (_ in T = D[A]) {\n                    if (T.hasOwnProperty(_)) {\n                      if (m = void 0, L = T[_], e = {}, M = null, (U.errorTrackerArr[0] = {}).tooltext = L.tooltext, O = p, P = L.errorValue, b = !v.useHorizontalErrorBar && \"horizontal\" === H, y = !v.useVerticalErrorBar && \"vertical\" === H, x = v.halfHorizontalErrorBar && \"horizontal\" === H && \"optional\" === A, w = v.halfVerticalErrorBar && \"vertical\" === H && \"optional\" === A, b || y || x || w) m = \"disappearing\";else if (null === P || void 0 === P || isNaN(P)) m = \"disappearing\";else {\n                        if (s = L.errorBarColor, r = L.isHorizontal, n = L.errorBarThickness, l = r ? K.horizontalErrorBarWidth : K.verticalErrorBarWidth, V = X ? l / 2 : 0, E = X ? -1 : 0, W = n > 5 ? n / 2 + .5 : 2.75, r) {\n                          if (k = S = Q.getPixel(h.config._x + P * E), C = u, k = Math.round(O) + n % 2 / 2, C = Math.round(S) + n % 2 / 2, L.errorEdgeBar) for (N = [f, C, k - V, \"V\", k + V], I = 2 * V, B = k - V, R = W; R < I; R += 2 * W) {\n                            re.push({\n                              x: C,\n                              y: B + R,\n                              r: W,\n                              index: t,\n                              data: h,\n                              toolText: L.tooltext,\n                              barType: \"h\"\n                            });\n                          } else for (N = [f, u, k, \"H\", C], I = Math.abs(u - C), B = u > C ? C : u, R = W; R < I; R += 2 * W) {\n                            re.push({\n                              x: B + R,\n                              y: k,\n                              r: W,\n                              index: t,\n                              data: h,\n                              toolText: L.tooltext,\n                              barType: \"h\"\n                            });\n                          }\n                        } else if (k = S = Z.getPixel(h.config._y + P * E), C = u, k = Math.round(S) + n % 2 / 2, C = Math.round(u) + n % 2 / 2, L.errorEdgeBar) for (N = [f, C - V, k, \"H\", C + V], I = 2 * V, B = C - V, R = W; R <= I; R += 2 * W) {\n                          re.push({\n                            x: B + R,\n                            y: k,\n                            r: W,\n                            index: t,\n                            data: h,\n                            toolText: L.tooltext,\n                            barType: \"v\"\n                          });\n                        } else for (N = [f, C, O, \"V\", k], I = Math.abs(O - k), B = O > k ? k : O, R = W; R <= I; R += 2 * W) {\n                          re.push({\n                            x: C,\n                            y: B + R,\n                            r: W,\n                            index: t,\n                            data: h,\n                            toolText: L.tooltext,\n                            barType: \"v\"\n                          });\n                        }\n                        e = {\n                          path: N,\n                          \"stroke-width\": X ? n : 0,\n                          stroke: s,\n                          cursor: c ? \"pointer\" : \"\",\n                          \"stroke-linecap\": d\n                        };\n                      }\n                      o = [\"error\", H, A, _].join(\"-\"), m || (m = a[o] ? \"updating\" : \"appearing\"), (a[o] || \"disappearing\" !== m) && (M = a[o] = ae.setAnimation({\n                        el: a[o] || \"path\",\n                        container: te,\n                        component: this,\n                        attr: e,\n                        state: m,\n                        label: \"path\",\n                        callback: ne(m)\n                      }), \"disappearing\" !== m && M.show(), M.shadow({\n                        opacity: \"disappearing\" === m ? 0 : ee\n                      }, oe));\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          re.length && (this.config.dataTreeB = new i[\"default\"]().buildKdTree(re)), K.initAnimation = !1;\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o, a, r, n, i, l;\n          return (o = this.config.dataTree.getNeighbour({\n            x: e,\n            y: t\n          }, !0)) ? (r = o.data.config.toolText, o.data.config.finalTooltext = r, i = o.data.config.hoverEffects, (l = o.data.graphics.element).data(\"hoverEnabled\", i.enabled), i.enabled && l.attr(l.getData().setRolloverAttr), {\n            pointIndex: o.index,\n            hovered: !0,\n            pointObj: o.data\n          }) : (a = this.config.dataTreeB && this.config.dataTreeB.getNeighbour({\n            x: e,\n            y: t\n          }, !0)) ? (\"h\" === a.barType ? n = a.toolText : \"v\" === a.barType && (n = a.toolText), a.data.config.finalTooltext = n, (l = a.data.graphics.element).data(\"hoverEnabled\", !1), l.attr(l.getData().setRolloutAttr), {\n            pointIndex: a.index,\n            hovered: !0,\n            pointObj: a.data\n          }) : void 0;\n        }, t.prototype.removePlots = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.components,\n              n = r.removeDataArr,\n              i = r.pool || (r.pool = {\n            element: [],\n            hotElement: [],\n            label: []\n          }),\n              l = this.getFromEnv(\"animationManager\"),\n              s = n.length,\n              c = function c() {\n            this.hide(), this.shadow({\n              opacity: 0\n            });\n          };\n\n          for (o = 0; o < s; o++) {\n            if (e = n[0], n.splice(0, 1), e && e.graphics) {\n              for (a in t = e.graphics) {\n                t.hasOwnProperty(a) && l.setAnimation({\n                  el: t[a],\n                  component: this,\n                  attr: {},\n                  state: \"disappering\",\n                  callback: c\n                });\n              }\n\n              e.graphics.element && (i.element = i.element.concat(e.graphics.element)), e.graphics.label && (i.label = i.label.concat(e.graphics.label));\n            }\n          }\n\n          r.pool = i;\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = m;\n    },\n    478: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"initial.dataset.errorScatter\": n[\"default\"][\"initial.dataset.line\"]\n      };\n    },\n    479: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(474),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"initial.dataset.errorScatter\": n[\"default\"][\"initial.dataset.errorLine\"]\n      };\n    },\n    480: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(354)),\n          r = i(o(347)),\n          n = o(428);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"InverseMSArea\";\n        }, t.prototype.getName = function () {\n          return \"InverseMSArea\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Inverted Y-Axis Multi-series Area Chart\", t.defaultDatasetType = \"area\", t.isInverse = !0, t.zeroplanethickness = 2, t.zeroplanealpha = 80, t.showzeroplaneontop = 1, t.enablemousetracking = !0, t.defaultcrosslinethickness = 1, n._setDefaultConfig.call(this);\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t.prototype.getDSGroupdef = function () {}, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    481: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(354)),\n          r = i(o(331)),\n          n = i(o(402));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"InverseMSColumn2d\";\n        }, t.prototype.getName = function () {\n          return \"InverseMSColumn2d\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Inverted Y-Axis Multi-series Column Chart\", t.defaultDatasetType = \"column\", t.isInverse = !0, t.enablemousetracking = !0;\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t.prototype.getDSGroupdef = function () {\n          return n[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    482: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(354)),\n          r = i(o(346)),\n          n = o(428);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.defaultPlotShadow = 1, o;\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"InverseMSLine\";\n        }, t.prototype.getName = function () {\n          return \"InverseMSLine\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Inverted Y-Axis Multi-series Line Chart\", t.defaultDatasetType = \"line\", t.isInverse = !0, t.zeroplanethickness = 1, t.zeroplanealpha = 4, t.showzeroplaneontop = 0, t.enablemousetracking = !0, t.defaultcrosslinethickness = 1, n._setDefaultConfig.call(this);\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t.prototype.getDSGroupdef = function () {}, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    483: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(484)),\n          r = l(o(487)),\n          n = l(o(489)),\n          i = l(o(490));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.registerFactory(\"limitUpdater\", i[\"default\"], [\"axis\"]), o;\n        }\n\n        return s(t, e), t.prototype.getName = function () {\n          return \"DragColumn2D\";\n        }, t.getName = function () {\n          return \"DragColumn2D\";\n        }, t.prototype.getDSGroupdef = function () {\n          return n[\"default\"];\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this), this.config.isDrag = !0;\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = c;\n    },\n    484: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(404),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      },\n          i = o(118),\n          l = o(125),\n          s = o(485),\n          c = o(129),\n          u = o(486);\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = (0, l.getDepsByType)(\"transcoder\"),\n          d = i.preDefStr.UNDERSCORE,\n          g = i.BLANKSTRING,\n          f = 0,\n          m = function m(e) {\n        var t = e.sender.apiInstance,\n            o = t.getChildren(\"canvas\")[0].getChildren(\"vCanvas\")[0],\n            a = t.config,\n            r = void 0,\n            n = e.data,\n            i = n && n.endValue,\n            l = n && n.startValue;\n        (i > a.yMax || i < a.yMin || l === a.yMin || l === a.yMax) && (r = o.getDataLimits(), a.yMax = r.max, a.yMin = r.min);\n      },\n          v = function v(e) {\n        return e.toString().toLowerCase();\n      },\n          b = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.eiMethods.getDataWithId = function () {\n            for (var e, t, o, a, r, n, i, l, s, c, u = this.apiInstance && this.apiInstance.getJSONData(), p = [[g]], h = u.dataset, f = u.categories && u.categories[0] && u.categories[0].category, m = h && h.length || 0, v = 0; m--;) {\n              if (r = h[m]) for (p[0][m + 1] = r.id || r.seriesname, i = r.id || m + 1, c = (a = r.data) && a.length || 0, s = 0; s < c; s += 1) {\n                if (!p[n = s + 1]) {\n                  for (o = f && f[s + v] || {}; o.vline;) {\n                    o = f[s + (v += 1)] || {};\n                  }\n\n                  t = o.label || o.name || g, p[n] = [t];\n                }\n\n                e = p[n], l = a[s].id || n + d + i, e[m + 1] = [l, Number(a[s].value)];\n              }\n            }\n\n            return p;\n          }, o.eiMethods.getData = function (e) {\n            var t,\n                o,\n                a = this.apiInstance && this.apiInstance.getJSONData(),\n                r = a.dataset,\n                n = r && r.length || 0,\n                i = 0;\n            if (e) o = v(e), t = /^json$/gi.test(o) ? a : h[o]().fromJSON(a, this).data;else for ((t = s._getData.call(this.apiInstance)).unshift([g]); i < n;) {\n              t[0][i + 1] = r[i++].seriesname;\n            }\n            return t;\n          }, o.eiMethods.setUpperLimit = function (e, t) {\n            var o,\n                a = this.apiInstance;\n            if (!t) return a.changeUpperLimits(e);\n            a.addJob(\"setUpperLimitId\" + f++, function () {\n              o = a.changeUpperLimits(e), \"function\" == typeof t && t(o);\n            }, c.priorityList.postRender);\n          }, o.eiMethods.setLowerLimit = function (e, t) {\n            var o,\n                a = this.apiInstance;\n            if (!t) return a.changeLowerLimits(e);\n            a.addJob(\"setLowerLimitId\" + f++, function () {\n              o = a.changeLowerLimits(e), \"function\" == typeof t && t(o);\n            }, c.priorityList.postRender);\n          }, o.eiMethods.getLowerLimit = function (e) {\n            var t = this.apiInstance,\n                o = t.getChildren(\"yAxis\")[0];\n\n            if (o) {\n              if (!e) return o.config.axisRange.min;\n              t.addJob(\"getLowerLimitId\" + f++, function () {\n                \"function\" == typeof e && e(o.config.axisRange.min);\n              }, c.priorityList.postRender);\n            }\n          }, o.eiMethods.getUpperLimit = function (e) {\n            var t = this.apiInstance,\n                o = t.getChildren(\"yAxis\")[0];\n\n            if (o) {\n              if (!e) return o.config.axisRange.max;\n              t.addJob(\"getUpperLimitId\" + f++, function () {\n                \"function\" == typeof e && e(o.config.axisRange.max);\n              }, c.priorityList.postRender);\n            }\n          }, o;\n        }\n\n        return p(t, e), t.prototype.getName = function () {\n          return \"DragBase\";\n        }, t.prototype.configureAttributes = function (t) {\n          e.prototype.configureAttributes.call(this, t), \"DragNode\" !== this.getName() && this.getFromEnv(\"chartInstance\").addEventListener(\"dataplotdragend\", m);\n        }, t.prototype.mouseoutHandler = function (e, t, o) {\n          var a = this.config.datasetOrder || this.getDatasets(),\n              r = this.getChildren(\"mouseTracker\")[0];\n          a[t]._firePlotEvent(i.MOUSEOUT, o, e), delete r._lastDatasetIndex, delete r._lastPointIndex;\n        }, t.getName = function () {\n          return \"DragBase\";\n        }, t.prototype._mouseEvtHandler = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              l,\n              s,\n              c,\n              u = this,\n              p = t.mouseTracker,\n              h = e.originalEvent,\n              d = u.config.datasetOrder || u.getDatasets(),\n              g = (0, i.getMouseCoordinate)(u.getFromEnv(\"chart-container\"), h, u),\n              f = g.chartX,\n              m = g.chartY,\n              v = !1,\n              b = d.length,\n              y = p._lastDatasetIndex,\n              x = p._lastPointIndex;\n          if (void 0 !== x && (s = d[y].components.data[x].config.dragStart), !s) for (; b-- && !v;) {\n            (o = d[b]) && o.getState(\"visible\") && (a = o._getHoveredPlot && o._getHoveredPlot(f, m)) && a.hovered && (v = !0, a.datasetIndex = b, l = p.getMouseEvents(e, a.datasetIndex, a.pointIndex));\n          }\n          if (s && void 0 !== y && (c = e.type === i.MOUSEOUT ? i.MOUSEMOVE : e.type, d[y] && d[y]._firePlotEvent && d[y]._firePlotEvent(c, x, e)), !s && (!v || l && l.fireOut) && void 0 !== y && d[y] && d[y]._firePlotEvent && (l && !l.events.length ? p.mouseoutTimer = setTimeout(function () {\n            u.mouseoutHandler(e, y, x);\n          }, 20) : u.mouseoutHandler(e, y, x)), v) for ((n = l.events && l.events.length) && (p._lastDatasetIndex = a.datasetIndex, x = p._lastPointIndex = a.pointIndex), r = 0; r < n; r += 1) {\n            o && o._firePlotEvent && o._firePlotEvent(l.events[r], x, e);\n          }\n        }, t.prototype.parseChartAttr = function (t) {\n          e.prototype.parseChartAttr.call(this, t);\n          var o,\n              a = this.getFromEnv(\"dataSource\").chart;\n          (o = this.config).formAction = (0, i.getValidValue)(a.formaction), a.submitdataasxml !== i.ZEROSTRING || a.formdataformat || (a.formdataformat = h.csv().format), o.formDataFormat = (0, i.pluck)(a.formdataformat, h.xml().format), o.formTarget = (0, i.pluck)(a.formtarget, \"_self\"), o.formMethod = (0, i.pluck)(a.formmethod, \"POST\"), o.submitFormAsAjax = (0, i.pluckNumber)(a.submitformusingajax, 1), o.restoreBtnTitle = (0, i.pluck)(a.restoretext, a.restorebtntitle, \"Restore\"), o.submitBtnTitle = (0, i.pluck)(a.submittext, a.formbtntitle, \"Submit\"), o.showFormBtn = (0, i.pluckNumber)(a.enablesubmit, a.showformbtn, 1) && o.formAction, o.showRestoreBtn = (0, i.pluckNumber)(a.enablerestore, a.showrestorebtn, 1), o.formBtnTitle = (0, i.pluck)(a.formbtntitle, \"Submit\"), o.formBtnStyle = {\n            fontSize: o.style.outCanfontSize,\n            fontFamily: o.style.outCanfontFamily,\n            fontWeight: \"bold\"\n          }, o.restoreBtnWidth = (0, i.pluckNumber)(a.restorebtnwidth, 0), o.allowAxisChange = (0, i.pluckNumber)(a.allowaxischange, 1), a.toolbary || a.toolbarx ? o.spaceHardCoded = !0 : delete o.spaceHardCoded, o.drawTrendRegion = (0, i.pluckNumber)(a.drawcrossline, 0);\n        }, t.prototype._storeIntialLimit = function (e, t) {\n          this.config.axisInitialLimit = {\n            min: e,\n            max: t\n          };\n        }, t.prototype._createToolBox = function () {\n          e.prototype._createToolBox.call(this), this.addConfigureOptions();\n        }, t.prototype.addConfigureOptions = function () {\n          var e,\n              t,\n              o = this,\n              a = o.getFromEnv(\"chartMenuList\"),\n              r = o.config,\n              n = r.allowAxisChange,\n              i = r.submitBtnTitle,\n              l = r.restoreBtnTitle,\n              s = [{\n            \"Increase Upper Limit\": {\n              handler: function handler() {\n                var e = o.getChildren(\"yAxis\")[0].getLimit(),\n                    t = e.max,\n                    a = e.tickInterval;\n                o.changeUpperLimits(t + a);\n              },\n              action: \"click\"\n            }\n          }, {\n            \"Increase Lower Limit\": {\n              handler: function handler() {\n                var e = o.getChildren(\"yAxis\")[0].getLimit(),\n                    t = e.min,\n                    a = e.tickInterval;\n                o.changeLowerLimits(t + a);\n              },\n              action: \"click\"\n            }\n          }, {\n            \"Decrease Upper Limit\": {\n              handler: function handler() {\n                var e = o.getChildren(\"yAxis\")[0].getLimit(),\n                    t = e.max,\n                    a = e.tickInterval;\n                o.changeUpperLimits(t - a);\n              },\n              action: \"click\"\n            }\n          }, {\n            \"Decrease Lower Limit\": {\n              handler: function handler() {\n                var e = o.getChildren(\"yAxis\")[0].getLimit(),\n                    t = e.min,\n                    a = e.tickInterval;\n                o.changeLowerLimits(t - a);\n              },\n              action: \"click\"\n            }\n          }];\n          r.showFormBtn && ((t = {})[i] = {\n            handler: function handler() {\n              u.submitData.call(o);\n            },\n            action: \"click\"\n          }, s.push(t)), r.showRestoreBtn && ((e = {})[l] = {\n            handler: function handler() {\n              o.restoreData();\n            },\n            action: \"click\"\n          }, s.push(e)), n && a.appendAsList(s);\n        }, t.prototype.restoreData = function () {\n          var e = this.getChildren(\"yAxis\")[0],\n              t = this.getFromEnv(\"chart-attrib\"),\n              o = this.config.axisInitialLimit;\n          this.iterateComponents(function (e) {\n            var t = void 0;\n            (t = e.getChildren(\"dataset\")) && t.forEach(function (e) {\n              e.restore();\n            });\n          }), e.resetStoredLimits(), e.setAxisConfig({\n            axisMaxValue: t.yaxismaxvalue,\n            axisMinValue: t.yaxisminvalue\n          }), e.setDataLimit(o.max, o.min), this.fireChartInstanceEvent(\"dataRestored\", {}), this._manageInteractiveSpace();\n        }, t.prototype.changeLowerLimits = function (e) {\n          var t = this.getChildren(\"yAxis\")[0],\n              o = t.getLimit(),\n              a = o.min,\n              r = o.min,\n              n = this.config,\n              l = (0, i.safeMin)([n.yMin, t.getTrendLineLimits()[0]]),\n              s = !1,\n              c = n.allowAxisChange,\n              u = o.max;\n          return this.getFromEnv(\"animationManager\").setAnimationState(\"update\"), void 0 !== e && e < l && e !== r && c && (a = e, s = !0), s && (t.resetStoredLimits(), t.setAxisConfig({\n            axisMaxValue: u,\n            axisMinValue: a,\n            showLowerLimit: !0\n          }), t.setDataLimit(u, a), this._manageInteractiveSpace()), s;\n        }, t.prototype.changeUpperLimits = function (e) {\n          var t,\n              o = this.getChildren(\"yAxis\")[0],\n              a = o.getLimit(),\n              r = a.min,\n              n = a.max,\n              l = this.config,\n              s = (0, i.safeMax)([l.yMax, o.getTrendLineLimits()[1]]),\n              c = !1,\n              u = l.allowAxisChange;\n          return this.getFromEnv(\"animationManager\").setAnimationState(\"update\"), void 0 !== e && e > s && e !== n && u && (t = e, c = !0), c && (o.resetStoredLimits(), o.setAxisConfig({\n            axisMaxValue: t,\n            axisMinValue: r,\n            showUpperLimit: !0\n          }), o.setDataLimit(t, r), this._manageInteractiveSpace()), c;\n        }, t.prototype.getJSONData = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              l,\n              s = this.getChildren(\"canvas\")[0].getChildren(\"vCanvas\")[0],\n              c = this.getFromEnv(\"dataSource\"),\n              u = [];\n          if (s.iterateComponents(function (t) {\n            \"group\" === t.getType() && (e = t);\n          }), e) u = e.getJSONData && e.getJSONData();else for (n = (o = this.getDatasets()).length, r = 0; r < n; r++) {\n            a = {\n              seriesname: (t = o[r]).config.seriesname,\n              data: t.getJSONData().data\n            }, u.push(a);\n          }\n          return (l = (0, i.extend2)({}, c)).dataset = u, l;\n        }, t;\n      }(n[\"default\"]);\n\n      b.prototype._manageInteractiveSpace = i._manageInteractiveSpace, t[\"default\"] = b;\n    },\n    486: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t.submitData = undefined;\n      var a,\n          r = o(166),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      },\n          i = o(125),\n          l = o(118);\n      var s = void 0,\n          c = (0, i.getDepsByType)(\"transcoder\");\n\n      t.submitData = function () {\n        var e,\n            t,\n            o,\n            a,\n            r,\n            i = this,\n            u = new n[\"default\"](),\n            p = i.config,\n            h = c.json(),\n            d = c.csv && c.csv() || \"csv\",\n            g = c.xml(),\n            f = p.formAction,\n            m = i.getFromEnv(\"chartInstance\"),\n            v = p.submitFormAsAjax;\n        p.formDataFormat === h.format ? (e = h.format, i.getJSONData && (t = JSON.stringify(i.getJSONData())), i.getCollatedData && (t = JSON.stringify(i.getCollatedData()))) : p.formDataFormat && p.formDataFormat === d.format ? (e = d.format, (t = i.getCSVString && i.getCSVString()) !== s && \"\" !== t || (i.getJSONData && (t = d.fromJSON(i.getJSONData()).data), i.getCollatedData && (t = d.fromJSON(i.getCollatedData()).data))) : (e = g.format, i.getCollatedData && (t = g.fromJSON(i.getCollatedData()).data), i.getJSONData && (t = g.fromJSON(i.getJSONData()).data)), i.fireChartInstanceEvent(\"beforeDataSubmit\", {\n          data: t\n        }, s, function () {\n          v ? (u.onError = function (e, o, a, r) {\n            i.fireChartInstanceEvent(\"dataSubmitError\", {\n              xhrObject: o.xhr,\n              url: r,\n              statusText: e,\n              httpStatus: o.xhr && o.xhr.status ? o.xhr.status : -1,\n              data: t\n            }, [m.id, e, o.xhr && o.xhr.status]);\n          }, u.onSuccess = function (e, o, a, r) {\n            i.fireChartInstanceEvent(\"dataSubmitted\", {\n              xhrObject: u,\n              response: e,\n              url: r,\n              data: t\n            }, [m.id, e]);\n          }, (o = {})[\"str\" + e.toUpperCase()] = t, u.open && u.abort(), u.post(f, o)) : ((a = window.document.createElement(\"span\")).innerHTML = '<form style=\"display:none\" action=\"' + f + '\" method=\"' + p.formMethod + '\" target=\"' + p.formTarget + '\"> <input type=\"hidden\" name=\"strXML\" value=\"' + (0, l.xssEncode)(t) + '\"><input type=\"hidden\" name=\"dataFormat\" value=\"' + e.toUpperCase() + '\" /></form>', r = a.removeChild(a.firstChild), window.document.body.appendChild(r), r.submit && r.submit(), r.parentNode.removeChild(r), a = r = null);\n        }, function () {\n          i.fireChartInstanceEvent(\"dataSubmitCancelled\", {\n            data: t\n          });\n        });\n      };\n    },\n    487: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t.updateDataValue = t._restore = t._getJSONData = undefined;\n      var a = l(o(331)),\n          r = o(118),\n          n = l(o(488)),\n          i = o(125);\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c,\n          u,\n          p = r.preDefStr.setRolloverAttrStr,\n          h = r.preDefStr.setRolloutAttrStr,\n          d = r.preDefStr.DATAPLOTCLICK,\n          g = function g(e, t) {\n        var o,\n            a = t.getChildren(\"yAxis\")[0],\n            n = t.getFromEnv(\"chart-container\"),\n            i = this.data(\"eventArgs\");\n        o = (0, r.getMouseCoordinate)(n, e, t), i.value = a.getValue(o.chartY), this.data(\"eventArgs\", i);\n      };\n\n      (0, i.addDep)({\n        name: \"dragColumnAnimation\",\n        type: \"animationRule\",\n        extension: n[\"default\"]\n      });\n\n      var f = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return s(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"dragColumn\";\n        }, t.prototype.configureAttributes = function (t) {\n          var o = this.config,\n              a = this.getFromEnv(\"chart-attrib\"),\n              n = o.JSONData;\n          o.allowDrag = (0, r.pluckNumber)(n.allowdrag, 1), o.allowNegDrag = (0, r.pluckNumber)(n.allownegativedrag, 1), o.allowAxisChange = (0, r.pluckNumber)(a.allowaxischange, 1), o.snapToDivOnly = (0, r.pluckNumber)(a.snaptodivonly, 0), o.snapToDiv = o.snapToDivOnly ? 1 : (0, r.pluckNumber)(a.snaptodiv, 1), o.doNotSnap = (0, r.pluckNumber)(a.donotsnap, 0), o.snapToDivRelaxation = (0, r.pluckNumber)(a.snaptodivrelaxation, 10), o.doNotSnap && (o.snapToDiv = o.snapToDivOnly = 0), e.prototype.configureAttributes.call(this, t);\n        }, t.prototype._plotConfigure = function (t, o) {\n          var a = this.config,\n              n = this.components.data,\n              i = void 0;\n          e.prototype._plotConfigure.call(this, t, o), (i = n[t].config).allowDrag = (0, r.pluckNumber)(o.allowdrag, a.allowDrag), i.allowNegDrag = (0, r.pluckNumber)(o.allownegativedrag, a.allowNegDrag);\n        }, t.prototype._firePlotEvent = function (e, o, a) {\n          var n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N = this,\n              S = document,\n              E = N.getFromEnv(\"chart\"),\n              A = N.config,\n              D = A.JSONData,\n              T = E.getFromEnv(\"dataSource\").chart,\n              L = A.currentToolTip,\n              _ = N.getFromEnv(\"chartConfig\"),\n              P = _.drawTrendRegion,\n              O = _.useplotgradientcolor,\n              V = _.useroundedges,\n              M = N.getFromEnv(\"paper\").canvas.style,\n              F = N.getFromEnv(\"number-formatter\"),\n              I = N.getFromEnv(\"toolTipController\"),\n              B = N.components.data[o],\n              R = B.config,\n              j = B.graphics.element,\n              G = R.finalTooltext || R.toolText,\n              H = a.originalEvent,\n              W = r.hasSVG ? \"ns-resize\" : \"n-resize\",\n              z = (0, r.getMouseCoordinate)(N.getFromEnv(\"chart-container\"), H).chartY,\n              U = B._yPos,\n              J = B._height,\n              K = [1, 2, 3, 4, 5, 6, 7],\n              q = N.getFromEnv(\"yAxis\"),\n              Y = q.yBasePos,\n              X = _.yaxisname,\n              Q = {\n            xaxisName: _.xaxisname,\n            yaxisName: X\n          },\n              Z = _.canvasTop,\n              $ = _.canvasBottom,\n              ee = R.allowDrag,\n              te = R.allowNegDrag ? $ : Y,\n              oe = U,\n              ae = U + J;\n\n          if (u = _.dragTolerance + 1, m = R.setValue, v = U >= Y ? U + J : U, j) switch (l = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(D.data[o].tooltext, D.plottooltext, T.plottooltext))), e) {\n            case \"mouseover\":\n              A.mouseIn = !0, z <= ae - u && z >= oe + u && !P && G && (L ? I.draw(H, G, L) : L = A.currentToolTip = I.draw(H, G)), !R._rollOverResponseSetterFire && z <= ae && z >= oe && (t._rolloverResponseSetter(E, j, a, this), R._rollOverResponseSetterFire = !0);\n              break;\n\n            case \"mouseout\":\n              A.mouseIn = !1, M.cursor = \"default\", R._rollOverResponseSetterFire && t._rolloutResponseSetter(E, j, a, this), R._rollOverResponseSetterFire = !1, I.hide(A.currentToolTip);\n              break;\n\n            case \"click\":\n              !R.dragMove && E.plotEventHandler(j, a, d);\n              break;\n\n            case \"touchmove\":\n            case \"mousemove\":\n              R.dragStart || (v = R.setValue < 0 ? U + J : U, ee && z >= v - u && z <= v + u ? (M.cursor = W, I.hide(A.currentToolTip)) : (M.cursor = \"default\", R._rollOverResponseSetterFire && !P && G && (L ? I.draw(H, G, L) : L = A.currentToolTip = I.draw(H, G))), !R._rollOverResponseSetterFire && z <= ae && z >= oe ? (t._rolloverResponseSetter(E, j, a), R._rollOverResponseSetterFire = !0) : !R._rollOverResponseSetterFire || z <= ae && z >= oe || (I.hide(A.currentToolTip), R._rollOverResponseSetterFire = !1, t._rolloutResponseSetter(E, j, a, this)));\n              break;\n\n            case \"touchstart\":\n            case \"mousedown\":\n              n = function n(e) {\n                z = (0, r.getMouseCoordinate)(N.getFromEnv(\"chart-container\"), e).chartY, e.preventDefault ? e.preventDefault() : e.returnValue = !1, R._rollOverResponseSetterFire = !1, M.cursor = W, R.dragMove = !0, R._pointerDy++, (z += R._dragBuffer) < Z ? z = Z : z > te && (z = te), U = Y < z ? Y : z, J = (0, r.mathAbs)(Y - z), B._yPos = U, B._height = J, v = U >= Y ? U + J : U, R._y = m = R.setValue = q.getValue(v), f = F.dataLabels(m), R.toolTipValue = f, R.displayValue = (0, r.pluck)(R.setDisplayValue, f), O && !V && (R.colorArr[0].FCcolor.angle = C = U < Y ? 90 : 270), j.attr({\n                  y: B._yPos,\n                  height: B._height,\n                  fill: (0, r.toRaphaelColor)(R.colorArr[0])\n                }), N.parseLabelAttributes(B), N.drawLabel(o, o + 1), B.graphics.element = j, I.hide(A.currentToolTip), 1 === R._pointerDy && (y = {\n                  dataIndex: o,\n                  datasetIndex: B.datasetIndex,\n                  startValue: B.startValue,\n                  datasetName: B.name\n                }, E.fireChartInstanceEvent(\"dataplotDragStart\", y));\n              }, i = function i(e) {\n                z = (0, r.getMouseCoordinate)(N.getFromEnv(\"chart-container\"), e).chartY, A.mousedown = !1, R.dragStart && (N.setMaxMin(B), y = {\n                  dataIndex: o,\n                  datasetIndex: B.datasetIndex,\n                  startValue: B.startValue,\n                  endValue: R.setValue,\n                  datasetName: B.name\n                }, b = [E.getFromEnv(\"chartInstance\").id, y.dataIndex, y.datasetIndex, y.datasetName, y.startValue, y.endValue], g.call(j, e, E), R._pointerDy && (E.fireChartInstanceEvent(\"dataplotDragEnd\", y), E.fireChartInstanceEvent(\"chartupdated\", y, b)), O && !V && (C = U >= Y ? 90 : 270, (x = j.data(p)) && x.fill && ((k = (k = x.fill).split(\"-\"))[0] = C, x.fill = k.join(\"-\")), (w = j.data(h)) && w.fill && ((k = (k = w.fill).split(\"-\"))[0] = C, w.fill = k.join(\"-\")))), R._dragBuffer = 0, R._pointerDy = 0, R.dragStart = !1, void 0 !== l && (Q.formattedValue = R.toolTipValue, Q.label = R.label, G = (0, r.parseTooltext)(l, K, Q, {\n                  value: R.toolTipValue\n                }, void 0, D), R.setTooltext = G, l = G, R.toolText = G), G = R.finalTooltext = !1 !== R.toolText ? R.toolText + (l ? \"\" : R.toolTipValue) : \"\", z >= v - u && z <= v + u || (M.cursor = \"default\"), S.removeEventListener ? (S.removeEventListener(\"mousemove\", s), S.removeEventListener(\"mouseup\", c), S.removeEventListener(\"touchmove\", s), S.removeEventListener(\"touchend\", c)) : (S.detachEvent(\"onmousemove\", s), S.detachEvent(\"onmouseup\", c), S.detachEvent(\"ontouchmove\", s), S.detachEvent(\"ontouchend\", c));\n              }, A.mousedown = !0, v = R.setValue < 0 ? U + J : U, R.dragMove = !1, ee && z >= v - u && z <= v + u ? (R.dragStart = !0, R._pointerDy = 0, R._dragStartY = z, R._dragBuffer = v - z, B.startValue = R.setValue, B.name = A.seriesname, B.datasetIndex = A.index, B.dragged = !0, s = function s(e) {\n                n(e);\n              }, c = function c(e) {\n                i(e);\n              }, S.addEventListener ? (S.addEventListener(\"mousemove\", s), S.addEventListener(\"touchmove\", s), S.addEventListener(\"mouseup\", c), S.addEventListener(\"touchend\", c)) : (S.attachEvent(\"onmousemove\", s), S.attachEvent(\"ontouchmove\", s), S.attachEvent(\"onmouseup\", c), S.attachEvent(\"ontouchend\", c))) : R.dragStart = !1;\n          }\n        }, t._rolloverResponseSetter = function (e, t, o, a) {\n          var r = t && t.getData(),\n              n = e.getFromEnv(\"animationManager\");\n          t && 0 !== r.showHoverEffect && !0 !== r.draged && t && (n.setAnimationState(\"mouseOver\"), n.setAnimation({\n            el: t,\n            label: \"rect\",\n            component: a,\n            attr: t.getData().setRolloverAttr\n          }), e.plotEventHandler(t, o, \"DataPlotRollOver\"));\n        }, t._rolloutResponseSetter = function (e, t, o, a) {\n          var r = t && t.getData(),\n              n = e.getFromEnv(\"animationManager\");\n          t && 0 !== r.showHoverEffect && !0 !== r.draged && (n.setAnimationState(\"mouseOut\"), n.setAnimation({\n            el: t,\n            label: \"rect\",\n            component: a,\n            attr: t.getData().setRolloutAttr\n          }), e.plotEventHandler(t, o, \"DataPlotRollOut\"));\n        }, t.prototype.getJSONData = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n = this.config.JSONData.data,\n              i = this.components.data,\n              l = [],\n              s = {};\n\n          for (r = 0, a = n.length; r < a; r++) {\n            for (o in t = n[r], e = i[r], s = {}, t) {\n              s[o] = \"value\" === o ? e.config.setValue : t[o];\n            }\n\n            l.push(s);\n          }\n\n          return {\n            data: l\n          };\n        }, t.prototype.restore = function () {\n          this.setData(this.config.JSONData, !0);\n        }, t;\n      }(a[\"default\"]);\n\n      t._getJSONData = c = f.prototype.getJSONData, t._restore = u = f.prototype.restore, t[\"default\"] = f, t._getJSONData = c, t._restore = u, t.updateDataValue = g;\n    },\n    488: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(332),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"initial.dataset.dragColumn\": n[\"default\"][\"initial.dataset.column\"]\n      };\n    },\n    489: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(402),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      },\n          i = o(118);\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return l(t, e), t.prototype.getJSONData = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.getFromEnv(\"dataSource\").dataset,\n              n = this.getChildren(\"dataset\"),\n              l = [],\n              s = n.length;\n\n          for (a = 0; a < s; a++) {\n            e = n[a], delete (o = (0, i.extend2)({}, r[a])).data, t = e.getJSONData(), l.push((0, i.extend2)(o, t));\n          }\n\n          return l;\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    490: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o = e.config.allowAxisChange,\n            a = e.getChildren(\"yAxis\")[0],\n            n = void 0;\n        (0, r.componentFactory)(a, i[\"default\"], \"limitUpdater\", o ? 1 : 0), (n = (t = a.getChildren(\"limitUpdater\")) && t[0]) && n.configure();\n      };\n      var a,\n          r = o(118),\n          n = o(491),\n          i = (a = n) && a.__esModule ? a : {\n        \"default\": a\n      };\n    },\n    491: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(131)),\n          r = i(o(120)),\n          n = o(118);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = 13,\n          c = 27,\n          u = void 0;\n\n      function p() {\n        this.justFocussed && (this.justFocussed = !1, n.hasTouch || this.select());\n      }\n\n      function h(e, t, o) {\n        var a = u.getLinkedParent();\n        if (e !== t + \"\") return o ? a.changeUpperLimits && a.changeUpperLimits(Number(e)) : a.changeLowerLimits && a.changeLowerLimits(Number(e));\n      }\n\n      function d() {\n        var e,\n            t = {\n          opacity: 1,\n          filter: \"alpha(opacity=100)\",\n          color: (0, n.rgbaToHex)(this.axisLabel.attr(\"fill\"))\n        };\n\n        for (e in t) {\n          this.style[e] = t[e];\n        }\n\n        this.value = this.dataValue, this.justFocussed = !0, this.hasFocus = !0, this.axisLabel && this.axisLabel.hide();\n      }\n\n      function g() {\n        h(this.value, this.oldValue, this.isMaxLabel), this.style.opacity = 0, this.style.filter = \"alpha(opacity=0)\", this.axisLabel && this.axisLabel.show(), n.isIE && document.getElementsByTagName(\"body\")[0].focus && document.getElementsByTagName(\"body\")[0].focus(), this.justFocussed = !1, this.hasFocus = !1;\n      }\n\n      function f(e) {\n        var t = function (e) {\n          return \"number\" == typeof e.which ? e.which : e.keyCode;\n        }(e.originalEvent),\n            o = this.value,\n            a = this.oldValue,\n            n = this.isMaxLabel;\n\n        t === s ? !1 === h(o, a, n) ? this.style.color = \"#dd0000\" : r[\"default\"].fire(this, \"blur\", e) : t === c && (this.value = a, r[\"default\"].fire(this, \"blur\", e));\n      }\n\n      function m(e) {\n        return function (t) {\n          e.parentNode && r[\"default\"].fire(e, \"blur\", t);\n        };\n      }\n\n      function v(e) {\n        return function (t) {\n          t.target !== e && e.hasFocus && r[\"default\"].fire(e, \"blur\", t);\n        };\n      }\n\n      function b(e, t) {\n        return function () {\n          r[\"default\"].unlisten(u.getLinkedParent(), \"defaultprevented\", t), e.parentNode.removeChild(e);\n        };\n      }\n\n      function y(e, t) {\n        return function () {\n          r[\"default\"].unlisten(u.getLinkedParent().getLinkedItem(\"container\"), \"mousedown\", t), e.parentNode.removeChild(e);\n        };\n      }\n\n      var x = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return l(t, e), t.prototype.configureAttributes = function () {\n          this.config.linkedAxis = this.getLinkedParent(), u = this.config.linkedAxis;\n        }, t.prototype.getType = function () {\n          return \"helper\";\n        }, t.prototype.getName = function () {\n          return \"limitUpdater\";\n        }, t.prototype.draw = function () {\n          var e = this.getFromEnv(\"chartConfig\"),\n              t = this.config.linkedAxis,\n              o = t.getAxisConfig(\"extremeLabels\"),\n              a = t.getLimit(),\n              i = this.getFromEnv(\"chart-container\"),\n              l = this.getFromEnv(\"style\").inCanvasStyle,\n              s = (0, n.extend2)({\n            outline: \"none\",\n            \"-webkit-appearance\": \"none\",\n            filter: \"alpha(opacity=0)\",\n            position: \"absolute\",\n            background: \"transparent\",\n            border: \"1px solid #cccccc\",\n            textAlign: \"right\",\n            top: 0,\n            left: 0,\n            width: 50,\n            zIndex: 20,\n            opacity: 0,\n            borderRadius: 0,\n            display: \"block\"\n          }, l),\n              c = {\n            max: {\n              element: o.lastLabel.graphic,\n              value: a.max\n            },\n            min: {\n              element: o.firstLabel.graphic,\n              value: a.min\n            }\n          },\n              u = void 0,\n              h = void 0,\n              x = void 0,\n              w = void 0,\n              k = void 0,\n              C = void 0,\n              N = void 0,\n              S = void 0,\n              E = void 0,\n              A = void 0,\n              D = void 0,\n              T = void 0;\n\n          for (w in s.color = (0, n.hashify)(s.color), s.fontSize = s.fontSize + \"px\", c) {\n            if (c.hasOwnProperty(w)) {\n              if (C = (x = c[w].element) && x.getBBox(), S = c[w].value, N = \"max\" === w, h = w + \"Input\", u = this.getGraphicalElement(h), !C || !x) {\n                u && (u.style.display = \"none\");\n                continue;\n              }\n\n              for (k in u || (u = this.addGraphicalElement(h, (0, n.createElement)(\"input\", {\n                type: \"text\",\n                value: S,\n                id: \"fc-updater-\" + w\n              }, i))), r[\"default\"].listen(u, [\"focus\", \"mouseup\", \"blur\", \"keyup\"], [d, p, g, f]), n.hasSVG ? (r[\"default\"].listen(i, \"defaultprevented\", E = m(u)), r[\"default\"].listen(i, \"destroy\", b(u, E))) : (r[\"default\"].listen(i, \"mousedown\", T = v(u)), r[\"default\"].listen(i, \"destroy\", y(u, T))), A = C.x + C.width - e.marginLeft, D = e.marginLeft, s.top = C.y + \"px\", s.left = D + \"px\", s.width = A + \"px\", s) {\n                s.hasOwnProperty(k) && (u.style[k] = s[k]);\n              }\n\n              u.dataValue = S, u.value = S, u.oldValue = S, u.name = S || \"\", u.axisLabel = x, u.isMaxLabel = N;\n            }\n          }\n        }, t.prototype.removingDraw = function () {\n          var e = this.getGraphicalElement(),\n              t = void 0,\n              o = void 0;\n\n          for (t in e) {\n            e.hasOwnProperty(t) && ((o = e[t]) && o.parentNode && o.parentNode.removeChild(o), delete e[t]);\n          }\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = x;\n    },\n    492: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = r(o(493));\n\n      function r(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function n(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var i = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.defaultPlotShadow = 1, o;\n        }\n\n        return n(t, e), t.prototype.getName = function () {\n          return \"DragLine\";\n        }, t.getName = function () {\n          return \"DragLine\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.isDrag = !0, t.zeroplanethickness = 1, t.zeroplanealpha = 40, t.showzeroplaneontop = 0, t.enablemousetracking = !0, t.defaultcrosslinethickness = 1;\n        }, t.prototype.getDSdef = function () {\n          return a[\"default\"];\n        }, t;\n      }(r(o(497))[\"default\"]);\n\n      t[\"default\"] = i;\n    },\n    493: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = c(o(346)),\n          r = o(494),\n          n = o(118),\n          i = o(487),\n          l = o(125),\n          s = c(o(496));\n\n      function c(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function u(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      (0, l.addDep)({\n        name: \"dragLineAnimation\",\n        type: \"animationRule\",\n        extension: s[\"default\"]\n      });\n\n      var p = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return u(t, e), t.prototype._firePlotEvent = function () {\n          r.__firePlotEvent.apply(this, arguments);\n        }, t.prototype.updateImage = function (e) {\n          r._updateImage.call(this, e);\n        }, t.prototype.configureAttributes = function () {\n          r.configurer.apply(this, arguments);\n        }, t.prototype._plotConfigure = function (t, o) {\n          var a = this.config,\n              r = this.components.data,\n              i = void 0;\n          e.prototype._plotConfigure.call(this, t, o), (i = r[t].config).allowDrag = (0, n.pluckNumber)(o.allowdrag, a.allowDrag), i.allowNegDrag = (0, n.pluckNumber)(o.allownegativedrag, a.allowNegDrag);\n        }, t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"dragLine\";\n        }, t.prototype.restore = function () {\n          i._restore.call(this);\n        }, t.prototype.getJSONData = function () {\n          return i._getJSONData.call(this);\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = p;\n    },\n    494: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t._updateImage = t.configurer = t.__firePlotEvent = undefined;\n      var a = s(o(347)),\n          r = o(118),\n          n = o(487),\n          i = s(o(495)),\n          l = o(125);\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var u,\n          p,\n          h,\n          d = \"DataPlotRollOut\",\n          g = Math.min,\n          f = Math.max;\n      (0, l.addDep)({\n        name: \"dragAreaAnimation\",\n        type: \"animationRule\",\n        extension: i[\"default\"]\n      });\n\n      var m = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"dragArea\";\n        }, t.prototype.configureAttributes = function (t) {\n          var o = this.config,\n              a = this.getFromEnv(\"chart-attrib\"),\n              n = o.JSONData;\n          o.allowDrag = (0, r.pluckNumber)(n.allowdrag, 1), o.allowNegDrag = (0, r.pluckNumber)(n.allownegativedrag, 1), o.allowAxisChange = (0, r.pluckNumber)(a.allowaxischange, 1), o.snapToDivOnly = (0, r.pluckNumber)(a.snaptodivonly, 0), o.doNotSnap = (0, r.pluckNumber)(a.donotsnap, 0), o.snapToDiv = (0, r.pluckNumber)(a.snaptodiv, 1), o.snapToDivRelaxation = (0, r.pluckNumber)(a.snaptodivrelaxation, 10), o.doNotSnap && (o.snapToDiv = o.snapToDivOnly = 0), e.prototype.configureAttributes.call(this, t);\n        }, t.prototype._plotConfigure = function (t, o) {\n          var a = this.config,\n              n = this.components.data,\n              i = void 0;\n          e.prototype._plotConfigure.call(this, t, o), (i = n[t].config).allowDrag = (0, r.pluckNumber)(o.allowdrag, a.allowDrag), i.allowNegDrag = (0, r.pluckNumber)(o.allownegativedrag, a.allowNegDrag);\n        }, t.updateImage = function (e) {\n          var t,\n              o = e.graphics,\n              a = o.image || o.element,\n              n = e.config,\n              i = n.anchorProps,\n              l = n.hoverEffects,\n              s = a && a.data(\"imgRef\"),\n              c = i.imageScale,\n              u = s.height * c * .01,\n              p = s.width * c * .01,\n              h = e._xPos,\n              d = e._yPos,\n              f = l.imageHoverScale,\n              m = s.width * f * .01,\n              v = s.height * f * .01,\n              b = i.isAnchorRadius,\n              y = i.radius = b ? i.radius : g(p, u) / 2,\n              x = i.imagePadding,\n              w = y - x - .5 * i.borderThickness,\n              k = l.radius - x - .5 * l.anchorBorderThickness,\n              C = i.symbol[1],\n              N = (0, r.polyPathToPath)([C || 2, h, d, k > 0 ? k : 0, l.startAngle, l.dip]),\n              S = (0, r.polyPathToPath)([C || 2, h, d, w > 0 ? w : 0, i.startAngle, 0]),\n              E = {\n            x: h - s.width * c * .005,\n            y: d - s.height * c * .005,\n            width: p,\n            height: u,\n            alpha: 100\n          };\n          E[\"clip-path\"] = S, (t = {\n            x: h - s.width * f * .005,\n            y: d - s.height * f * .005,\n            width: m,\n            height: v,\n            alpha: 100\n          })[\"clip-path\"] = N, a.attr(E), a.data(\"setRolloverAttr\", t), a.data(\"setRolloutAttr\", E);\n        }, t.prototype._firePlotEvent = function (e, o, a) {\n          var i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              g,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H = this,\n              W = H.config,\n              z = H.getFromEnv(\"chart-attrib\"),\n              U = H.getFromEnv(\"chart\"),\n              J = H.getFromEnv(\"chartConfig\"),\n              K = J.drawTrendRegion,\n              q = W.JSONData,\n              Y = document,\n              X = H.getFromEnv(\"paper\"),\n              Q = H.getFromEnv(\"toolTipController\"),\n              Z = X.canvas.style,\n              $ = H.getFromEnv(\"number-formatter\"),\n              ee = H.components,\n              te = ee.data[o],\n              oe = W.currentToolTip,\n              ae = W.index,\n              re = a.originalEvent,\n              ne = r.hasSVG ? \"ns-resize\" : \"n-resize\",\n              ie = H.getFromEnv(\"yAxis\"),\n              le = ie.yBasePos,\n              se = [1, 2, 3, 4, 5, 6, 7],\n              ce = J.yaxisname,\n              ue = {\n            xaxisName: J.xaxisname,\n            yaxisName: ce\n          },\n              pe = J.canvasTop,\n              he = J.canvasBottom,\n              de = H.getGraphicalElement().lineElement,\n              ge = O ? he : le,\n              fe = \"dragLine\" === H.getName();\n\n          if (\"touchend\" === e && (L = re.changedTouches[0], re.pageX = L && L.pageX, re.pageY = L && L.pageY), h = (0, r.getMouseCoordinate)(U.getFromEnv(\"chart-container\"), re), g = h.chartY, m = h.chartX, te) switch (k = te.graphics.element, D = te.config, I = D.hoverEffects, V = D.anchorProps, V.imageUrl, F = te.graphics.image, M = k, G = D.hoverEffects && D.hoverEffects.enabled, B = V.startAngle || 90, N = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(q.data[o].tooltext, q.plottooltext, z.plottooltext))), S = D.finalTooltext, C = D.hoverEffects.enabled, E = D.eventArgs, v = te._yPos, b = te._xPos, P = D.allowDrag, O = D.allowNegDrag, ge = O ? he : le, D.dragTolerance = D.dragTolerance < V.markerRadius ? V.markerRadius + .5 : D.dragTolerance, p = f(D.dragTolerance, D.hoverEffects.anchorRadius || 0) + 1, e) {\n            case \"mouseover\":\n              W.mouseIn = !0, D.allowDrag && (Z.cursor = ne), D.dragStart || !S || D.dragStart || K || (oe ? Q.draw(re, S, oe) : oe = W.currentToolTip = Q.draw(re, S)), D.dragStart || (C && H._hoverPlotAnchor(te, \"DataPlotRollOver\"), k && U.plotEventHandler(k, a, \"DataPlotRollOver\", E));\n              break;\n\n            case \"mouseout\":\n              W.mouseIn = !1, Z.cursor = \"default\", C && H._hoverPlotAnchor(te, d), k && U.plotEventHandler(k, a, d, E), Q.hide(W.currentToolTip);\n              break;\n\n            case \"touchmove\":\n            case \"mousemove\":\n              !D.dragStart && S && g >= v - p && g <= v + p && m <= b + p && m >= b - p ? (D.allowDrag && (Z.cursor = ne), oe ? Q.draw(re, S, oe) : oe = W.currentToolTip = Q.draw(re, S)) : Q.hide(W.currentToolTip);\n              break;\n\n            case \"click\":\n              !D.dragMove && k && U.plotEventHandler(k, a, \"dataplotclick\", E);\n              break;\n\n            case \"touchstart\":\n            case \"mousedown\":\n              i = function i(e, a) {\n                g = (0, r.getMouseCoordinate)(H.getFromEnv(\"chart-container\"), e).chartY, re.preventDefault ? re.preventDefault() : re.returnValue = !1, D.allowDrag && (Z.cursor = ne), D.dragMove = !0, D._pointerDy++, (g += D._dragBuffer) < pe ? g = pe : g > ge && (g = ge), te._yPos = v = g, D._y = _ = D.setValue = ie.getValue(v), D._Py = ie.getPixel(D._y), T = $.dataLabels(_), D.toolTipValue = T, D.displayValue = T, H.parseLabelAttributes(te, o), H.drawLabel(o, o + 1), te.graphics.element = k, G && (R = M.data(\"setRolloverAttr\")) && (R.path = (0, r.polyPathToPath)([I.anchorSides || 2, te._xPos, te._yPos, I.anchorRadius, I.startAngle, I.dip])), G && (j = M.data(\"setRolloutAttr\")) && (j.path = (0, r.polyPathToPath)([V.symbol[1] || 2, te._xPos, te._yPos, V.radius, V.startAngle, D.dip || 0])), M && M.attr(j || {\n                  path: (0, r.polyPathToPath)([V.symbol[1] || 2, b, te._yPos, V.radius, B, 0])\n                }), F && t.updateImage(te), u = ee.data, fe && H.drawCommonElements(), a && (W = H.config, x = D.pathStartIndex, w = D.pathEndIndex, y = D.lastPath, y = H.getLinePath(u, {\n                  begin: x,\n                  end: w\n                }), a.attr({\n                  path: y.getPathArr()\n                })), 1 === D._pointerDy && (E = {\n                  dataIndex: o,\n                  datasetIndex: ae,\n                  startValue: te.startValue,\n                  endValue: D.setValue,\n                  datasetName: te.name\n                }, U.fireChartInstanceEvent(\"dataplotDragStart\", E));\n              }, l = function l(e) {\n                g = (0, r.getMouseCoordinate)(H.getFromEnv(\"chart-container\"), e).chartY, W.mousedown = !1, D.dragStart && (H.setMaxMin(te), E = {\n                  dataIndex: o,\n                  datasetIndex: ae,\n                  startValue: te.startValue,\n                  endValue: D.setValue,\n                  datasetName: te.name\n                }, A = [U.getFromEnv(\"chartInstance\").id, E.dataIndex, E.datasetIndex, E.datasetName, E.startValue, E.endValue], k && n.updateDataValue.call(k, a, U), D._pointerDy && (C && H._hoverPlotAnchor(te, d), U.fireChartInstanceEvent(\"dataplotDragEnd\", E), U.fireChartInstanceEvent(\"chartupdated\", E, A))), void 0 !== N && (ue.formattedValue = D.toolTipValue, ue.label = D.label, S = (0, r.parseTooltext)(N, se, ue, {\n                  value: D.toolTipValue\n                }, void 0, q), D.setTooltext = S, N = S, D.toolText = S), S = D.finalTooltext = !1 !== D.toolText ? N || D.toolText.substring(0, D.toolText.indexOf(D.formatedVal)) + D.toolTipValue : \"\", g >= v - p && g <= v + p && m <= b + p && m >= b - p || (Z.cursor = \"default\"), D._dragBuffer = 0, D._pointerDy = 0, D.dragStart = !1, Y.removeEventListener ? (Y.removeEventListener(\"mousemove\", s), Y.removeEventListener(\"mouseup\", c), Y.removeEventListener(\"touchmove\", s), Y.removeEventListener(\"touchend\", c)) : (Y.detachEvent(\"onmousemove\", s), Y.detachEvent(\"onmouseup\", c), Y.detachEvent(\"ontouchmove\", s), Y.detachEvent(\"ontouchend\", c));\n              }, W.mousedown = !0, D.dragMove = !1, P && g >= v - p && g <= v + p && m <= b + p && m >= b - p ? (D.dragStart = !0, D._pointerDy = 0, D._dragStartY = g, D._dragBuffer = v - g, te.dragged = !0, te.startValue = D.setValue, te.name = W.seriesname, te.datasetIndex = W.index, E = {\n                dataIndex: o + 1,\n                datasetIndex: te.datasetIndex,\n                startValue: te.startValue,\n                datasetName: te.name\n              }, s = function s(e) {\n                i(e, de);\n              }, c = function c(e) {\n                l(e);\n              }, Y.addEventListener ? (Y.addEventListener(\"mousemove\", s), Y.addEventListener(\"touchmove\", s), Y.addEventListener(\"mouseup\", c), Y.addEventListener(\"touchend\", c)) : (Y.attachEvent(\"onmousemove\", s), Y.attachEvent(\"ontouchmove\", s), Y.attachEvent(\"onmouseup\", c), Y.attachEvent(\"ontouchend\", c))) : D.dragStart = !1;\n          }\n        }, t.prototype.restore = function () {\n          n._restore.call(this);\n        }, t.prototype.getJSONData = function () {\n          return n._getJSONData.call(this);\n        }, t;\n      }(a[\"default\"]);\n\n      t._updateImage = u = m.prototype.updateImage, t.__firePlotEvent = h = m.prototype._firePlotEvent, t.configurer = p = m.prototype.configureAttributes, t.__firePlotEvent = h, t.configurer = p, t._updateImage = u, t[\"default\"] = m;\n    },\n    495: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(348),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"*.dataset.dragArea\": n[\"default\"][\"*.dataset.area\"]\n      };\n    },\n    496: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"*.dataset.dragLine\": n[\"default\"][\"*.dataset.line\"]\n      };\n    },\n    497: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(483)),\n          r = l(o(494)),\n          n = o(118),\n          i = o(428);\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return s(t, e), t.prototype.getName = function () {\n          return \"DragArea\";\n        }, t.getName = function () {\n          return \"DragArea\";\n        }, t.prototype.getDSGroupdef = function () {}, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          i._setDefaultConfig.call(this), t.isDrag = !0, t.anchoralpha = n.HUNDREDSTRING, t.enablemousetracking = !0, t.defaultcrosslinethickness = 1;\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = c;\n    },\n    498: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(499)),\n          r = i(o(502)),\n          n = o(118);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"Kagi\";\n        }, t.prototype.getName = function () {\n          return \"Kagi\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Kagi Chart\", t.singleseries = !0, t.hasLegend = !1, t.defaultDatasetType = \"kagi\", t.setAdaptiveMin = !0, t.anchorborderthickness = 1, t.anchorimageurl = void 0, t.anchorimagepadding = 1, t.anchorsides = 1, t.anchoralpha = void 0, t.anchorbgalpha = \"100\", t.anchorimagealpha = \"100\", t.anchorimagescale = 100, t.anchorstartangle = 90, t.anchorshadow = 0, t.anchorbgcolor = void 0, t.anchorbordercolor = void 0, t.anchorradius = 3, t.showvalues = 1, t.plotfillalpha = \"70\", t.linedashlen = 5, t.linedashgap = 4, t.linedashed = void 0, t.linealpha = \"100\", t.linethickness = 2, t.drawfullareaborder = 1, t.connectnulldata = 0, t.zeroplanethickness = 1, t.enablemousetracking = !0, t.zeroplanealpha = 40, t.showzeroplaneontop = 0;\n        }, t.prototype._getDataset = function () {\n          var e = [];\n          return this.iterateComponents(function (t) {\n            t.getType && \"dataset\" === t.getType() && e.push(t);\n          }), e;\n        }, t.prototype._postSpaceManagement = function () {\n          var e,\n              t = this.config,\n              o = this.getChildren(\"xAxis\")[0],\n              a = this.getChildren(\"yAxis\")[0],\n              r = this.getChildren(\"canvas\")[0],\n              i = r.config,\n              l = i.canvasBorderWidth,\n              s = (0, n.pluckNumber)(i.canvasPadding, 15),\n              c = i.canvasPaddingTop,\n              u = i.canvasPaddingBottom,\n              p = i.canvasPaddingLeft,\n              h = i.canvasPaddingRight,\n              d = this.getFromEnv(\"dataSource\").chart,\n              g = this._getDataset()[0].config,\n              f = g && g.shiftCount,\n              m = (0, n.pluckNumber)(o.getAxisConfig(\"axisMinValue\"), 0),\n              v = (0, n.pluckNumber)(o.getAxisConfig(\"axisMaxValue\"), f - 1),\n              b = this.config.canvasWidth,\n              y = (0, n.pluckNumber)(d.maxhshiftpercent, 10),\n              x = b - 2 * s;\n\n          a && a.setAxisDimention({\n            x: t.canvasLeft - l,\n            y: t.canvasTop + c,\n            opposite: t.canvasRight + l,\n            axisLength: t.canvasHeight - c - u\n          }), this._setPosition(), g && (y = y <= 0 ? 10 : y, e = g.xShiftLength = Math.min(x / f, y * x / 100), v = Math.max(v, 1)), r.setCanvasPadding(), o && o.setAxisConfig({\n            canvasPaddingLeft: Math.max(p, s) + e / 2,\n            canvasPaddingRight: Math.max(h, s) + e / 2\n          }), o && o.setAxisDimention({\n            x: this.config.canvasLeft + s + e / 2,\n            axisLength: e * (v - m),\n            y: t.canvasBottom + (t.shift || 0) + l,\n            opposite: t.canvasTop - l\n          });\n        }, t.prototype._setPosition = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c = this.getFromEnv(\"dataSource\"),\n              u = this._getDataset()[0],\n              p = c.data || u && u[0] && u[0].data,\n              h = u.components.data,\n              d = h && h.length,\n              g = this.getChildren(\"yAxis\")[0],\n              f = 0,\n              m = f,\n              v = [];\n\n          for (e = 0; e < d; e++) {\n            o = (t = h[e].config).setValue, (c = h[e]) || (c = h[e] = {\n              graphics: {}\n            }), t.isDefined || (o = t.plotValue), o = (0, n.pluck)(t.plotValue, o), t.plotY = (0, n.toPrecision)(g.getPixel(t.setValue), 2), t.graphY = o && (0, n.toPrecision)(g.getPixel(o), 2), t.plotX = m, t.isShift ? (m = f += 1, p && v.push(p[e])) : e === d - 1 && p && v.push(p[e]), e && (s = h[e - 1].config, a = t && t.objParams && t.objParams.isRally, r = t && t.objParams && t.objParams.lastHigh, i = t && t.objParams && t.objParams.lastLow, l = t && t.objParams && t.objParams.isRallyInitialised, s && l && s.isRally !== t.isRally ? (t.isChanged = !0, t.ty = (0, n.toPrecision)(g.getPixel(a ? r : i), 2)) : t.isChanged = !1);\n          }\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    499: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = n(o(258)),\n          r = n(o(500));\n\n      function n(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function i(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var l = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return i(t, e), t.getName = function () {\n          return \"WaterFall2D\";\n        }, t.prototype.getName = function () {\n          return \"WaterFall2D\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Waterfall Chart\", t.singleseries = !0, t.hasLegend = !1, t.defaultDatasetType = \"Waterfall2D\", t.enablemousetracking = !0;\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = l;\n    },\n    500: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = o(118),\n          r = o(122),\n          n = s(o(331)),\n          i = o(125),\n          l = s(o(501));\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      (0, i.addDep)({\n        name: \"waterFall2DAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var u = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"waterFall2D\";\n        }, t.prototype.configure = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n\n          var t,\n              o,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H,\n              W,\n              z,\n              U,\n              J,\n              K,\n              q,\n              Y,\n              X,\n              Q,\n              Z,\n              $,\n              ee,\n              te,\n              oe,\n              ae,\n              re,\n              ne,\n              ie,\n              le,\n              se = this.getFromEnv(\"chart\"),\n              ce = this.config,\n              ue = this.config.JSONData,\n              pe = ue.data,\n              he = pe && pe.length,\n              de = this.getFromEnv(\"xAxis\").getTicksLen(),\n              ge = Math.min(de, he),\n              fe = se.getFromEnv(\"dataSource\").chart,\n              me = this.getFromEnv(\"color-manager\"),\n              ve = this.index || this.positionIndex,\n              be = me.getPlotColor(ve),\n              ye = (0, a.pluckNumber)(ue.dashed, fe.plotborderdashed),\n              xe = (0, a.pluckNumber)(fe.useplotgradientcolor, 1),\n              we = (0, a.pluckNumber)(fe.showtooltip, 1),\n              ke = (0, a.parseUnsafeString)(fe.yaxisname),\n              Ce = (0, a.parseUnsafeString)(fe.xaxisname),\n              Ne = (0, a.parseUnsafeString)((0, a.pluck)(fe.tooltipsepchar, \", \")),\n              Se = this.components.data,\n              Ee = this.getFromEnv(\"number-formatter\"),\n              Ae = {},\n              De = Ae.dataObj || (Ae.dataObj = {}),\n              Te = De.chart || (De.chart = {}),\n              Le = (0, a.pluck)(fe.connectorthickness, 1),\n              _e = -Infinity,\n              Pe = Infinity,\n              Oe = 0,\n              Ve = 0,\n              Me = 0;\n\n          for (this.setState(\"visible\", 1 === (0, a.pluckNumber)(ue.visible, !Number(ue.initiallyhidden), 1)), n = ce.showplotborder = (0, a.pluckNumber)(fe.showplotborder, 1), ce.plotBorderThickness = d = n ? (0, a.pluckNumber)(fe.plotborderthickness, 1) : 0, ce.isRoundEdges = g = (0, a.pluckNumber)(fe.useroundedges, 0), ce.plotBorderAlpha = x = n ? (0, a.pluck)(fe.plotborderalpha, v, \"100\") : 0, ce.plotBorderColor = w = (0, a.pluck)(fe.plotbordercolor, me.getColor(\"plotBorderColor\").split(\",\")[0]), ce.plotgradientcolor = y = xe ? (0, a.getDefinedColor)(fe.plotgradientcolor, me.getColor(\"plotGradientColor\")) : \"\", ce.plotDashLen = p = (0, a.pluckNumber)(fe.plotborderdashlen, 6), ce.plotDashGap = h = (0, a.pluckNumber)(fe.plotborderdashgap, 3), ce.use3DLighting = (0, a.pluckNumber)(fe.use3dlighting, 1), ce.showSum = X = (0, a.pluckNumber)(fe.showsumatend, 1), ce.plotColor = be = (0, a.pluck)(ue.color, be), ce.plotfillAngle = m = (0, a.pluckNumber)(360 - fe.plotfillangle, 90), ce.showShadow = g ? (0, a.pluckNumber)(fe.showshadow, 1) : (0, a.pluckNumber)(fe.showshadow, me.getColor(\"showShadow\")), ce.showHoverEffect = f = (0, a.pluckNumber)(fe.plothovereffect, fe.showhovereffect, void 0), ce.plotFillAlpha = v = (0, a.pluck)(ue.alpha, fe.plotfillalpha, \"100\"), ce.plotRadius = (0, a.pluckNumber)(fe.useRoundEdges, ce.isRoundEdges ? 1 : 0), ce.plotFillRatio = b = (0, a.pluck)(ue.ratio, fe.plotfillratio), ce.plotBorderDashStyle = C = ye ? (0, a.getDashStyle)(p, h) : \"none\", ce.showValues = (0, a.pluckNumber)(ue.showvalues, fe.showvalues, 1), ce.valuePadding = (0, a.pluckNumber)(fe.valuepadding, 2), ce.enableAnimation = z = (0, a.pluckNumber)(fe.animation, fe.defaultanimation, 1), ce.animation = !!z && {\n            duration: 1e3 * (0, a.pluckNumber)(fe.animationduration, 1)\n          }, Te.transposeAnimation = ce.transposeAnimation = (0, a.pluckNumber)(fe.transposeanimation, Te.transposeAnimation, z), ce.transposeAnimDuration = 1e3 * (0, a.pluckNumber)(fe.transposeanimduration, .2), ce.showTooltip = (0, a.pluckNumber)(fe.showtooltip, 1), ce.stack100Percent = (0, a.pluckNumber)(se.stack100percent, fe.stack100percent, 0), ce.definedGroupPadding = Math.max((0, a.pluckNumber)(fe.plotspacepercent), 0), ce.plotSpacePercent = Math.max((0, a.pluckNumber)(fe.plotspacepercent, 20) % 100, 0), ce.maxColWidth = (0, a.pluckNumber)(fe.maxcolwidth, 50), ce.showPercentValues = (0, a.pluckNumber)(fe.showpercentvalues, 0), ce.showPercentInToolTip = (0, a.pluckNumber)(fe.showpercentintooltip, 0), ce.plotPaddingPercent = (0, a.pluckNumber)(fe.plotpaddingpercent), ce.rotateValues = (0, a.pluckNumber)(fe.rotatevalues) ? 270 : 0, ce.placeValuesInside = (0, a.pluckNumber)(fe.placevaluesinside, 0), ce.parentYAxis = U = \"s\" === (0, a.pluck)(ue.parentyaxis && ue.parentyaxis.toLowerCase(), \"p\") ? 1 : 0, ce.defaultPadding = {\n            left: .5,\n            right: .5\n          }, this.setState(\"dirty\", !0), Se || (Se = this.components.data = []), ce.zLine = oe = {\n            step: !0,\n            data: [],\n            dashStyle: \"1\" === fe.connectordashed ? (0, a.getDashStyle)((0, a.pluckNumber)(fe.connectordashlen, 2), (0, a.pluckNumber)(fe.connectordashgap, 2)) : \"none\",\n            useForwardSteps: !0,\n            color: (0, r.convertColor)((0, a.pluck)(fe.connectorcolor, \"000000\"), (0, a.pluck)(fe.connectoralpha, 100)),\n            lineWidth: Le\n          }, Y = 0; Y < ge; Y += 1) {\n            N = pe[Y], $ = Ee.getCleanValue(N.value), te = (0, a.pluckNumber)(N.issum, 0), N.vline || te ? delete N._value : (Oe += $, N._value = $);\n          }\n\n          for (ee = Ee.dataLabels(Oe), X && (X = !0, ge += 1, ne = {\n            label: (0, a.getFirstValue)(fe.sumlabel, \"Total\"),\n            _value: Oe,\n            value: Oe,\n            issum: 1,\n            cumulative: 1\n          }), Y = 0, ie = 0; Y < ge; Y += 1) {\n            N = pe[Y], A = (E = Se[Y]) && E.config, E || (E = Se[Y] = {\n              graphics: {}\n            }), E.config || (A = Se[Y].config = {}), !N && X && (N = pe[Y] = ne), be = (0, a.pluck)(N.color, me.getPlotColor(Y)), E.vline || ($ = N._value, delete N._value, A.issum = te = (0, a.pluckNumber)(N.issum, 0), re = A.isCumulative = (0, a.pluckNumber)(N.cumulative, 1), te ? ($ = re ? Ve : Ve === Me ? Ve : Ve - Me, A.lastComTotal = Me, Me = Ve, oe.data.push({\n              y: null,\n              x: ie - .5\n            })) : Ve += $, _e = Math.max(_e, Ve), Pe = Math.min(Pe, Ve), A.total = Ve, Z = A.showLabel = (0, a.pluckNumber)(N.showlabel, fe.showlabels, 1), Q = A.dataLabel = (0, a.parseUnsafeString)(Z ? (0, a.getFirstValue)(N.label, N.name) : \"\"), $ > 0 ? (ae = (0, a.pluck)(N.color, fe.positivecolor, be), 0 !== f && (T = (0, a.pluck)(N.positivehovercolor, fe.positivehovercolor, fe.plotfillhovercolor, fe.columnhovercolor, ae))) : (ae = (0, a.pluck)(N.color, fe.negativecolor, be), 0 !== f && (T = (0, a.pluck)(N.negativehovercolor, fe.negativehovercolor, fe.plotfillhovercolor, fe.columnhovercolor, ae))), le = $ < 0 ? 360 - m : m, v = (0, a.pluck)(N.alpha, ce.plotFillAlpha), J = (0, a.pluckNumber)(N.dashed, ye), K = (0, a.pluckNumber)(N.dashlen, p), q = h = (0, a.pluckNumber)(N.dashgap, h), A.showValue = (0, a.pluckNumber)(N.showvalue, ce.showValues), A.setValue = S = $, A.setLink = (0, a.pluck)(N.link), A.toolTipValue = H = Ee.dataLabels(S, U), A.setDisplayValue = W = (0, a.getValidValue)((0, a.parseUnsafeString)(N.displayvalue)), A.displayValue = (0, a.pluck)(W, H), A.plotBorderDashStyle = k = 1 === J ? (0, a.getDashStyle)(K, q) : 0 === J ? \"none\" : C, A.shadow = {\n              opacity: ce.showShadow ? v / 100 : 0\n            }, A.colorArr = D = (0, r.getColumnColor)(ae + \",\" + y.replace(/,+?$/, \"\"), v, b, le, g, w, x.toString(), 0, !1), 0 !== f && (L = (0, a.pluck)(N.alpha, N.hoveralpha, ue.hoveralpha, fe.plotfillhoveralpha, fe.columnhoveralpha, v), !(_ = (0, a.pluck)(N.hovergradientcolor, ue.hovergradientcolor, fe.plothovergradientcolor, y)) && (_ = \"\"), P = (0, a.pluck)(N.hoverratio, ue.hoverratio, N.ratio, fe.plothoverratio, b), O = (0, a.pluckNumber)(360 - N.hoverangle, 360 - ue.hoverangle, 360 - fe.plothoverangle, le), V = (0, a.pluck)(N.borderhovercolor, ue.borderhovercolor, fe.plotborderhovercolor, w), M = (0, a.pluck)(N.borderhoveralpha, ue.borderhoveralpha, fe.plotborderhoveralpha, x, v), F = (0, a.pluckNumber)(N.borderhoverthickness, ue.borderhoverthickness, fe.plotborderhoverthickness, d), I = (0, a.pluckNumber)(N.borderhoverdashed, ue.borderhoverdashed, fe.plotborderhoverdashed), B = (0, a.pluckNumber)(N.borderhoverdashgap, ue.borderhoverdashgap, fe.plotborderhoverdashgap, p), R = (0, a.pluckNumber)(N.borderhoverdashlen, ue.borderhoverdashlen, fe.plotborderhoverdashlen, h), j = I ? (0, a.getDashStyle)(R, B) : k, 1 === f && T === be && (T = (0, r.getLightColor)(T, 70)), G = (0, r.getColumnColor)(T + \",\" + _, L, P, O, g, V, M.toString(), 0, !1), A.setRolloutAttr = {\n              fill: (0, a.toRaphaelColor)(D[0]),\n              stroke: n && (0, a.toRaphaelColor)(D[1]),\n              \"stroke-width\": d,\n              \"stroke-dasharray\": k\n            }, A.setRolloverAttr = {\n              fill: (0, a.toRaphaelColor)(G[0]),\n              stroke: n && (0, a.toRaphaelColor)(G[1]),\n              \"stroke-width\": F,\n              \"stroke-dasharray\": j\n            }), i = A.toolTipValue, A.origToolText = s = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(N.tooltext, ue.plottooltext, fe.plottooltext))), we ? void 0 !== s ? (c = [1, 2, 3, 5, 6, 7, 20, 21, 24, 25], l = {\n              formattedValue: i,\n              label: Q,\n              yaxisName: ke,\n              xaxisName: Ce,\n              cumulativeValue: Ve,\n              cumulativeDataValue: Ee.dataLabels(Ve),\n              sum: ee,\n              unformattedSum: Oe\n            }, u = (0, a.parseTooltext)(s, c, l, N, fe, ue)) : u = null !== i && (\"\" !== Q ? Q + Ne : \"\") : u = !1, oe.data.push({\n              y: null === $ ? null : Ve,\n              x: ie\n            }), ie += 1, A.originalPlotColor = be, A.toolText = u, A.setTooltext = u, A._x = Y, A._y = S);\n          }\n\n          for (ce.maxValue = _e, ce.minValue = Pe, ce.connectNullData = (0, a.pluckNumber)(fe.connectnulldata, 0), ce.showConnectors = (0, a.pluckNumber)(fe.showconnectors, 1), t = ue.catData, Y = 0; Y < t.length; Y += 1) {\n            o = t[Y], pe.splice(o.index, 0, o.data);\n          }\n\n          this.getFromEnv(\"xAxis\").setTickValues(pe), this.config.maxminFlag = !1;\n        }, t.prototype.createCoordinates = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s = this.components.data,\n              c = this.getFromEnv(\"chart\").isBar,\n              u = this.getFromEnv(\"yAxis\"),\n              p = this.getFromEnv(\"xAxis\"),\n              h = u.getAxisBase(),\n              d = u.getPixel(h),\n              g = p.config.isVertical,\n              f = this.getFromEnv(\"chartConfig\"),\n              m = f.xDepth || 0,\n              v = f.yDepth || 0,\n              b = s.length,\n              y = this.components,\n              x = this.groupManager,\n              w = x && x.stackConf,\n              k = y.data;\n\n          for (!c && (m = -m), c && (v = -v), a = 0; a < b; a++) {\n            t = (e = k[a]) && e.config, void 0 !== e && (l = t._y, t.issum ? t.isCumulative ? o = null : (o = t.lastComTotal, l += t.lastComTotal) : (o = k[a - 1] && k[a - 1].config.total) && (l += o), r = p.getPixel(w && w[a].x || t._x) + m, n = u.getPixel(l) + v, i = (o ? u.getPixel(o) : d) + v, g ? (t._Px = n, t._Py = r, t._Pby = r, t._Pbx = i) : (t._Px = r, t._Py = n, t._Pby = i, t._Pbx = r));\n          }\n        }, t.prototype.getDataLimits = function () {\n          var e,\n              t,\n              o = this.components.data,\n              a = this.config,\n              r = o.length,\n              n = -Infinity,\n              i = +Infinity;\n\n          for (e = 0; e < r; e++) {\n            o[e] && void 0 !== (t = o[e].config.total) && (n = Math.max(n, t), i = Math.min(i, t));\n          }\n\n          return a.maxValue = n, a.minValue = i, {\n            max: a.maxValue,\n            min: a.minValue\n          };\n        }, t.prototype.drawPlots = function (t) {\n          e.prototype.drawPlots.call(this, t), this.config.showConnectors ? this.drawLine() : this.getContainer(\"commonElemsGroup\").hide();\n        }, t.prototype.drawLine = function () {\n          var e,\n              t,\n              o,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c = this.config,\n              u = this.getFromEnv(\"xAxis\"),\n              p = this.getFromEnv(\"yAxis\"),\n              h = p.getAxisBase(),\n              d = p.getPixel(h),\n              g = this.getContainer(\"commonElemsGroup\"),\n              f = this.getFromEnv(\"columnWidth\") / 2,\n              m = this.getFromEnv(\"animationManager\"),\n              v = c.zLine,\n              b = c.connectNullData,\n              y = v.data,\n              x = y.length,\n              w = this._graphics,\n              k = v.dashStyle,\n              C = v.color,\n              N = v.lineWidth,\n              S = w.zLine,\n              E = null,\n              A = [],\n              D = [];\n\n          for (p.yBasePos = d, g.toFront().show(), e = 0; e < x; e += 1) {\n            null === (n = (r = y[e]).y) ? (D.length = 0, 0 === b && (E = null)) : (i = (0, a.pluckNumber)(r.x, e), t = p.getPixel(n), o = u.getPixel(i), o = (0, a.getCrispValue)(o, N, N).position, t = (0, a.getCrispValue)(t, N, N).position, null !== E ? (D.length && (A = A.concat(D), D.length = 0), A.push(\"M\", l, E, \"m\", -f, 0, \"H\", o, \"h\", f, \"m\", 0, t - E)) : D.push(\"M\", o, t), l = o, E = t);\n          }\n\n          s = m.setAnimation({\n            el: S || \"path\",\n            attr: {\n              path: A,\n              \"stroke-linecap\": \"round\",\n              \"stroke-opacity\": 1,\n              \"stroke-dasharray\": k,\n              stroke: C,\n              \"stroke-linejoin\": N >= 2 ? \"round\" : \"miter\",\n              \"stroke-width\": N\n            },\n            container: g,\n            component: this,\n            label: \"path\"\n          }), S || this.addGraphicalElement(\"zLine\", s);\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = u;\n    },\n    501: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(332),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"initial.dataset.waterFall2D\": n[\"default\"][\"initial.dataset.column\"]\n      };\n    },\n    502: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(346)),\n          r = o(118),\n          n = o(125),\n          i = l(o(503));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c = function c(e) {\n        return void 0 !== e && null !== e;\n      },\n          u = \"M\",\n          p = r.hasTouch ? r.TOUCH_THRESHOLD_PIXELS : r.CLICK_THRESHOLD_PIXELS;\n\n      (0, n.addDep)({\n        name: \"kagiAnimation\",\n        type: \"animationRule\",\n        extension: i[\"default\"]\n      });\n\n      var h = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.manageSpace = function () {}, o.drawCommonElements = function () {}, o;\n        }\n\n        return s(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"kagi\";\n        }, t.prototype._parseShadowOptions = function () {\n          var e = this.getFromEnv(\"chart\"),\n              t = this.config,\n              o = e.getFromEnv(\"dataSource\").chart;\n          return {\n            opacity: (0, r.pluckNumber)(o.showshadow, 1) ? t.alpha / 100 : 0\n          };\n        }, t.prototype.configureAttributes = function (t) {\n          e.prototype.configureAttributes.call(this, t);\n\n          var o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H = this.getFromEnv(\"chart\"),\n              W = this.getFromEnv(\"xAxis\"),\n              z = 0,\n              U = [],\n              J = 0;\n\n          for (o = this.components, n = o.data, i = this.config, l = this.config.JSONData.data, s = H.getFromEnv(\"dataSource\").chart, u = i.maxValue, p = i.minValue, a = o.removeDataArr || (o.removeDataArr = []), h = !1, d = 0, g = (0, r.pluckNumber)(s.reversalvalue, -1), f = (0, r.pluckNumber)(s.reversalpercentage, 5), C = 0; C < n.length; C += 1) {\n            n[C].config.__nullCount = J, null === n[C].config.setValue && (a.push(n.splice(C, 1)[0]), J++, C -= 1);\n          }\n\n          if (n.length) {\n            for (i.rallyColor = (0, r.pluck)(s.rallycolor, \"FF0000\"), i.rallyAlpha = (0, r.pluckNumber)(s.rallyalpha, s.linealpha, 100), i.declineColor = (0, r.pluck)(s.declinecolor, \"0000FF\"), i.declineAlpha = (0, r.pluckNumber)(s.declinealpha, s.linealpha, 100), i.canvasPadding = (0, r.pluckNumber)(s.canvaspadding, 15), i.maxHShiftPercent = (0, r.pluckNumber)(s.maxhshiftpercent, 10), i.rallyThickness = (0, r.pluckNumber)(s.rallythickness, s.linethickness, 2), m = (0, r.pluckNumber)(s.rallydashlen, s.linedashlen, 5), v = (0, r.pluckNumber)(s.rallydashgap, s.linedashgap, 4), i.declineThickness = (0, r.pluckNumber)(s.declinethickness, s.linethickness, 2), b = (0, r.pluckNumber)(s.declinedashlen, s.linedashlen, 5), y = (0, r.pluckNumber)(s.declinedashgap, s.linedashgap, 4), i.lineDashed = {\n              \"true\": (0, r.pluckNumber)(s.rallydashed, s.linedashed, 0),\n              \"false\": (0, r.pluckNumber)(s.declinedashed, s.linedashed, 0)\n            }, i.rallyDashed = (0, r.pluckNumber)(s.rallydashed, s.linedashed, 0) ? (0, r.getDashStyle)(m, v) : \"none\", i.declineDashed = (0, r.pluckNumber)(s.declinedashed, s.linedashed, 0) ? (0, r.getDashStyle)(b, y) : \"none\", i.canvasPadding = (0, r.pluckNumber)(s.canvaspadding, this.canvasPadding, 15), g = g > 0 ? g : f * (u - p) / 100, x = n[0].config.setValue, w = function w(e, t) {\n              for (var o, a = 1, r = n[0].config.setValue; a < e;) {\n                o = n[a].config.setValue, t ? o <= r && (n[a].config.isDefined = !1) : o >= r && (n[a].config.isDefined = !1), a += 1;\n              }\n\n              n[0].config.vAlign = t ? \"bottom\" : \"top\", n[0].config.align = \"center\";\n            }, k = l.length, C = 0, N = 0; N < k; N += 1, C += 1) {\n              if ((!(S = l[N]) || !S.vline) && (T = n[C] && n[C].config, E && (E = !1), T && (T.isDefined = !0), C && T)) {\n                if (T.isShift = void 0, A = n[C - 1].config, T.vAlign = \"middle\", T.align = \"right\", T.showLabel = !1, D = null, P = T.setValue, L = n[C + 1] && n[C + 1].config.setValue, _ = Math.abs(x - P), h ? P < V && O ? O = !1 : P > M && !O && (O = !0) : (P > x && _ > g ? (V = x, M = null, F = !0, h = !0, w(C, O = !0)) : P < x && _ > g ? (V = null, M = x, F = !1, h = !0, w(C, O = !1)) : (O = null, F = null, h = !1), c(A) && (A.isRally = O), null !== O && (n[0].config.isRally = O)), T.isRally = O, (F && P < x || !F && P > x) && (D = x), B = D || P, _ = Math.abs(B - L), I = null === F ? null : F ? B > L && _ >= g : B < L && _ >= g, A && A.isShift) for (F ? (V = x, j = \"bottom\") : F || (M = x, j = \"top\"), G = \"center\", R = C; R > 1; R -= 1) {\n                  if (n[R].y == x) {\n                    n[R].vAlign = j, n[R].align = G, n[R].showLabel = !0;\n                    break;\n                  }\n                }\n                I ? (d += 1, E = !0, F = !F, T.isShift = !0, x = B, U.push(l[C + T.__nullCount]), z = this._appendCategory(z, C, U, 0)) : F && P > x || !F && P < x ? x = P : D = x, T.plotValue = D, T.objParams = {\n                  isRally: O,\n                  lastHigh: M,\n                  lastLow: V,\n                  isRallyInitialised: h\n                };\n              }\n            }\n\n            this._appendCategory(z, C, U, 1), U.push(S), W.setTickValues(U), i.shiftCount = d + 1;\n          }\n        }, t.prototype._appendCategory = function (e, t, o, a) {\n          var n,\n              i,\n              l,\n              s,\n              c = this.config.JSONData.catData;\n          if (e < c.length) for (n = e; n < c.length; e = n += 1) {\n            if (l = (i = c[n]).data, (s = i.index - (n + 1)) < t) l.lineposition = (0, r.pluckNumber)(l.lineposition, a);else if (s > t) break;\n            o.push(l);\n          }\n          return e;\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s = this.getFromEnv(\"xAxis\"),\n              c = this.config,\n              u = c.trackIndex,\n              p = this.components.data,\n              h = p.length;\n\n          for (e += s.getTranslation(), i = Math.floor(Math.max(s.getValue(e - c.maxRadius), 0)), a = Math.ceil(Math.min(s.getValue(e + c.maxRadius), h - 1)); a >= i; a--) {\n            for (o = h = (l = u[a]) && l.length; o >= 0; o--) {\n              if (r = l[o], n = this.isWithinShape(p[r], r, e, t)) return n;\n            }\n          }\n        }, t.prototype.getClip = function (e) {\n          var t = this.getFromEnv(\"chart\").getChildren(\"canvas\")[0].config,\n              o = [t.canvasLeft, t.canvasTop, 0, t.canvasTop + t.canvasHeight];\n          return o[2] += \"init\" === e ? 0 : t.canvasLeft + t.canvasWidth, o;\n        }, t.prototype.parsePlotAttributes = function (e, t) {\n          var o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u = t,\n              h = void 0,\n              d = this.config.JSONData,\n              g = this.config,\n              f = this.getFromEnv(\"xAxis\"),\n              m = void 0,\n              v = this.components.data,\n              b = void 0,\n              y = void 0,\n              x = void 0,\n              w = void 0,\n              k = void 0,\n              C = {},\n              N = void 0,\n              S = this.getState(\"visible\"),\n              E = void 0;\n          e = e.config, N = (b = v[u]).config, h = e.trackerConfig = {}, k = N.hoverEffects, l = N.setValue, s = N.displayValue, o = b._xPos = f.getPixel(e.plotX), a = b._yPos = e.plotY, b._index = e.plotX, c = (C = N.anchorProps).symbol, n = e.finalTooltext = e.toolText, i = N.setLink, void 0 !== a && !isNaN(a) && e.isDefined && ((m = e.eventArgs = e.eventArgs || {}).index = u, m.link = i, m.value = l, m.displayValue = s, m.categoryLabel = N.label, m.toolText = n, m.id = g.userID, m.datasetIndex = 0, m.datasetName = d.seriesname, m.visible = S, y = x = {}, C.imageUrl && (N.anchorImageLoaded = !1), E = {\n            path: (0, r.polyPathToPath)([c[1] || 2, o, a, C.radius, C.startAngle, 0]),\n            fill: (0, r.toRaphaelColor)({\n              color: C.bgColor,\n              alpha: C.bgAlpha\n            }),\n            stroke: (0, r.toRaphaelColor)({\n              color: C.borderColor,\n              alpha: C.borderAlpha\n            }),\n            \"stroke-width\": C.borderThickness,\n            visibility: C.radius ? S : \"hidden\"\n          }, w = Math.max(C.radius, k && k.anchorRadius || 0, p) + C.borderThickness / 2, h.trackerRadius = w, k.enabled && (x = {\n            path: (0, r.polyPathToPath)([k.anchorSides || 2, o, a, k.anchorRadius, k.startAngle, k.dip]),\n            fill: (0, r.toRaphaelColor)({\n              color: k.anchorColor,\n              alpha: k.anchorBgAlpha\n            }),\n            stroke: (0, r.toRaphaelColor)({\n              color: k.anchorBorderColor,\n              alpha: k.anchorBorderAlpha\n            }),\n            \"stroke-width\": k.anchorBorderThickness\n          }, y = {\n            path: (0, r.polyPathToPath)([C.sides, o, a, C.radius, C.startAngle, 0]),\n            fill: (0, r.toRaphaelColor)({\n              color: C.bgColor,\n              alpha: C.bgAlpha\n            }),\n            stroke: (0, r.toRaphaelColor)({\n              color: C.borderColor,\n              alpha: C.borderAlpha\n            }),\n            \"stroke-width\": C.borderThickness\n          }, k.attrs = {\n            hoverEnabled: k.enabled,\n            anchorRadius: C.radius,\n            anchorHoverRadius: k.anchorRadius\n          }, k.attrs.setRolloverAttr = x, k.attrs.setRolloutAttr = y, C.isAnchorHoverRadius = k.attrs.anchorRadius)), e.props = {\n            element: {\n              attr: E\n            }\n          };\n        }, t.prototype.parseLabelAttributes = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w = this.getFromEnv(\"chart\"),\n              k = w.config,\n              C = this.getFromEnv(\"smartLabel\"),\n              N = w.config.dataLabelStyle,\n              S = k.rotatevalues ? 270 : 0,\n              E = k.canvasTop,\n              A = E + k.canvasHeight,\n              D = {},\n              T = {},\n              L = t,\n              _ = this.components.data.length;\n          y = (d = e && e.config) && d.setValue, void 0 !== e && void 0 !== y && null !== y && !0 !== d.labelSkip ? (t > 0 && (T = {\n            x: this.components.data[L - 1]._xPos,\n            y: this.components.data[L - 1]._yPos\n          }), t < _ - 1 && (D = {\n            x: this.components.data[L + 1]._xPos,\n            y: this.components.data[L + 1]._yPos\n          }), h = d.anchorProps, n = e.graphics, m = e._yPos || e.config._Py, f = e._xPos || e.config._Px, b = n.element ? n.image && .5 * n.element.attr(\"height\") || h.radius - 3 : 0, a = k.valuepadding + 2 + b, o = d.displayValue, v = d.showValue, c(o) && \"\" !== o && v && (x = {\n            text: o,\n            fill: N.color,\n            \"text-bound\": [N.backgroundColor, N.borderColor, N.borderThickness, N.borderPadding, N.borderRadius, N.borderDash]\n          }, r = C.getOriSize(o), S ? (d._state = {\n            labelWidth: r.height,\n            labelHeight: r.width\n          }, d._rotated = !0) : (d._state = {\n            labelWidth: r.width,\n            labelHeight: r.height\n          }, d._rotated = !1), i = l = S ? r.width : r.height, i += a, p = .5 * l + a, s = m, u = f, i += 4, g = Number(S) >= 1 ? r.height : r.width, d._valueBelowPoint = 0, D.y > s ? T.y < s ? u -= a + 3 + .5 * g : m - i < E ? (u -= a + 3 + .5 * g, s = E + i / 2) : s -= p : T.y > s ? u -= a + 3 + .5 * g : m + i > A ? (u -= a + 3 + .5 * g, s = A - i / 2) : (s += p + 2, d._valueBelowPoint = 1), x.x = u, x.y = s), d.props = d.props || {}, d.props.label = {\n            attr: x\n          }) : d && delete d.labelSkip;\n        }, t.prototype.allocatePosition = function () {\n          var e,\n              t = void 0,\n              o = this,\n              a = o.config,\n              n = o.components.data,\n              i = n && n.length,\n              l = o.getFromEnv(\"xAxis\"),\n              s = o.components.data,\n              c = void 0,\n              p = void 0,\n              h = l.getPixel(0),\n              d = l.getPixel(1) - h,\n              g = {\n            \"true\": a.rallyThickness,\n            \"false\": a.declineThickness\n          },\n              f = void 0,\n              m = void 0,\n              v = l.getPixel(0),\n              b = n[0] && !!n[0].isRally,\n              y = void 0,\n              x = h - d / 2,\n              w = void 0,\n              k = void 0,\n              C = void 0;\n\n          if (a.imagesLoaded = 0, n.length) {\n            if (f = a.rallyPath = [], m = a.declinePath = [], s = o.components.data = s || [], n[0].config.setValue) w = n[0].config.plotY;else for (t = 1; t < i; t += 1) {\n              if (n[t].config.setValue) {\n                w = n[t].config.plotY;\n                break;\n              }\n            }\n\n            for (b = !!n[0].config.isRally, e = Math.round(w) + g[b] % 2 / 2, b ? f.push(u, x, e, \"H\", v) : m.push(u, x, e, \"H\", v), (0, r.fcEach)(n, function (e, t) {\n              e = e.config, c = s[t], p = c.config, p.setValue, (k = n[t + 1] && n[t + 1].config || {}) && (C = [u, v, w], b = e.isRally, e.isShift && (v += d, w = e.graphY, C.push(\"H\", v), C[2] = Math.round(C[2]) + g[b] % 2 / 2, C = C.toString(), b ? f.push(C) : m.push(C), C = [u, v, w]), k.isChanged && (w = k.ty, C.push(\"V\", w), C[1] = Math.round(C[1]) + g[!!b] % 2 / 2, C = C.toString(), b ? f.push(C) : m.push(C), C = [u, v, w]), y = k.isRally, k.graphY !== C[2] && void 0 !== k.graphY && (C.push(\"V\", k.graphY), C[1] = Math.round(C[1]) + g[!!y] % 2 / 2, C = C.toString(), y ? f.push(C) : m.push(C)), k.graphY && (w = k.graphY)), o.parsePlotAttributes(c, t);\n            }), t = 0; t < n.length; t++) {\n              o.parseLabelAttributes(s[t], t);\n            }\n          }\n        }, t.prototype.drawPlots = function () {\n          var e = void 0,\n              t = this,\n              o = t.getGraphicalElement(),\n              a = t.getFromEnv(\"animationManager\"),\n              n = t.config,\n              i = n.trackIndex = {},\n              l = t.components.data,\n              s = void 0,\n              c = void 0,\n              u = t.components.data,\n              p = void 0,\n              h = void 0,\n              d = n.shadow,\n              g = void 0,\n              f = {},\n              m = void 0,\n              v = n.rallyThickness,\n              b = n.declineThickness,\n              y = {\n            stroke: (0, r.toRaphaelColor)({\n              color: n.rallyColor,\n              alpha: n.rallyAlpha\n            }),\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-width\": v,\n            \"stroke-dasharray\": n.rallyDashed\n          },\n              x = {\n            stroke: (0, r.toRaphaelColor)({\n              color: n.declineColor,\n              alpha: n.declineAlpha\n            }),\n            \"stroke-linecap\": \"round\",\n            \"stroke-linejoin\": \"round\",\n            \"stroke-width\": b,\n            \"stroke-dasharray\": n.declineDashed\n          },\n              w = o.rallyElem,\n              k = void 0,\n              C = o.declineElem,\n              N = void 0,\n              S = void 0,\n              E = t.getContainer(\"commonElemsGroup\"),\n              A = t.getContainer(\"plotGroup\"),\n              D = t.getContainer(\"shadowGroup\"),\n              T = void 0;\n          if (!l.length) return k && k.hide(), void (N && N.hide());\n          k && k.show(), N && N.show(), (0, r.fcEach)(l, function (o, r) {\n            o = o.config, p = u[r], m = p.config, e = p.graphics, T = e.image, h = m.hoverEffects, s = p._yPos, i[o.plotX] || (i[o.plotX] = []), i[o.plotX].push(r), p._index = o.plotX, f = m.anchorProps, g = f.shadow, void 0 !== s && !isNaN(s) && o.isDefined ? (f.imageUrl ? t.drawAnchorImage(p) : (T && T.hide(), c = e.element, S = o.props.element.attr, (c = e.element = a.setAnimation({\n              el: c || \"path\",\n              attr: S,\n              container: A,\n              component: t,\n              label: \"anchor\"\n            })).show().shadow(g, D).data(\"anchorRadius\", f.radius).data(\"anchorHoverRadius\", h.anchorRadius).data(\"hoverEnabled\", h.enabled).data(\"eventArgs\", o.eventArgs)), h.enabled && c && c.data(\"anchorRadius\", f.radius).data(\"anchorHoverRadius\", h.anchorRadius).data(\"hoverEnabled\", h.enabled).data(\"setRolloverAttr\", h.attrs.setRolloverAttr).data(\"setRolloutAttr\", h.attrs.setRolloutAttr).data(\"eventArgs\", o.eventArgs)) : (e.element && e.element.hide(), T && T.hide());\n          }), y.path = n.rallyPath, (k = a.setAnimation({\n            el: w || \"path\",\n            attr: y,\n            container: E,\n            component: t,\n            label: \"line\"\n          })).shadow(v && d, D), w || t.addGraphicalElement(\"rallyElem\", k), x.path = n.declinePath, (N = a.setAnimation({\n            el: C || \"path\",\n            attr: x,\n            container: E,\n            component: t,\n            label: \"line\"\n          })).shadow(b && d, D), C || t.addGraphicalElement(\"declineElem\", N);\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = h;\n    },\n    503: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"*.dataset.kagi\": n[\"default\"][\"*.dataset.line\"]\n      };\n    },\n    504: function _(e, t, o) {\n      \"use strict\";\n\n      (function (e) {\n        t.__esModule = !0;\n        var a = o(118),\n            r = c(o(414)),\n            n = c(o(505)),\n            i = o(125),\n            l = o(486),\n            s = c(o(231));\n\n        function c(e) {\n          return e && e.__esModule ? e : {\n            \"default\": e\n          };\n        }\n\n        function u(e, t) {\n          if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n          e.prototype = Object.create(t && t.prototype, {\n            constructor: {\n              value: e,\n              enumerable: !1,\n              writable: !0,\n              configurable: !0\n            }\n          }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n            for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n              var r = o[a],\n                  n = Object.getOwnPropertyDescriptor(t, r);\n              n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n            }\n          }(e, t));\n        }\n\n        var p = (0, i.getDep)(\"redraphael\", \"plugin\"),\n            h = \",\",\n            d = \"config\",\n            g = \"rgba(192,192,192,\" + (a.isIE ? .002 : 1e-6) + \")\",\n            f = \"visible\",\n            m = \"hidden\",\n            v = \"round\",\n            b = \"pointer\",\n            y = Math.PI / 180,\n            x = \"M\",\n            w = \"L\",\n            k = \"t\";\n        (0, s[\"default\"])(p), p.addSymbol({\n          resizeIcon: function resizeIcon(e, t, o) {\n            var r,\n                n = (0, a.pluckNumber)(o, 15) / 3,\n                i = [];\n\n            for (n < 0 && (e += (o = -o) - (n = -n) / 2, t += o - n / 2), r = 3; r > 0; r -= 1) {\n              i.push(x, e - n * r, t - 3, w, e - 3, t - n * r);\n            }\n\n            return i;\n          },\n          closeIcon: function closeIcon(e, t, o) {\n            var a = e,\n                r = t,\n                n = 1.3 * o,\n                i = 43 * y,\n                l = 48 * y,\n                s = a + n * Math.cos(i),\n                c = r + n * Math.sin(i),\n                u = .71 * (o - 2),\n                p = .71 * (o - 2),\n                h = function (e, t, o, a, r, n) {\n              return [\"A\", o, a, 0, n, r, e, t];\n            }(a + n * Math.cos(l), r + n * Math.sin(l), n, n, 0, 1);\n\n            return [x, s, c].concat(h).concat([x, e + u, t - p, w, e - u, t + p, x, e - u, t - p, w, e + u, t + p]);\n          },\n          configureIcon: function configureIcon(e, t, o) {\n            var a = .25,\n                r = .71 * (o -= 1),\n                n = .71 * (o + 2),\n                i = e - o,\n                l = t - o,\n                s = e + o,\n                c = t + o,\n                u = e + .5,\n                p = t + .5,\n                h = e - .5,\n                d = t - .5,\n                g = i - 2,\n                f = l - 2,\n                m = s + 2,\n                v = c + 2,\n                b = e + r,\n                y = t + r,\n                k = e - r,\n                C = t - r,\n                N = e + n,\n                S = t + n,\n                E = e - n,\n                A = t - n;\n            return [x, i, p, w, g, p, g, d, i, d, k - a, C + a, E - a, A + a, E + a, A - a, k + a, C - a, h, l, h, f, u, f, u, l, b - a, C - a, N - a, A - a, N + a, A + a, b + a, C + a, s, d, m, d, m, p, s, p, b + a, y - a, N + a, S - a, N - a, S + a, b - a, y + a, u, c, u, v, h, v, h, c, k + a, y + a, E + a, S + a, E - a, S - a, k - a, y - a, \"Z\"];\n          },\n          axisIcon: function axisIcon(e, t, o) {\n            var a = .33 * (o -= 1),\n                r = o / 2,\n                n = e - o,\n                i = t - o,\n                l = e + r,\n                s = t + o,\n                c = e - r,\n                u = t + a,\n                p = t - a;\n            return [x, n, i, w, l, i, l, s, n, s, x, c, u, w, l, u, x, c, p, w, l, p];\n          },\n          loggerIcon: function loggerIcon(e, t, o) {\n            var a = (e -= o -= 1) + 2 * o,\n                r = e + 2,\n                n = a - 2,\n                i = (t -= o) + 2,\n                l = i + o,\n                s = l + 2;\n            return [x, e, t, w, a, t, a, i, n, i, n, l, a, l, a, s, e, s, e, l, r, l, r, i, e, i, e, t];\n          }\n        });\n\n        var C = function (t) {\n          function o() {\n            !function (e, t) {\n              if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }(this, o);\n\n            var e = function (e, t) {\n              if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n              return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n            }(this, t.call(this));\n\n            return e.isXY = !0, e.defaultZeroPlaneHighlighted = !1, e.eiMethods = {\n              getData: function getData(e) {\n                var t = this.apiInstance;\n                return t && t.getData(e);\n              },\n              restoreData: function restoreData() {\n                var e = this.apiInstance;\n                return e && e.restoreData();\n              },\n              submitData: function submitData() {\n                var e = this.apiInstance;\n                return e && e.submitData();\n              }\n            }, e;\n          }\n\n          return u(o, t), o.getName = function () {\n            return \"SelectScatter\";\n          }, o.prototype.parseChartAttr = function (e) {\n            t.prototype.parseChartAttr.call(this, e), this.config.formBtnTitle = (0, a.pluck)(e.chart.submittext, e.chart.formbtntitle, \"Submit\"), this.config.restoreBtnTitle = (0, a.pluck)(e.chart.restoretext, e.chart.restorebtntitle, \"Restore\");\n          }, o.prototype.getName = function () {\n            return \"SelectScatter\";\n          }, o.prototype.configureAttributes = function (e) {\n            var o = this.getFromEnv(\"chart\").config,\n                r = this.getFromEnv(\"dataSource\").chart || {};\n            o.formAction = (0, a.getValidValue)(r.formaction), o.enableSubmit = (0, a.pluckNumber)(r.enablesubmit, r.showformbtn, 1) && o.formAction, o.enableRestore = (0, a.pluckNumber)(r.enablerestore, r.showrestorebtn, 1), t.prototype.configureAttributes.call(this, e);\n          }, o.prototype.__setDefaultConfig = function () {\n            t.prototype.__setDefaultConfig.call(this);\n\n            var e = this.config;\n            e.friendlyName = \"Dragable Scatter Chart\", e.hasLegend = !0, e.defaultDatasetType = \"selectScatter\", e.allowreversexaxis = !0, e.enablemousetracking = !0;\n          }, o.prototype._createToolBox = function () {\n            var e;\n\n            t.prototype._createToolBox.call(this);\n\n            var o = this,\n                a = o.getFromEnv(\"chartConfig\"),\n                r = o.getFromEnv(\"chartMenuList\"),\n                n = [];\n\n            if (a.enableRestore && n.push(((e = {})[a.restoreBtnTitle] = {\n              handler: function handler() {\n                o.restoreData();\n              },\n              action: \"click\"\n            }, e)), a.enableSubmit) {\n              var i = {};\n              i[a.formBtnTitle] = {\n                handler: function handler() {\n                  l.submitData.call(o);\n                },\n                action: \"click\"\n              }, n.push(i);\n            }\n\n            r.appendAsList(n);\n          }, o.prototype.getData = function (t) {\n            var o,\n                r,\n                n,\n                i = this.getCollatedData(),\n                l = [],\n                s = i.dataset,\n                c = s && s.length || 0,\n                u = 0,\n                p = 0;\n            if (t) l = /^json$/gi.test(t) ? i : /^csv$/gi.test(t) ? this.getCSVString() : e.core.transcodeData(i, \"json\", t);else for (; u < c; u += 1) {\n              if (r = s[u]) {\n                for ((n = o = (r = s[u] && s[u].data) && r.length || 0) && (l[p] || (l[p] = [(0, a.getValidValue)(s[u].id, \"null\")])); n--;) {\n                  l[p][n + 1] = (0, a.getValidValue)(r[n].id, \"null\");\n                }\n\n                o && (p += 1);\n              }\n            }\n            return l;\n          }, o.prototype.getCSVString = function () {\n            for (var e = this.getData(), t = e.length; t--;) {\n              e[t] = e[t].join(h);\n            }\n\n            return e.join(\"|\");\n          }, o.prototype.getCollatedData = function (e) {\n            var t,\n                o,\n                r,\n                n,\n                i,\n                l,\n                s,\n                c,\n                u,\n                p,\n                h,\n                d = this.getDatasets(),\n                g = this.config._selectEleArr,\n                f = g && g.length || 0,\n                m = e || this.getFromEnv(\"dataSource\"),\n                v = (0, a.extend2)({}, m),\n                b = v.dataset,\n                y = b && b.length,\n                x = !1,\n                w = [];\n            if (!f || !y) return m;\n\n            for (; f--;) {\n              if (n = g[f]) for (c = n.startX, u = n.endX, p = n.startY, h = n.endY, i = y; i--;) {\n                if (d[i].getState(\"visible\")) for (w[i] || (w[i] = {\n                  data: []\n                }), s = (r = b[i].data) && r.length; s--;) {\n                  t = (l = r[s]).x, o = l.y, t > c && t < u && o < p && o > h && (w[i].data[s] = x = !0);\n                }\n              }\n            }\n\n            for (; y--;) {\n              for (s = (r = b[y].data) && r.length; s--;) {\n                w[y] && w[y].data[s] || r.splice(s, 1);\n              }\n            }\n\n            return x ? v : m;\n          }, o.prototype.createSelectionBox = function (e) {\n            (function (e) {\n              var t,\n                  o = e.chart,\n                  r = o.getFromEnv(\"paper\"),\n                  n = o.config,\n                  i = o.getChildren(\"yAxis\")[0],\n                  l = o.getChildren(\"xAxis\")[0],\n                  s = e.selectionLeft,\n                  c = e.selectionTop,\n                  u = e.selectionWidth,\n                  p = e.selectionHeight,\n                  y = s + u,\n                  x = c + p,\n                  w = u > 15 && p > 15,\n                  C = {\n                resizeEleRadius: 15,\n                canvasTop: n.canvasTop,\n                canvasRight: n.canvasLeft + n.canvasWidth,\n                canvasLeft: n.canvasLeft,\n                canvasBottom: n.canvasTop + n.canvasHeight\n              },\n                  N = o.getChildContainer(\"trackerGroup\"),\n                  S = n._selectEleArr || (n._selectEleArr = []);\n              C.index = S.length, C.id = \"SELECT_\" + C.index, C.selectBoxG = t = r.group(\"selection-box\", N).toFront(), C.selectBoxTracker = r.rect(s, c, u, p, t).attr({\n                \"stroke-width\": 1,\n                stroke: (0, a.toRaphaelColor)(n.selectBorderColor),\n                fill: n.selectFillColor\n              }).css({\n                cursor: \"move\"\n              }), C.selectBoxTracker.node._isTrackerElem = !0, C.selectBoxTracker.data(d, {\n                position: 6,\n                selectEleObj: C,\n                chart: o,\n                xChange: !0,\n                yChange: !0\n              }), C.topTracker = r.rect(s, c - 6, u, 12, t).attr({\n                \"stroke-width\": 0,\n                fill: g\n              }).css(\"cursor\", a.hasSVG ? \"ns-resize\" : \"n-resize\"), C.topTracker.node._isTrackerElem = !0, C.topTracker.data(d, {\n                position: 1,\n                selectEleObj: C,\n                yChange: !0,\n                chart: o\n              }), C.rightTracker = r.rect(s + u - 6, c, 12, p, t).attr({\n                \"stroke-width\": 0,\n                fill: g\n              }).css(\"cursor\", a.hasSVG ? \"ew-resize\" : \"w-resize\"), C.rightTracker.node._isTrackerElem = !0, C.rightTracker.data(d, {\n                position: 2,\n                chart: o,\n                selectEleObj: C,\n                xChange: !0\n              }), C.bottomTracker = r.rect(s, c + p - 6, u, 12, t).attr({\n                \"stroke-width\": 0,\n                fill: g\n              }).css(\"cursor\", a.hasSVG ? \"ns-resize\" : \"n-resize\"), C.bottomTracker.node._isTrackerElem = !0, C.bottomTracker.data(d, {\n                position: 3,\n                chart: o,\n                selectEleObj: C,\n                yChange: !0\n              }), C.leftTracker = r.rect(s - 6, c, 12, p, t).attr({\n                \"stroke-width\": 0,\n                fill: g\n              }).css(\"cursor\", a.hasSVG ? \"ew-resize\" : \"e-resize\"), C.leftTracker.node._isTrackerElem = !0, C.leftTracker.data(d, {\n                position: 4,\n                chart: o,\n                selectEleObj: C,\n                xChange: !0\n              }), C.cornerInnerSymbol = r.symbol(\"resizeIcon\", 0, 0, 15, t).attr({\n                transform: k + y + h + x,\n                \"stroke-width\": 1,\n                visibility: w ? f : m,\n                stroke: \"#999999\"\n              }), C.cornerInnerSymbol.node._isTrackerElem = !0, C.cornerOuterSymbol = r.symbol(\"resizeIcon\", 0, 0, -12, t).attr({\n                transform: k + y + h + x,\n                strokeWidth: 1,\n                visibility: w ? m : f,\n                stroke: \"#777777\"\n              }), C.cornerOuterSymbol.node._isTrackerElem = !0, C.resizeTracker = r.circle(y, x, 12, t).attr({\n                \"stroke-width\": 1,\n                stroke: g,\n                fill: g\n              }).css(\"cursor\", a.hasSVG ? \"nwse-resize\" : \"nw-resize\"), C.resizeTracker.node._isTrackerElem = !0, C.resizeTracker.data(d, {\n                position: 5,\n                chart: o,\n                selectEleObj: C,\n                yChange: !0,\n                xChange: !0\n              }), C.closeButton = r.symbol(\"closeIcon\", 0, 0, 6, t).attr({\n                transform: \"t\" + y + h + c,\n                \"stroke-width\": 2,\n                stroke: n.selectionCancelButtonBorderColor,\n                fill: n.selectionCancelButtonFillColor,\n                \"stroke-linecap\": v,\n                \"stroke-linejoin\": v\n              }).css({\n                cursor: b,\n                _cursor: \"hand\"\n              }).click(function () {\n                o.deleteSelection(this, o);\n              }), C.closeButton.node._isTrackerElem = !0, C.closeButton.data(d, {\n                chart: o,\n                index: C.index\n              }), C.startX = l.getValue(s), C.startY = i.getValue(c), C.endX = l.getValue(y), C.endY = i.getValue(x), C.isVisible = !0, S.push(C), o.bindDragEvent(C);\n            }).call(this, e);\n          }, o.prototype._deleteAllSelection = function () {\n            var e,\n                t,\n                o,\n                a,\n                r,\n                n = this.config._selectEleArr;\n\n            if (n) {\n              for (t = 0, o = n.length; t < o; t++) {\n                for (r in e = n[t]) {\n                  e.hasOwnProperty(r) && ((a = e[r]).remove && a.remove(), delete e[r]);\n                }\n              }\n\n              delete this.config._selectEleArr;\n            }\n          }, o.prototype.deleteSelection = function (e, t) {\n            (function (e, t) {\n              var o,\n                  a,\n                  r,\n                  n,\n                  i,\n                  l = e.data(d).index,\n                  s = t.config._selectEleArr,\n                  c = t.getChildren(\"xAxis\")[0],\n                  u = t.getChildren(\"yAxis\")[0];\n\n              for (r in i = {\n                selectionLeft: (n = (o = s.find(function (e) {\n                  return e.index === l;\n                })).selectBoxTracker.getBBox()).x,\n                selectionTop: n.y,\n                selectionWidth: n.width,\n                selectionHeight: n.height,\n                startXValue: c.getValue(n.x, 1),\n                startYValue: u.getValue(n.y, 1),\n                endXValue: c.getValue(n.x + n.width, 1),\n                endYValue: u.getValue(n.y + n.height, 1),\n                data: t.getCollatedData(),\n                id: o.id\n              }, o) {\n                o.hasOwnProperty(r) && ((a = o[r]).remove && a.remove(), delete o[r]);\n              }\n\n              s = s.filter(function (e) {\n                return Object.keys(e).length;\n              }), t.fireChartInstanceEvent(\"selectionRemoved\", i);\n            }).call(this, e, t);\n          }, o.prototype.bindDragEvent = function (e) {\n            var t;\n\n            for (t in e) {\n              /Tracker/.test(t) && e[t].drag(this.move, this.start, this.up);\n            }\n          }, o.prototype.start = function () {\n            var e = this.data(d).selectEleObj,\n                t = e.topTracker,\n                o = e.rightTracker,\n                a = e.bottomTracker,\n                r = e.leftTracker,\n                n = e.resizeTracker,\n                i = t.data(d),\n                l = o.data(d),\n                s = a.data(d),\n                c = r.data(d),\n                u = n.data(d),\n                p = e.selectBoxTracker.data(d),\n                h = e.selectBoxTracker.getBBox();\n            i.ox = h.x, i.oy = h.y, l.ox = h.x2, l.oy = h.y, s.ox = h.x, s.oy = h.y2, c.ox = h.x, c.oy = h.y, i.ox = h.x, i.oy = h.y, u.ox = h.x2, u.oy = h.y2, p.ox = h.x, p.oy = h.y, p.ow = h.width, p.oh = h.height, p.ox2 = h.x2, p.oy2 = h.y2, e.selectBoxG.toFront(), t.hide(), o.hide(), a.hide(), r.hide(), n.hide(), this.show();\n          }, o.prototype.move = function (e) {\n            var t,\n                o,\n                a,\n                r,\n                n = this.data(d),\n                i = n.selectEleObj,\n                l = n.chart,\n                s = i.topTracker,\n                c = i.rightTracker,\n                u = i.bottomTracker,\n                p = i.leftTracker,\n                h = i.resizeTracker,\n                g = i.selectBoxTracker,\n                f = i.canvasLeft,\n                m = i.canvasRight,\n                v = i.canvasTop,\n                b = i.canvasBottom,\n                y = l.getChildren(\"xAxis\")[0],\n                x = l.getChildren(\"yAxis\")[0],\n                w = g.data(d),\n                k = {},\n                C = e.data[0],\n                N = e.data[1];\n\n            switch (C = n.xChange ? C : 0, N = n.yChange ? N : 0, a = C + n.ox, r = N + n.oy, a = Math.min(m - (n.ow || 0), Math.max(a, f)), r = Math.min(b - (n.oh || 0), Math.max(r, v)), n.position) {\n              case 1:\n                k.y = Math.min(w.oy2, r), k.height = Math.abs(w.oy2 - r) || 1, s.attr({\n                  y: r + -6\n                });\n                break;\n\n              case 2:\n                k.x = Math.min(w.ox, a), k.width = Math.abs(w.ox - a) || 1, c.attr({\n                  x: a + -6\n                });\n                break;\n\n              case 3:\n                k.y = Math.min(w.oy, r), k.height = Math.abs(w.oy - r) || 1, u.attr({\n                  y: r + -6\n                });\n                break;\n\n              case 4:\n                k.x = Math.min(w.ox2, a), k.width = Math.abs(w.ox2 - a) || 1, p.attr({\n                  x: a + -6\n                });\n                break;\n\n              case 5:\n                k.x = Math.min(w.ox, a), k.width = Math.abs(w.ox - a) || 1, k.y = Math.min(w.oy, r), k.height = Math.abs(w.oy - r) || 1, h.attr({\n                  cx: a,\n                  cy: r\n                });\n                break;\n\n              default:\n                k.x = a, k.y = r;\n            }\n\n            this.data(\"dragStarted\") || (o = {\n              selectionLeft: (t = g.getBBox()).x,\n              selectionTop: t.y,\n              selectionWidth: t.width,\n              selectionHeight: t.height,\n              startXValue: y.getValue(t.x),\n              startYValue: x.getValue(t.y),\n              endXValue: y.getValue(t.x + t.width),\n              endYValue: x.getValue(t.y + t.height),\n              id: i.id\n            }, l.fireChartInstanceEvent(\"BeforeSelectionUpdate\", o), this.data(\"dragStarted\", 1)), g.animate(k), i.isVisible && (i.closeButton.hide(), i.cornerInnerSymbol.hide(), i.cornerOuterSymbol.hide(), i.isVisible = !1);\n          }, o.prototype.up = function () {\n            var e,\n                t,\n                o = this,\n                a = o.data(d),\n                r = a.selectEleObj,\n                n = a.chart,\n                i = n.getChildren(\"xAxis\")[0],\n                l = n.getChildren(\"yAxis\")[0],\n                s = r.topTracker,\n                c = r.rightTracker,\n                u = r.bottomTracker,\n                p = r.leftTracker,\n                g = r.resizeTracker,\n                f = r.selectBoxTracker;\n            setTimeout(function () {\n              e = f.getBBox(), r.startX = i.getValue(e.x), r.startY = l.getValue(e.y), r.endX = i.getValue(e.x2), r.endY = l.getValue(e.y2), s.attr({\n                x: e.x,\n                y: e.y + -6,\n                width: e.width\n              }), c.attr({\n                x: e.x2 + -6,\n                y: e.y,\n                height: e.height\n              }), u.attr({\n                x: e.x,\n                y: e.y2 + -6,\n                width: e.width\n              }), p.attr({\n                x: e.x + -6,\n                y: e.y,\n                height: e.height\n              }), g.attr({\n                cx: e.x2,\n                cy: e.y2\n              }), r.closeButton.transform(k + e.x2 + h + e.y), r.cornerInnerSymbol.transform(k + e.x2 + h + e.y2), r.cornerOuterSymbol.transform(k + e.x2 + h + e.y2), r.closeButton.show(), e.width < 15 || e.height < 15 ? (r.cornerInnerSymbol.hide(), r.cornerOuterSymbol.show()) : (r.cornerInnerSymbol.show(), r.cornerOuterSymbol.hide()), r.isVisible = !0, s.show(), c.show(), u.show(), p.show(), g.show(), o.data(\"dragStarted\") && (t = {\n                selectionLeft: e.x,\n                selectionTop: e.y,\n                selectionWidth: e.width,\n                selectionHeight: e.height,\n                startXValue: i.getValue(e.x),\n                startYValue: l.getValue(e.y),\n                endXValue: i.getValue(e.x + e.width),\n                endYValue: l.getValue(e.y + e.height),\n                data: n.getCollatedData(),\n                id: r.id\n              }, n.fireChartInstanceEvent(\"SelectionUpdated\", t), o.data(\"dragStarted\", 0));\n            }, 100);\n          }, o.prototype.restoreData = function () {\n            var e,\n                t = [];\n\n            for (this.iterateComponents(function (e) {\n              e.getType && \"dataset\" === e.getType() && t.push(e);\n            }), this._deleteAllSelection(), e = 0; e < t.length; e++) {\n              t[e].asyncDraw();\n            }\n\n            return this.fireChartInstanceEvent(\"dataRestored\", {}), !0;\n          }, o.prototype._postSpaceManagement = function () {\n            t.prototype._postSpaceManagement.call(this), this._deleteAllSelection();\n          }, o.prototype.getDSdef = function () {\n            return n[\"default\"];\n          }, o.prototype.getDSGroupdef = function () {}, o;\n        }(r[\"default\"]);\n\n        t[\"default\"] = C;\n      }).call(this, o(111));\n    },\n    505: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = c(o(418)),\n          r = o(118),\n          n = o(122),\n          i = o(125),\n          l = c(o(506)),\n          s = o(125);\n\n      function c(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function u(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var p = r.preDefStr.altHGridColorStr,\n          h = r.preDefStr.altHGridAlphaStr;\n      (0, s.addDep)({\n        name: \"selectScatterAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var d = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return u(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"selectScatter\";\n        }, t.prototype.configure = function (t) {\n          e.prototype.configure.call(this, t);\n          var o = this.getFromEnv(\"chart\"),\n              a = o.config,\n              l = o.getFromEnv(\"dataSource\").chart,\n              s = this.getFromEnv(\"color-manager\"),\n              c = (0, r.pluck)(l.selectbordercolor, s.getColor(\"canvasBorderColor\")),\n              u = (0, r.pluckNumber)(l.selectborderalpha, s.getColor(\"canvasBorderAlpha\"));\n          a.selectBorderColor = {\n            FCcolor: {\n              color: c,\n              alpha: u\n            }\n          }, a.selectFillColor = (0, n.convertColor)((0, r.pluck)(l.selectfillcolor, s.getColor(p)), (0, r.pluckNumber)(l.selectfillalpha, s.getColor(h))), a.selectionCancelButtonBorderColor = (0, n.convertColor)((0, r.pluck)(l.selectioncancelbuttonbordercolor, c), (0, r.pluckNumber)(l.selectioncancelbuttonborderalpha, u)), a.selectionCancelButtonFillColor = (0, n.convertColor)((0, r.pluck)(l.selectioncancelbuttonfillcolor, \"FFFFFF\"), (0, r.pluckNumber)(l.selectioncancelbuttonfillalpha, 100)), a.connativeZoom = !1, a.zoomType = \"xy\", l.submitdataasxml !== r.ZEROSTRING || l.formdataformat || (l.formdataformat = (0, i.getDepsByType)(\"transcoder\").csv && \"csv\"), a.formDataFormat = (0, r.pluck)(l.formdataformat), a.formTarget = (0, r.pluck)(l.formtarget, \"_self\"), a.formMethod = (0, r.pluck)(l.formmethod, \"POST\"), a.submitFormAsAjax = (0, r.pluckNumber)(l.submitformusingajax, 1);\n        }, t.prototype.draw = function () {\n          e.prototype.draw.call(this);\n          var t = this.getFromEnv(\"chart\"),\n              o = t.getFromEnv(\"chart-container\"),\n              a = this.getFromEnv(\"xAxis\"),\n              n = this.getFromEnv(\"yAxis\");\n          (0, r.bindSelectionEvent)(t, {\n            selectionStart: function selectionStart(e) {\n              var t = (0, r.getMouseCoordinate)(o, e.originalEvent),\n                  i = (0, r.extend2)({\n                selectionLeft: e.selectionLeft,\n                selectionTop: e.selectionTop,\n                selectionWidth: e.selectionWidth,\n                selectionHeight: e.selectionHeight,\n                startXValue: a.getValue(e.selectionLeft, 1),\n                startYValue: n.getValue(e.selectionTop, 1)\n              }, t);\n              e.chart.fireChartInstanceEvent(\"selectionStart\", i);\n            },\n            selectionEnd: function selectionEnd(e) {\n              var t = (0, r.getMouseCoordinate)(o, e.originalEvent),\n                  i = (0, r.extend2)({\n                selectionLeft: e.selectionLeft,\n                selectionTop: e.selectionTop,\n                selectionWidth: e.selectionWidth,\n                selectionHeight: e.selectionHeight,\n                startXValue: a.getValue(e.selectionLeft, 1),\n                startYValue: n.getValue(e.selectionTop, 1),\n                endXValue: a.getValue(e.selectionLeft + e.selectionWidth, 1),\n                endYValue: n.getValue(e.selectionTop + e.selectionHeight, 1)\n              }, t);\n              e.chart.fireChartInstanceEvent(\"selectionEnd\", i), e.chart.createSelectionBox(e);\n            }\n          });\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = d;\n    },\n    506: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"*.dataset.selectScatter\": n[\"default\"][\"*.dataset.line\"]\n      };\n    },\n    507: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = n(o(261)),\n          r = n(o(508));\n\n      function n(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function i(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var l = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.defaultPaletteOptions = null, o.registerFactory(\"dataset\", r[\"default\"], [\"canvas\"]), o;\n        }\n\n        return i(t, e), t.getName = function () {\n          return \"MultilevelPie\";\n        }, t.prototype.getName = function () {\n          return \"MultilevelPie\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.is3D = !1, t.friendlyName = \"Multi-level Pie Chart\", t.hasLegend = !1, t.defaultDatasetType = \"multiLevelPie\", t.valuefontbold = 0, t.skipCanvasDrawing = !0;\n        }, t.prototype._checkInvalidSpecificData = function () {}, t.prototype._spaceManager = function () {\n          var e,\n              t = this.config;\n          this._allocateSpace(this._manageActionBarSpace && this._manageActionBarSpace(.225 * t.availableHeight) || {}), e = .7 * t.canvasHeight, this._manageChartMenuBar(e);\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = l;\n    },\n    508: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o,\n            a = e.getFromEnv(\"dataSource\"),\n            n = void 0,\n            l = {};\n        o = (t = e.config.categories = a.category || []).length, !n && o && (l = t, n = o), o ? (0, r.datasetFactory)(e, i[\"default\"], \"dataset\", n, [l]) : e.setChartMessage();\n      };\n      var a,\n          r = o(118),\n          n = o(509),\n          i = (a = n) && a.__esModule ? a : {\n        \"default\": a\n      };\n    },\n    509: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = u(o(369)),\n          r = o(118),\n          n = o(122),\n          i = o(125),\n          l = u(o(510)),\n          s = o(129),\n          c = u(o(211));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = (0, i.getDep)(\"redraphael\", \"plugin\"),\n          d = /^[0-9]+\\%?$|^([0-9]+[.][0-9]+)\\%?$/;\n      (0, i.addDep)({\n        name: \"multilevelpieAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      }), (0, c[\"default\"])(h);\n\n      var g = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.components = {\n            data: []\n          }, o.graphics = {}, o;\n        }\n\n        return p(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"multiLevelPie\";\n        }, t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.config.JSONData = e;\n\n          var t,\n              o,\n              a,\n              i = this.getFromEnv(\"chart\"),\n              l = i.config,\n              s = this.config || (this.config = {}),\n              c = s.dataLabelOptions || (s.dataLabelOptions = {}),\n              u = s.piePlotOptions,\n              p = i.config.style,\n              h = this.config.JSONData,\n              g = i.getFromEnv(\"dataSource\").chart,\n              f = s.enableAnimation = (0, r.pluckNumber)(g.animation, g.defaultanimation, 1),\n              m = (0, r.pluckNumber)(-g.centerangle, 180),\n              v = (0, r.pluckNumber)(g.totalangle, 360),\n              b = function b(e, t) {\n            for (var o = this.data(\"plotItem\"); e.graphics.element;) {\n              e.graphics.element.attr({\n                fill: \"mouseover\" === t ? s.hoverFillColor : (e.config || o).color\n              }), e = e.config.parent;\n            }\n          },\n              y = function w(e, t) {\n            var o,\n                a = this.data(\"plotItem\");\n\n            for (e.graphics.element.attr({\n              fill: \"mouseover\" === t ? s.hoverFillColor : (e.config || a).color\n            }), o = 0; o < (e.components.data && e.components.data.length); o++) {\n              w.call(this, e.components.data[o], t);\n            }\n          },\n              x = function x(e) {\n            if (s.useHoverColor) {\n              var t = this.data(\"plotItem\"),\n                  o = t.selfRef;\n              s.highlightParentPieSlices || s.highlightChildPieSlices ? !s.highlightParentPieSlices && s.highlightChildPieSlices ? y.call(this, o, e) : s.highlightParentPieSlices && !s.highlightChildPieSlices ? b.call(this, o, e) : s.highlightParentPieSlices && s.highlightChildPieSlices && (b.call(this, o, e), y.call(this, o, e)) : o.graphics.element.attr({\n                fill: \"mouseover\" === e ? s.hoverFillColor : (o.config || t).color\n              });\n            }\n          };\n\n          s.animation = !!f && {\n            duration: 1e3 * (0, r.pluckNumber)(g.animationduration, g.moveduration, 1)\n          }, s.showShadow = (0, r.pluckNumber)(g.showshadow, 0), s.useHoverColor = Boolean((0, r.pluckNumber)(g.usehovercolor, 1)), s.hoverFillColor = (0, n.convertColor)((0, r.pluck)(g.hoverfillcolor, \"FF5904\"), (0, r.pluckNumber)(g.hoverfillalpha, 100)), t = (t = (0, r.getFirstValue)(g.valuebordercolor, \"\")) ? (0, n.convertColor)(t, (0, r.pluckNumber)(g.valueborderalpha, g.valuebgalpha, g.valuealpha, 100)) : \"\", !c.style && (c.style = {\n            fontFamily: (0, r.pluck)(g.valuefont, p.fontFamily),\n            fontSize: (0, r.pluckNumber)(g.valuefontsize, (o = p.fontSize, a = 10, parseInt(o, a || 10))) + \"px\",\n            color: (0, n.convertColor)((0, r.pluck)(g.valuefontcolor, p.color), (0, r.pluckNumber)(g.valuefontalpha, g.valuealpha, 100)),\n            fontWeight: (0, r.pluckNumber)(g.valuefontbold) ? \"bold\" : \"normal\",\n            fontStyle: (0, r.pluckNumber)(g.valuefontitalic) ? \"italic\" : \"normal\",\n            backgroundColor: g.valuebgcolor ? (0, n.convertColor)(g.valuebgcolor, (0, r.pluckNumber)(g.valuebgalpha, g.valuealpha, 100)) : \"\",\n            border: t || g.valuebgcolor ? (0, r.pluckNumber)(g.valueborderthickness, 1) + \"px solid\" : \"\",\n            borderPadding: (0, r.pluckNumber)(g.valueborderpadding, 2),\n            borderThickness: (0, r.pluckNumber)(g.valueborderthickness, p.borderThickness, 1),\n            borderRadius: (0, r.pluckNumber)(g.valueborderradius, p.borderRadius, 0),\n            borderColor: t,\n            borderDash: (0, r.pluckNumber)(g.valueborderdashed, 0) ? (0, r.getDashStyle)((0, r.pluckNumber)(g.valueborderdashlen, 4), (0, r.pluckNumber)(g.valueborderdashgap, 2)) : \"none\"\n          }), !u && (u = s.piePlotOptions = {}), u.allowPointSelect = !1, s.borderColor = (0, n.convertColor)((0, r.pluck)(g.plotbordercolor, g.piebordercolor, \"FFFFFF\"), g.showplotborder != r.ZEROSTRING ? (0, r.pluck)(g.plotborderalpha, g.pieborderalpha, 100) : 0), s.showTooltip = (0, r.pluckNumber)(g.showtooltip, 1), s.borderWidth = (0, r.pluckNumber)(g.pieborderthickness, g.plotborderthickness, 1), u.startingAngle = 0, u.size = \"100%\", s.highlightParentPieSlices = (0, r.pluckNumber)(g.highlightparentpieslices, g.highlightparentpienodes, 1), s.highlightChildPieSlices = (0, r.pluckNumber)(g.highlightchildpieslices, g.highlightchildpienodes, 0), s.showLabels = (0, r.pluckNumber)(g.showlabels, 1), s.showValues = (0, r.pluckNumber)(g.showvalues, 0), s.showValuesInTooltip = (0, r.pluckNumber)(g.showvaluesintooltip, g.showvalues, 0), s.showPercentValues = (0, r.pluckNumber)(g.showpercentvalues, g.showpercentagevalues, 0), s.showPercentInTooltip = (0, r.pluckNumber)(g.showpercentintooltip, 0), s.toolTipSepChar = (0, r.pluck)(g.tooltipsepchar, g.hovercapsepchar, r.COMMASPACE), s.labelSepChar = (0, r.pluck)(g.labelsepchar, s.toolTipSepChar), s.tooltext = g.plottooltext, s.alpha = (0, r.pluck)(g.plotfillalpha, g.piefillalpha, 100), s.startAngle = (m - v / 2) * (Math.PI / 180), s.endtAngle = (m + v / 2) * (Math.PI / 180), s.initialAngle = s.endtAngle, s.originX = (0, r.pluckNumber)(g.originx), s.originY = (0, r.pluckNumber)(g.originy), s.events = {\n            mouseOver: function mouseOver() {\n              x.call(this, \"mouseover\");\n            },\n            mouseOut: function mouseOut() {\n              x.call(this, \"mouseout\");\n            }\n          }, l.plotBorderWidth = 0, l.plotBorderWidth = 0, s.maxLevel = this.addMSPieCat(h, 1, this, s.startAngle, s.endtAngle), s.pieRadius = parseInt(g.pieradius, 10), s.innerRadius = \"0\", d.test(g.innerradius) && (s.innerRadius = (0, r.pluck)(g.innerradius)), c.distance = 0, c.placeLabelsInside = !0;\n        }, t.prototype.removalFn = function (e, t) {\n          this.getFromEnv(\"animationManager\").setAnimation({\n            el: e,\n            label: \"element\" === t ? \"ringpath\" : \"label\",\n            component: this,\n            callback: function callback() {\n              this.remove();\n            }\n          });\n        }, t.prototype.removeGraphics = function (e) {\n          var t,\n              o,\n              a,\n              r = e.components && e.components.data,\n              n = e.graphics;\n          if (r) for (a = r.length, t = 0; t < a; t += 1) {\n            this.removeGraphics(r[t]);\n          }\n          if (e.graphics) for (o in n) {\n            n.hasOwnProperty(o) && this.removalFn(e.graphics[o], o);\n          }\n        }, t.prototype.removeChild = function (e, t, o) {\n          var a, r;\n          if (e.length) for (a = 0; a < e.length; a += 1) {\n            r = e[a], o ? this.removalFn(r, t, o) : this.removeGraphics(r, t);\n          } else for (a in e) {\n            this.removeChild(e[a], t, a);\n          }\n        }, t.prototype.addMSPieCat = function (e, t, o, a, i) {\n          var l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k = (0, r.extend2)([], e),\n              C = k.length,\n              N = this,\n              S = o.components.data,\n              E = N.config,\n              A = E.borderWidth,\n              D = E.borderColor,\n              T = N.getFromEnv(\"number-formatter\"),\n              L = N.getFromEnv(\"color-manager\"),\n              _ = 0,\n              P = E.labelSepChar,\n              O = t,\n              V = S.length,\n              M = function M() {\n            N.removeChild.apply(N, arguments);\n          },\n              F = k.length,\n              I = i - a,\n              B = 0;\n\n          for (d = 0; d < C; d += 1) {\n            (p = k[d])._userValue = T.getCleanValue(p.value, !0), p._value = (0, r.pluckNumber)(p._userValue, 1), _ += p._value;\n          }\n\n          for (u = I / (_ = _ || 1), d = C - 1; d >= 0; d -= 1) {\n            h = u * (p = k[d])._value, g = (0, r.parseUnsafeString)((0, r.pluck)(p.label, p.name)), m = null !== p._userValue ? T.dataLabels(p._userValue) : \"\", v = T.percentValue(p._value / _ * 100), f = (0, r.pluckNumber)(p.alpha, E.alpha), y = E.showLabels ? g : \"\", E.showValues && (E.showPercentValues ? y += \"\" !== y ? P + v : v : void 0 !== m && \"\" !== m && (y += \"\" !== y ? P + m : m)), \"\" === (b = E.showTooltip ? (0, r.parseUnsafeString)((0, r.pluck)(p.tooltext, p.hovertext, E.tooltext)) : void 0) ? (b = g, E.showValuesInTooltip && (E.showPercentInTooltip ? b += \"\" !== b ? P + v : v : void 0 !== m && \"\" !== m && (b += \"\" !== b ? P + m : m))) : b = (0, r.parseTooltext)(b, [1, 2, 3, 14], {\n              percentValue: v,\n              label: g,\n              formattedValue: m\n            }, p), x = a + B, B += h, (l = S[d]) || (l = S[d] = {\n              components: {\n                data: []\n              },\n              config: {},\n              graphics: {}\n            }), l.graphics.element && (w = l.config.startAngle + l.config.angleStrech), l.config = {\n              initialAngle: w || (o.config || o.config).initialAngle,\n              startAngle: x,\n              angleStrech: h,\n              level: t,\n              displayValue: y,\n              toolText: b,\n              link: (0, r.getValidValue)(p.link),\n              doNotSlice: !0,\n              color: (0, n.convertColor)(p.color || L.getPlotColor(), f),\n              borderWidth: (0, r.pluckNumber)(p.borderwidth, A),\n              borderColor: (0, r.pluck)(p.bordercolor, D),\n              dashStyle: (0, r.pluckNumber)(p.valueborderdashed, 0) ? (0, r.getDashStyle)((0, r.pluckNumber)(p.borderdashlen, 4), (0, r.pluckNumber)(p.borderdashgap, 2)) : \"none\",\n              shadow: {\n                opacity: .01 * Math.round(f > 50 ? f * f * f * 1e-4 : f * f * .01)\n              },\n              isSingleTon: !(C > 1)\n            }, l.config.parent = o, p.category ? (O = Math.max(O, N.addMSPieCat(p.category, t + 1, l, x, h + x)), (s = l.components.data.length) > (c = p.category.length) && M(l.components.data.splice(s - 1, c))) : (s = l.components.data.length) && M(l.components.data.splice(0, s));\n          }\n\n          return V > F && M(S.splice(F)), O;\n        }, t.prototype.parsePlotAttributes = function (e) {\n          var t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b = this.config || {},\n              y = this.getFromEnv(\"chart\"),\n              x = y.config,\n              w = this.components.data.length,\n              k = x.dataLabelStyle,\n              C = x.textDirection,\n              N = x.canvasWidth,\n              S = x.canvasHeight,\n              E = (0, r.pluckNumber)(b.originX, x.canvasLeft + .5 * N),\n              A = (0, r.pluckNumber)(b.originY, x.canvasTop + .5 * S),\n              D = (0, r.pluckNumber)(2 * b.pieRadius, Math.min(N, S)),\n              T = function (e, t) {\n            var o = e && e.length,\n                a = void 0;\n            return e && (a = \"%\" === e.charAt(o - 1) ? (0, r.pluckNumber)(t) * ((0, r.pluckNumber)(e.split(\"%\")[0]) / 100) : (0, r.pluckNumber)(e)) < t ? a : 0;\n          }(b.innerRadius, D / 2),\n              L = this.config.pool || (this.config.pool = {}),\n              _ = (D - 2 * T) / (2 * b.maxLevel);\n\n          for (b.innerSize = 2 * T, e || (e = this), w = e.components.data.length, g = 0; g < w; g += 1) {\n            this.parsePlotAttributes(e.components.data[g]);\n          }\n\n          (n = (m = e.config).level) && (i = n * _ + T, l = (n - 1) * _ + T, f = e.graphics, c = m.angleStrech, u = m.displayValue, p = !!m.link, s = m.color, d = (h = m.startAngle) + m.angleStrech, v = f.element, L.element && L.element.length && (v = f.element = v || L.element.shift()), m.plotItem = {\n            chart: y,\n            link: m.link,\n            value: c,\n            color: s,\n            labelText: u,\n            graphics: {\n              element: v\n            },\n            selfRef: e\n          }, m.eventArgs = {\n            link: m.link,\n            label: m.displayValue,\n            toolText: m.toolText\n          }, m.props = {\n            element: {\n              attr: {\n                ringpath: [E, A, i, l, h, d],\n                \"stroke-width\": m.borderWidth,\n                stroke: m.borderColor,\n                fill: (0, r.toRaphaelColor)(m.color),\n                \"stroke-dasharray\": m.dashStyle,\n                cursor: p ? \"pointer\" : r.BLANKSTRING\n              }\n            }\n          }, void 0 !== u && u !== r.BLANKSTRING && (t = (h + d) / 2, a = 0 === l && m.isSingleTon ? 0 : l + (i - l) / 2, (o = m._textAttrs) || (o = m._textAttrs = {}), o.text = u, o.fill = k.color || \"000000\", o.direction = C, o.cursor = p ? \"pointer\" : r.BLANKSTRING, o.x = E + a * Math.cos(t), o.y = A + a * Math.sin(t), o[\"text-bound\"] = [k.backgroundColor, k.borderColor, k.borderThickness, k.borderPadding, k.borderRadius, k.borderDash]));\n        }, t.prototype.parseLabelAttributes = function (e) {\n          var t,\n              o,\n              a,\n              n,\n              i = this.components.data.length;\n\n          for (!e && (e = this), i = e.components.data.length, a = 0; a < i; a += 1) {\n            this.parseLabelAttributes(e.components.data[a]);\n          }\n\n          o = (n = e.config).displayValue, t = n._textAttrs, n.level && void 0 !== o && o !== r.BLANKSTRING && (n.props.label = {\n            attr: t\n          });\n        }, t.prototype.draw = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              n = this.config || {},\n              i = this.getFromEnv(\"chart\"),\n              l = this.getFromEnv(\"animationManager\"),\n              c = this.getFromEnv(\"toolTipController\"),\n              u = i.config,\n              p = this.components,\n              h = p.data.length,\n              d = u.dataLabelStyle,\n              g = n.showShadow,\n              f = i.getChildContainer(\"plotGroup\"),\n              m = i.getChildContainer(\"datalabelsGroup\"),\n              v = n.events || {},\n              b = this.config.pool || (this.config.pool = {}),\n              y = p.removeDataArr;\n\n          for (y && y.length && this.removeElement(), e || (e = this, m.css(d)), h = e.components.data.length, t = 0; t < h; t += 1) {\n            this.draw(e.components.data[t]);\n          }\n\n          (a = e.config).level ? (r = (o = e.graphics).element, b.element && b.element.length && (r = o.element = r || b.element.shift()), (r = o.element = l.setAnimation({\n            el: o.element || \"ringpath\",\n            attr: a.props.element.attr,\n            container: f,\n            component: this,\n            state: \"appearing\",\n            label: \"ringpath\"\n          })).shadow(g && !!a.shadow).data(\"plotItem\", a.plotItem).data(\"eventArgs\", a.eventArgs).mouseover(function (e) {\n            var t = this,\n                o = v.mouseOver,\n                r = t.plotItem || t.data(\"plotItem\"),\n                n = r.chart,\n                i = n.getDatasets()[0];\n            n.plotEventHandler(t, e, \"DataPlotRollOver\"), o && o.call(t), i.fireEvent(\"datasetrollover\", {\n              pValue: r.pValue,\n              value: r.value,\n              displayValue: a.displayValue\n            });\n          }).mouseout(function (e) {\n            var t = this,\n                o = v.mouseOut,\n                r = t.plotItem || t.data(\"plotItem\"),\n                n = r.chart,\n                i = n.getDatasets()[0];\n            n.plotEventHandler(t, e, \"DataPlotRollOut\"), o && o.call(t), i.fireEvent(\"datasetrollout\", {\n              pValue: r.pValue,\n              value: r.value,\n              displayValue: a.displayValue\n            });\n          }).mouseup(function (e) {\n            i.plotEventHandler(this, e);\n          }), c.enableToolTip(r, a.toolText), t || n._drawn || (n._drawn = !0, m.show(), this.addJob(\"labelJob\", this.drawLabel.bind(this), s.priorityList.label))) : (n._drawn && this.drawLabel(), this.removeChild(this.config.pool, !0));\n        }, t.prototype.drawLabel = function (e) {\n          var t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s = this.config || {},\n              c = this.getFromEnv(\"chart\"),\n              u = this.getFromEnv(\"animationManager\"),\n              p = c.config,\n              h = this.components.data.length,\n              d = p.dataLabelStyle,\n              g = this.getFromEnv(\"toolTipController\"),\n              f = p.tooltip || {},\n              m = f && !1 !== f.enabled,\n              v = s.events || {},\n              b = this.config.pool || (this.config.pool = {}),\n              y = c.getChildContainer(\"datalabelsGroup\");\n\n          for (y.show(), !e && (e = this), h = e.components.data.length, a = 0; a < h; a += 1) {\n            this.drawLabel(e.components.data[a]);\n          }\n\n          t = (i = e.config).plotItem, o = i.displayValue, i.level ? (l = (n = e.graphics).label, void 0 !== o && o !== r.BLANKSTRING ? (l = n.label, b.label && b.label.length && (l = n.label = l || b.label.shift()), (l = n.label = u.setAnimation({\n            el: l || \"text\",\n            attr: i.props.label.attr,\n            container: y,\n            component: this,\n            state: \"appearing\",\n            label: \"text\"\n          })).mouseup(function (e) {\n            c.plotEventHandler(this, e);\n          }).mouseout(function (e) {\n            var t = v.mouseOut;\n            c.plotEventHandler(this, e, \"DataPlotRollOut\"), t && t.call(this);\n          }).mouseover(function (e) {\n            var t = v.mouseOver;\n            c.plotEventHandler(this, e, \"DataPlotRollOver\"), t && t.call(this);\n          }).css(d).show().data(\"plotItem\", t).data(\"eventArgs\", i.eventArgs), m && g.enableToolTip(l, void 0)) : l && u.setAnimation({\n            el: l,\n            component: this,\n            callback: function callback() {\n              this.hide();\n            },\n            label: \"text\"\n          })) : this.removeChild(this.config.pool, !0);\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = g;\n    },\n    510: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.multiLevelPie\": function initialDatasetMultiLevelPie() {\n          var e = this.config,\n              t = void 0;\n          return {\n            \"ringpath.appearing\": function ringpathAppearing(o) {\n              return [{\n                initialAttr: {\n                  ringpath: [(t = o.attr.ringpath)[0], t[1], t[2], t[3], e.initialAngle, e.initialAngle]\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"text.appearing\": function textAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }];\n            }\n          };\n        }\n      };\n    },\n    511: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = u(o(428)),\n          r = u(o(512)),\n          n = u(o(537)),\n          i = u(o(538)),\n          l = o(125),\n          s = u(o(231)),\n          c = o(118);\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = c.preDefStr.defaultFontStr,\n          d = c.preDefStr.divLineAlphaStr,\n          g = c.preDefStr.altVGridColorStr,\n          f = c.preDefStr.altVGridAlphaStr,\n          m = c.preDefStr.colors.c000000,\n          v = c.preDefStr.POSITION_BOTTOM,\n          b = c.preDefStr.divLineAlpha3DStr,\n          y = (0, l.getDep)(\"redraphael\", \"plugin\");\n      (0, s[\"default\"])(y);\n\n      var x = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this)),\n              a = o;\n\n          return a.friendlyName = \"Multi-axis Line Chart\", a.defaultPlotShadow = 1, a.axisPaddingLeft = 0, a.axisPaddingRight = 0, o.registerFactory(\"axis\", r[\"default\"], [\"canvas\"]), o.registerFactory(\"vCanvas\", n[\"default\"], [\"axis\"]), o.registerFactory(\"dataset\", i[\"default\"], [\"vCanvas\"]), o;\n        }\n\n        return p(t, e), t.getName = function () {\n          return \"MultiAxisLine\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.defaultDatasetType = \"multiaxisline\", t.defaultcrosslinethickness = 1;\n        }, t.prototype.getName = function () {\n          return \"MultiAxisLine\";\n        }, t.prototype._checkInvalidSpecificData = function () {\n          var e = this.getFromEnv(\"dataSource\"),\n              t = e.axis,\n              o = e.categories;\n          if (!t || !o) return !0;\n        }, t.prototype._feedAxesRawData = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s,\n              u,\n              p,\n              v,\n              y,\n              x,\n              w,\n              k,\n              C = this.config,\n              N = this.getFromEnv(\"color-manager\"),\n              S = this.getFromEnv(\"number-formatter\"),\n              E = this.getFromEnv(\"dataSource\"),\n              A = E.chart,\n              D = this.config.is3D,\n              T = D ? c.chartPaletteStr.chart3D : c.chartPaletteStr.chart2D,\n              L = [],\n              _ = {},\n              P = [];\n\n          for (e = {\n            isVertical: !1,\n            isReverse: !1,\n            isOpposit: !1,\n            outCanfontFamily: (0, c.pluck)(A.outcnvbasefont, A.basefont, h),\n            outCanfontSize: (0, c.pluckFontSize)(A.outcnvbasefontsize, A.basefontsize, 10),\n            outCancolor: (0, c.pluck)(A.outcnvbasefontcolor, A.basefontcolor, N.getColor(T.baseFontColor)).replace(/^#? ([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: A.xaxisnamepadding,\n            axisValuePadding: A.labelpadding,\n            axisNameFont: A.xaxisnamefont,\n            axisNameFontSize: A.xaxisnamefontsize,\n            axisNameFontColor: A.xaxisnamefontcolor,\n            axisNameFontBold: A.xaxisnamefontbold,\n            axisNameFontItalic: A.xaxisnamefontitalic,\n            axisNameBgColor: A.xaxisnamebgcolor,\n            axisNameBorderColor: A.xaxisnamebordercolor,\n            axisNameAlpha: A.xaxisnamealpha,\n            axisNameFontAlpha: A.xaxisnamefontalpha,\n            axisNameBgAlpha: A.xaxisnamebgalpha,\n            axisNameBorderAlpha: A.xaxisnameborderalpha,\n            axisNameBorderPadding: A.xaxisnameborderpadding,\n            axisNameBorderRadius: A.xaxisnameborderradius,\n            axisNameBorderThickness: A.xaxisnameborderthickness,\n            axisNameBorderDashed: A.xaxisnameborderdashed,\n            axisNameBorderDashLen: A.xaxisnameborderdashlen,\n            axisNameBorderDashGap: A.xaxisnameborderdashgap,\n            useEllipsesWhenOverflow: A.useellipseswhenoverflow,\n            divLineColor: (0, c.pluck)(A.vdivlinecolor, A.divlinecolor, N.getColor(T.divLineColor)),\n            divLineAlpha: (0, c.pluck)(A.vdivlinealpha, A.divlinealpha, D ? N.getColor(b) : N.getColor(d)),\n            divLineThickness: (0, c.pluckNumber)(A.vdivlinethickness, A.divlinethickness, 1),\n            divLineIsDashed: Boolean((0, c.pluckNumber)(A.vdivlinedashed, A.vdivlineisdashed, A.divlinedashed, A.divlineisdashed, 0)),\n            divLineDashLen: (0, c.pluckNumber)(A.vdivlinedashlen, A.divlinedashlen, 4),\n            divLineDashGap: (0, c.pluckNumber)(A.vdivlinedashgap, A.divlinedashgap, 2),\n            showAlternateGridColor: (0, c.pluckNumber)(A.showalternatevgridcolor, 0),\n            alternateGridColor: (0, c.pluck)(A.alternatevgridcolor, N.getColor(g)),\n            alternateGridAlpha: (0, c.pluck)(A.alternatevgridalpha, N.getColor(f)),\n            numDivLines: A.numvdivlines,\n            labelFont: A.labelfont,\n            labelFontSize: A.labelfontsize,\n            labelFontColor: A.labelfontcolor,\n            labelFontBold: A.labelfontbold,\n            labelFontItalic: A.labelfontitalic,\n            labelFontAlpha: A.labelalpha,\n            maxLabelHeight: A.maxlabelheight,\n            axisName: A.xaxisname,\n            axisMinValue: A.xaxisminvalue,\n            axisMaxValue: A.xaxismaxvalue,\n            setAdaptiveMin: A.setadaptivexmin,\n            adjustDiv: A.adjustvdiv,\n            labelDisplay: A.labeldisplay,\n            showLabels: A.showlabels,\n            rotateLabels: A.rotatelabels,\n            slantLabel: (0, c.pluckNumber)(A.slantlabels, A.slantlabel),\n            labelStep: (0, c.pluckNumber)(A.labelstep, A.xaxisvaluesstep),\n            showAxisValues: (0, c.pluckNumber)(A.showxaxisvalues, A.showxaxisvalue),\n            showLimits: A.showvlimits,\n            showDivLineValues: (0, c.pluckNumber)(A.showvdivlinevalues, A.showvdivlinevalues),\n            showZeroPlane: A.showvzeroplane,\n            zeroPlaneColor: A.vzeroplanecolor,\n            zeroPlaneThickness: A.vzeroplanethickness,\n            zeroPlaneAlpha: A.vzeroplanealpha,\n            showZeroPlaneValue: A.showvzeroplanevalue,\n            trendlineColor: A.trendlinecolor,\n            trendlineToolText: A.trendlinetooltext,\n            trendlineThickness: A.trendlinethickness,\n            trendlineAlpha: A.trendlinealpha,\n            showTrendlinesOnTop: A.showtrendlinesontop,\n            showAxisLine: (0, c.pluckNumber)(A.showxaxisline, A.showaxislines, A.drawAxisLines, 0),\n            axisLineThickness: (0, c.pluckNumber)(A.xaxislinethickness, A.axislinethickness, 1),\n            axisLineAlpha: (0, c.pluckNumber)(A.xaxislinealpha, A.axislinealpha, 100),\n            axisLineColor: (0, c.pluck)(A.xaxislinecolor, A.axislinecolor, m)\n          }, P.push(e), t = {\n            outCanfontFamily: (0, c.pluck)(A.outcnvbasefont, A.basefont, h),\n            outCanfontSize: (0, c.pluckFontSize)(A.outcnvbasefontsize, A.basefontsize, 10),\n            outCancolor: (0, c.pluck)(A.outcnvbasefontcolor, A.basefontcolor, N.getColor(T.baseFontColor)).replace(/^#? ([a-f0-9]+)/gi, \"#$1\"),\n            useEllipsesWhenOverflow: A.useellipseswhenoverflow,\n            showAlternateGridColor: 0,\n            axisNameFont: A.yaxisnamefont,\n            axisNameFontSize: A.yaxisnamefontsize,\n            axisNameFontColor: A.yaxisnamefontcolor,\n            axisNameFontBold: A.yaxisnamefontbold,\n            axisNameFontItalic: A.yaxisnamefontitalic,\n            axisNameBgColor: A.yaxisnamebgcolor,\n            axisNameBorderColor: A.yaxisnamebordercolor,\n            axisNameAlpha: A.yaxisnamealpha,\n            axisNameFontAlpha: A.yaxisnamefontalpha,\n            axisNameBgAlpha: A.yaxisnamebgalpha,\n            axisNameBorderAlpha: A.yaxisnameborderalpha,\n            axisNameBorderPadding: A.yaxisnameborderpadding,\n            axisNameBorderRadius: A.yaxisnameborderradius,\n            axisNameBorderThickness: A.yaxisnameborderthickness,\n            axisNameBorderDashed: A.yaxisnameborderdashed,\n            axisNameBorderDashLen: A.yaxisnameborderdashlen,\n            axisNameBorderDashGap: A.yaxisnameborderdashgap\n          }, s = {\n            side: \"l\",\n            axesConf: []\n          }, u = {\n            side: \"r\",\n            axesConf: []\n          }, a = 0, r = (o = E.axis || []).length; a < r; a++) {\n            for (_ = {}, i = o[a], _.checkBoxChecked = !1, w = 0, k = i.dataset ? i.dataset.length : 0; w < k; w += 1) {\n              0 !== Number(i.dataset[w].visible) && (_.checkBoxChecked = !0);\n            }\n\n            l = N.getPlotColor(a), p = (0, c.pluck)(i.color, A.axiscolor, l), v = (0, c.pluckNumber)(i.divlinethickness, A.divlinethickness, 1), y = (0, c.pluckNumber)(i.tickwidth, A.axistickwidth, 2), x = (0, c.pluckNumber)(i.axislinethickness, A.axislinethickness, 2), n = !(0, c.pluckNumber)(i.axisonleft, 1), t.isVertical = !0, t.isReverse = !0, t.isOpposit = n, t.labelStep = (0, c.pluckNumber)(i.yaxisvaluesstep, i.yaxisvaluestep, A.yaxisvaluesstep, A.yaxisvaluestep), t.axisMaxValue = i.maxvalue, t.axisMinValue = i.minvalue, t.setAdaptiveMin = (0, c.pluckNumber)(i.setadaptiveymin, A.setadaptiveymin), t.numDivLines = (0, c.pluckNumber)(i.numdivlines, A.numdivlines, 4), t.adjustDiv = (0, c.pluckNumber)(i.adjustdiv, A.adjustdiv), t.showAxisValues = (0, c.pluckNumber)(i.showyaxisvalues, i.showyaxisvalue, A.showyaxisvalues, A.showyaxisvalue, 1), t.showLimits = (0, c.pluckNumber)(i.showlimits, A.showyaxislimits, A.showlimits, t.showAxisValues), t.showDivLineValues = (0, c.pluckNumber)(i.showdivlinevalue, A.showdivlinevalues, i.showdivlinevalues, t.showAxisValues), t.showZeroPlane = (0, c.pluckNumber)(i.showzeroplane, A.showzeroplane), t.showZeroPlaneValue = (0, c.pluckNumber)(i.showzeroplanevalue, A.showzeroplanevalue), t.zeroPlaneColor = i.zeroplanecolor, t.zeroPlaneThickness = (0, c.pluckNumber)(i.zeroplanethickness, i.divlinethickness, C.zeroplanethickness, 2), t.zeroPlaneAlpha = (0, c.pluckNumber)(i.zeroplanealpha, i.divlinealpha, C.zeroplanealpha), t.showZeroPlaneOnTop = C.showzeroplaneontop, t.divLineColor = (0, c.pluck)(i.divlinecolor, p), t.divLineAlpha = (0, c.pluckNumber)(i.divlinealpha, A.divlinealpha, N.getColor(d), 100), t.divLineThickness = v, t.divLineIsDashed = Boolean((0, c.pluckNumber)(i.divlinedashed, i.divlineisdashed, A.divlinedashed, A.divlineisdashed, 0)), t.divLineDashLen = (0, c.pluckNumber)(i.divlinedashlen, A.divlinedashlen, 4), t.divLineDashGap = (0, c.pluckNumber)(i.divlinedashgap, A.divlinedashgap, 2), t.showAxisLine = 1, t.axisLineThickness = x, t.axisLineAlpha = 100, t.axisLineColor = p, t.tickLength = y, t.tickColor = p, t.tickAlpha = 100, t.tickWidth = x, t.axisName = i.title, t.rotateAxisName = 1, t.axisNameAlignCanvas = !0, t.drawAxisNameFromBottom = !0, (0, c.extend2)(_, t), S.parseMLAxisConf(i, a), 0 === (0, c.pluckNumber)(i.showaxis) ? (0, c.extend2)(_, {\n              axisIndex: a,\n              drawAxisLineWRTCanvas: !1,\n              drawLabels: !1,\n              drawPlotlines: !1,\n              drawAxisLine: !1,\n              drawPlotBands: !1,\n              drawAxisName: !1,\n              drawTrendLines: !1,\n              drawTrendLabels: !1,\n              drawTick: !1,\n              drawTickMinor: !1,\n              showAxis: 0\n            }) : (0, c.extend2)(_, {\n              axisIndex: a,\n              drawAxisLineWRTCanvas: !1,\n              drawLabels: !0,\n              drawPlotlines: !0,\n              drawAxisLine: !0,\n              drawPlotBands: !0,\n              drawAxisName: !0,\n              drawTrendLines: !0,\n              drawTrendLabels: !0,\n              drawTick: !0,\n              drawTickMinor: !0,\n              showAxis: 1\n            }), n ? u.axesConf.push(_) : s.axesConf.push(_);\n          }\n\n          return s.axesConf.length && L.push(s), u.axesConf.length && L.push(u), {\n            xAxisConfigure: P,\n            yAxisConfigure: L\n          };\n        }, t.prototype._postSpaceManagement = function () {\n          var e = this.getFromEnv(\"legend\"),\n              t = this.config.showLegend,\n              o = this.getChildren(\"yAxisSelectorUI\"),\n              a = this.getChildren(\"canvas\")[0];\n          this.setAxisDimention(), o.forEach(function (e) {\n            e.setAxisDimention();\n          }), a.setCanvasPadding(), this.setAxisDimention(), t && e.postSpaceManager();\n        }, t.prototype.setAxisDimention = function () {\n          var e = this.config,\n              t = this.getChildren(\"xAxis\")[0],\n              o = e.xDepth,\n              a = this.getChildren(\"canvas\")[0].config,\n              r = a.canvasBorderWidth,\n              n = a.canvasPadding,\n              i = a.canvasPaddingLeft,\n              l = a.canvasPaddingRight;\n          t && t.setAxisDimention({\n            x: e.canvasLeft + (o || 0) + Math.max(i, n),\n            y: e.canvasBottom + (e.shift || 0) + r,\n            opposite: e.canvasTop - r,\n            axisLength: e.canvasWidth - (o || 0) - Math.max(i, n) - Math.max(l, n)\n          });\n        }, t.prototype._spaceManager = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s,\n              u,\n              p = this.getChildren(\"canvas\")[0],\n              h = this.config,\n              d = h.showLegend,\n              g = h.legendPosition,\n              f = this.getChildren(\"xAxis\"),\n              m = this.getChildren(\"yAxisSelectorUI\"),\n              b = h.hasLegend,\n              y = h.yDepth,\n              x = this.getFromEnv(\"legend\"),\n              w = 0,\n              k = 0,\n              C = m.length || 0,\n              N = this.config.is3D,\n              S = this.getFromEnv(\"dataSource\").chart,\n              E = (0, c.pluckNumber)(S.showborder, N ? 0 : 1),\n              A = this.getChildren(\"canvas\")[0].config.canvasBorderWidth,\n              D = h.borderWidth = E ? (0, c.pluckNumber)(S.borderthickness, 1) : 0,\n              T = h.canvasMarginTop,\n              L = h.canvasMarginBottom,\n              _ = h.canvasMarginLeft,\n              P = h.canvasMarginRight,\n              O = (h.minCanvasHeight, h.minCanvasWidth, h.height),\n              V = h.width;\n          h.origCanvasTopMargin, h.origCanvasBottomMargin, h.origCanvasLeftMargin, h.origCanvasRightMargin;\n\n          for (this._allocateSpace({\n            top: D,\n            bottom: D,\n            left: D,\n            right: D\n          }), this._allocateSpace({\n            left: h.canvasMarginLeft,\n            right: h.canvasMarginRight\n          }), n = \"right\" === g ? .3 * h.canvasWidth : .3 * h.canvasHeight, !1 !== b && f && d && this._allocateSpace(x._manageLegendPosition(n)), a = 0; a < C; a++) {\n            w += (r = m[a].placeAxis(h.canvasWidth)).rightPadding, k += r.leftPadding, this._allocateSpace(r.dimension);\n          }\n\n          e = .225 * h.availableHeight, t = this._manageActionBarSpace && this._manageActionBarSpace(e) || {}, this._allocateSpace(t), o = g === v ? .6 * h.canvasHeight : .6 * h.canvasWidth, this._manageChartMenuBar(o), .7 * h.canvasWidth > w + k && this._allocateSpace({\n            left: k,\n            right: w\n          }), o = .6 * h.canvasHeight, f[0] && this._allocateSpace(f[0].placeAxis(o)), o = .325 * h.canvasHeight, this._getDSspace && this._allocateSpace(this._getDSspace(o)), y && this._allocateSpace({\n            bottom: y\n          }), this._allocateSpace({\n            top: A,\n            bottom: A,\n            left: A,\n            right: A\n          }), i = T > h.canvasTop ? T - h.canvasTop : 0, l = L > O - h.canvasBottom ? L + h.canvasBottom - O : 0, s = _ > h.canvasLeft ? _ - h.canvasLeft : 0, u = P > V - h.canvasRight ? P + h.canvasRight - V : 0, this._allocateSpace({\n            top: i,\n            bottom: l,\n            left: s,\n            right: u\n          }), h.actualCanvasMarginTop = i, h.actualCanvasMarginLeft = s, h.actualCanvasMarginRight = u, h.actualCanvasMarginBottom = l, p.setDimension({\n            top: h.canvasTop,\n            left: h.canvasLeft,\n            width: h.canvasWidth,\n            height: h.canvasHeight\n          });\n        }, t.prototype.configure = function (t) {\n          e.prototype.configure.call(this, t);\n          var o = this.config,\n              a = this.getFromEnv(\"dataSource\").chart;\n          o.axesPadding = 5, o.allowAxisShift = (0, c.pluckNumber)(a.allowaxisshift, 1), o.allowSelection = (0, c.pluckNumber)(a.allowselection, 1), o.checkBoxColor = (0, c.pluck)(a.checkboxcolor, \"#2196f3\"), o.axisConfigured = !0;\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = x;\n    },\n    512: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o = e.getChildren(\"canvas\")[0],\n            i = o.getChildren(\"axisRefVisualCartesian\")[0],\n            l = void 0;\n        t = e._feedAxesRawData(), n[\"default\"].resetAxisCount(), (0, a.componentFactory)(e, n[\"default\"], \"yAxisSelectorUI\", t.yAxisConfigure && t.yAxisConfigure.length, t.yAxisConfigure), (0, a.componentFactory)(e, r[\"default\"], \"xAxis\", 1, t.xAxisConfigure), (l = e.getChildren(\"xAxis\")[0]).setLinkedItem(\"canvas\", o), i.setLinkedItem(l.getId(), l), i.addExtEventListener(\"visiblerangeset\", function () {\n          return i.asyncDraw();\n        }, l), o.attachAxis(l, !1), o.setPrimaryAxis(\"xAxis\", l), e._setCategories();\n      };\n      var a = o(118),\n          r = i(o(321)),\n          n = i(o(513));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n    },\n    513: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(131)),\n          r = o(118),\n          n = l(o(292)),\n          i = l(o(514));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c = function c(e) {\n        var t = e.config.axesConf,\n            o = void 0,\n            a = void 0,\n            l = void 0,\n            s = e.config.axisMapById,\n            c = s && Array.from(s.keys()) || [],\n            p = void 0,\n            h = !0,\n            d = e.getFromEnv(\"chart\").getChildren(\"canvas\")[0],\n            g = d.getChildren(\"axisRefVisualCartesian\")[0],\n            f = function f() {\n          return g.asyncDraw();\n        };\n\n        (0, r.componentFactory)(e, n[\"default\"], \"yAxis\", t.length, t), o = (e.getChildren(\"yAxis\") || []).slice(0), a = e.config.axisMapById = new i[\"default\"](), (\"l\" === e.config.side ? o.reverse() : o).forEach(function (t) {\n          if (!t.getState(\"removed\") && 0 !== t.config.showaxis) {\n            var o,\n                r,\n                n = t.getId();\n            (p = {}).axis = t, a.set(n, p), 0 === t.config.showaxis ? t.hide() : t.show(), d.attachAxis(t, !0), h && (e.config.besideCanvas = n), h = !1, u || (l = t), t.setLinkedItem(\"canvas\", d), g.setLinkedItem(t.getId(), t), g.addExtEventListener(\"visiblerangeset\", f, t), u++, o = n, -1 !== (r = c.indexOf(o)) && c.splice(r, 1);\n          }\n        }), l && d.setPrimaryAxis(\"yAxis\", l), function (e, t) {\n          var o = void 0,\n              a = void 0,\n              r = void 0;\n\n          for (r = e.length - 1; r > -1; r--) {\n            o = e[r], (a = t.get(o)).checkbox && a.checkbox.hide(), a.axis && a.axis.hide(), t[\"delete\"](o);\n          }\n        }(c, s);\n      },\n          u = 0,\n          p = 0,\n          h = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.registerFactory(\"axis\", c), o;\n        }\n\n        return s(t, e), t.resetAxisCount = function () {\n          u = 0;\n        }, t.prototype.configureAttributes = function () {\n          var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n              t = this.config;\n          t.axesConf = e.axesConf || [], t.checkboxesConf = e.checkboxesConf || [], t.side = e.side;\n        }, t.prototype.placeAxis = function (e) {\n          var t = this.config.side,\n              o = this.getAxesDetails(),\n              a = this.getFromEnv(\"chartConfig\").axesPadding,\n              r = 0,\n              n = 0,\n              i = void 0,\n              l = {\n            right: 0,\n            left: 0\n          };\n          return o.forEach(function (o) {\n            var s = o.value || (o.value = {}),\n                c = o.axis;\n            c.getState(\"removed\") || 0 === c.config.showaxis || (i = c.placeAxis(.7 * e), \"r\" === t ? (e -= s.width = i.right, l.right += i.right, r += a) : (e -= s.width = i.left, l.left += i.left, n += a));\n          }), {\n            dimension: l,\n            rightPadding: r,\n            leftPadding: n\n          };\n        }, t.prototype.setAxisDimention = function () {\n          var e = this.config,\n              t = this.getAxesDetails(),\n              o = this.getFromEnv(\"chart\"),\n              a = this.getFromEnv(\"chartConfig\").axesPadding,\n              r = o.getChildren(\"canvas\")[0].config,\n              n = r.canvasBorderWidth,\n              i = r.canvasPaddingTop,\n              l = r.canvasPaddingBottom,\n              s = r.canvasLeft,\n              c = r.canvasTop,\n              u = r.canvasHeight,\n              p = s + r.canvasWidth,\n              h = \"r\" === e.side,\n              d = \"r\" === e.side ? s - n : p + n,\n              g = 0;\n          t.forEach(function (e) {\n            var t = e.value || (e.value = {}),\n                o = e.axis;\n            0 === o.config.showaxis || o.getState(\"removed\") || (t.x = h ? p + n + g + a : s - n - g - a, t.y = c + i, t.height = u - i - l, t.opposite = d, g += t.width + a, o.setAxisDimention({\n              x: t.x,\n              y: t.y,\n              opposite: t.opposite,\n              axisLength: t.height\n            }));\n          });\n        }, t.prototype.drawHotElements = function () {\n          var e,\n              t = this,\n              o = t.config,\n              a = \"r\" === o.side,\n              n = t.getFromEnv(\"chartConfig\").allowAxisShift,\n              i = t.getFromEnv(\"chart\"),\n              l = t.getFromEnv(\"paper\"),\n              s = i.getChildContainer(\"trackerGroup\"),\n              c = o.axisMapById,\n              u = t.getGraphicalElement(\"axisHotElement\") || [],\n              p = i.getChildren(\"canvas\")[0],\n              h = void 0,\n              d = -1,\n              g = {\n            cursor: \"col-resize\",\n            stroke: r.TRACKER_FILL,\n            fill: r.TRACKER_FILL,\n            visibility: !0\n          };\n\n          for (n && c.forEach(function (e, o) {\n            var n = void 0,\n                i = e.value;\n            g.x = i.x + (a ? 0 : -i.width), g.y = i.y, g.width = i.width, g.height = i.height, (n = u[++d]) || (n = t.addGraphicalElement(\"axisHotElement\", l.rect(s), !0), r.hasTouch ? n.touchstart(t._resuffelAxis) : n.mousedown(t._resuffelAxis)), n.attr(g).data(\"axisDetails\", {\n              axisSelectorUI: t,\n              canvas: p,\n              axisId: o\n            });\n          }), h = d + 1, e = u.length; h < e; h++) {\n            t.removeGraphicalElement(u[h]);\n          }\n        }, t.prototype.drawCheckBoxes = function () {\n          var e = this,\n              t = e.config,\n              o = e.getFromEnv(\"chartInstance\").id,\n              a = e.getFromEnv(\"chartConfig\"),\n              n = a.allowSelection,\n              i = e.getFromEnv(\"chart\"),\n              l = i.getChildContainer(\"buttonGroup\"),\n              s = e.getFromEnv(\"toolBoxAPI\"),\n              c = e.getFromEnv(\"toolbox\"),\n              u = s.CheckboxSymbol,\n              h = \"r\" === t.side,\n              d = t.axisMapById;\n          n && d.forEach(function (t, n) {\n            var s = t.value,\n                d = t.checkbox,\n                g = t.axis.config,\n                f = \"updating\",\n                m = h ? t.axis.getAxisConfig(\"axisNamePadding\") : -s.width;\n            d || ((d = t.checkbox = new u()).configure(\"\", !0, p++, c.pId, o), d.config.conf = c.getDefaultConfiguration(), d.attachEventHandlers({\n              click: {\n                fn: function fn(t, o) {\n                  e._dolegendInteraction.call(this, t, o), g.checkBoxChecked = !g.checkBoxChecked;\n                },\n                args: [n, i]\n              }\n            }), f = \"appearing\"), d.draw(s.x + m, s.y + s.height + 4, {\n              parentLayer: l\n            }), e.getFromEnv(\"animationManager\").setAnimation({\n              el: d.config.node,\n              attr: {\n                stroke: (0, r.toRaphaelColor)({\n                  color: a.checkBoxColor,\n                  alpha: 100,\n                  \"stroke-width\": [1, 2]\n                })\n              },\n              state: f,\n              component: e\n            }), g.checkBoxChecked ? d.check() : d.uncheck();\n          });\n        }, t.prototype._createLayers = function () {\n          var e = this.getFromEnv(\"chart\").getContainer(\"parentgroup\");\n          this.createContainer(\"axisBottomGroup\", {\n            name: \"axis-bottom-group\"\n          }, e), this.createContainer(\"axisTopGroup\", {\n            name: \"axis-top-group\"\n          }, e);\n        }, t.prototype.createContainer = function (e, t, o) {\n          var a = this.getFromEnv(\"animationManager\");\n          return this.addChildContainer(e, a.setAnimation({\n            container: o,\n            attr: t,\n            el: this.getChildContainer(e) || \"group\",\n            component: this,\n            label: \"group\"\n          }));\n        }, t.prototype.draw = function () {\n          this._createLayers(), this.drawHotElements(), this.drawCheckBoxes();\n        }, t.prototype._resuffelAxis = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              l = this.data(\"axisDetails\"),\n              s = l.axisSelectorUI,\n              c = s.config,\n              u = l.canvas,\n              p = l.axisId,\n              h = s.getAxesDetails();\n          c.besideCanvas !== p && (h = s.config.axisMapById = (e = c.besideCanvas, t = p, a = [e, (o = h).get(e)], r = [t, o.get(t)], n = Array.from(o.entries()).map(function (o) {\n            var n = o[0],\n                i = o[1];\n            return n === e ? r : n === t ? a : [n, i];\n          }), new i[\"default\"](n))), c.besideCanvas = p, u.setPrimaryAxis(\"yAxis\", h.get(p).axis), s.setAxisDimention(), s.asyncDraw(), u.getChildren(\"axisRefVisualCartesian\")[0].asyncDraw();\n        }, t.prototype._dolegendInteraction = function (e, t) {\n          var o,\n              a,\n              r = [];\n\n          for (o in t.iterateComponents(function (e) {\n            \"dataset\" === e.getType() && r.push(e);\n          }), r) {\n            r.hasOwnProperty(o) && (a = r[o]).getFromEnv(\"yAxis\").getId() === e && (!a.getState(\"visible\") && this.config.checked ? (a.config.legendInteractivity = !0, a.show()) : a.getState(\"visible\") && !this.config.checked && (a.config.legendInteractivity = !0, a.hide()));\n          }\n        }, t.prototype.manipulateCheckBox = function (e) {\n          var t,\n              o,\n              a,\n              r = e.data,\n              n = r.dataset,\n              i = n.getFromEnv(\"yAxis\").getId(),\n              l = n.getLinkedParent().getChildren().dataset,\n              s = r.state,\n              c = !0;\n          if (a = this.getAxesDetails().get(i)) if (\"hide\" === s) {\n            for (t = 0, o = l.length; t < o; t++) {\n              l[t].getState(\"visible\") && (c = !1);\n            }\n\n            c && a.checkbox && a.checkbox.uncheck();\n          } else a.checkbox && a.checkbox.check();\n        }, t.prototype.getAxesDetails = function () {\n          return this.config.axisMapById;\n        }, t.prototype.getType = function () {\n          return \"customAxisUI\";\n        }, t.prototype.getName = function () {\n          return \"multiAxisSelectorUI\";\n        }, t.prototype.getAxes = function () {\n          return Array.from(this.config.axisMapById.values()).map(function (e) {\n            return e.axis;\n          });\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = h;\n    },\n    537: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o = e.getChildren(\"canvas\")[0],\n            a = e.getFromEnv(\"dataSource\"),\n            r = e.getChildren(\"yAxisSelectorUI\"),\n            l = a.axis,\n            s = void 0,\n            c = [],\n            u = [],\n            p = void 0,\n            h = void 0,\n            d = void 0,\n            g = void 0;\n\n        for (s = e.getChildren(\"xAxis\"), d = 0; d < (s && s.length); d++) {\n          s[d].getState(\"removed\") || c.push(s[d]);\n        }\n\n        for (r.forEach(function (e) {\n          for (s = e.getChildren(\"yAxis\"), d = 0; d < (s && s.length); d++) {\n            s[d].getState(\"removed\") || u.push(s[d]);\n          }\n        }), (0, i.componentFactory)(o, n[\"default\"], \"vCanvas\", c.length * u.length), t = o.getChildren(\"vCanvas\"), h = 0, d = 0; h < (c && c.length); h++) {\n          for (g = 0; g < (u && u.length); g++, d++) {\n            (p = t[d]).configure(), p.xAxis(c[h]).yAxis(u[g]).canvas(o), p.addToEnv(\"axisData\", l[d]), p.addToEnv(\"vCanvas\", t[d]);\n          }\n        }\n      };\n      var a,\n          r = o(327),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      },\n          i = o(118);\n    },\n    538: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        for (var t = void 0, o = void 0, a = void 0, n = void 0, l = e.getChildren(), s = l.yAxisSelectorUI, c = l.canvas[0].getChildren(\"vCanvas\"), u = 0, p = c.length; u < p; u++) {\n          (n = c[u]).getState(\"removed\") || (t = n.getFromEnv(\"axisData\").dataset) && (o = t.length, a = Array(o).fill(n.getFromEnv(\"yAxis\").config.axisIndex).map(function (e, t) {\n            return e + Number(\".\" + (t + 1));\n          }), (0, r.datasetFactory)(n, i[\"default\"], \"dataset\", o, t, a), (l = n.getChildren(\"dataset\")).forEach(function (e) {\n            e.addEventListener(\"datasetVisibilityChanged\", function (e) {\n              s.forEach(function (t) {\n                t.manipulateCheckBox(e);\n              });\n            });\n          }));\n        }\n      };\n      var a,\n          r = o(118),\n          n = o(539),\n          i = (a = n) && a.__esModule ? a : {\n        \"default\": a\n      };\n    },\n    539: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(346)),\n          r = o(118),\n          n = o(125),\n          i = l(o(540));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      (0, n.addDep)({\n        name: \"multiAxislineAnimation\",\n        type: \"animationRule\",\n        extension: i[\"default\"]\n      });\n\n      var c = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return s(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"multiaxisline\";\n        }, t.prototype.configure = function (t) {\n          if (!t) return !1;\n          this.trimData(t), this.config.JSONData = t;\n          var o,\n              a,\n              n = this.config.JSONData,\n              i = this.config,\n              l = this.getFromEnv(\"chart-attrib\"),\n              s = this.getFromEnv(\"axisData\");\n          e.prototype.configure.call(this, t), i.linethickness = (0, r.pluckNumber)(n.linethickness, s.linethickness, l.linethickness, 2), i.lineDashLen = (0, r.pluckNumber)(n.linedashlen, s.linedashlen, l.linedashlen, 5), i.lineDashGap = (0, r.pluckNumber)(n.linedashgap, s.linedashgap, l.linedashgap, 4), i.alpha = (0, r.pluckNumber)(n.alpha, s.linealpha, l.linealpha, r.HUNDREDSTRING), i.linecolor = (0, r.pluck)(n.color, s.linecolor, s.color, l.linecolor, i.plotColor), i.legendSymbolColor = \"line\" === this.getName() ? i.lineColor : i.plotFillColor, a = (0, r.pluckNumber)(n.dashed, s.linedashed, l.linedashed), o = (0, r.getDashStyle)(i.lineDashLen, i.lineDashGap), i.anchorBorderColor = (0, r.pluck)(n.anchorbordercolor, l.anchorbordercolor, i.lineColor, i.plotColor), i.lineDashStyle = a ? o : \"none\", e.prototype._setConfigure.call(this);\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = c;\n    },\n    540: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"*.dataset.multiaxisline\": n[\"default\"][\"*.dataset.line\"]\n      };\n    },\n    541: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = i(o(354)),\n          r = o(428),\n          n = i(o(542));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.defaultPlotShadow = 1, o;\n        }\n\n        return l(t, e), t.getName = function () {\n          return \"MSStepLine\";\n        }, t.prototype.getName = function () {\n          return \"MSStepLine\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.friendlyName = \"Multi-series Step Line Chart\", t.defaultDatasetType = \"msstepline\", t.drawverticaljoins = 1, t.useforwardsteps = 1, t.zeroplanethickness = 1, t.zeroplanealpha = 40, t.showzeroplaneontop = 0, t.enablemousetracking = !0, t.defaultcrosslinethickness = 1, r._setDefaultConfig.call(this);\n        }, t.prototype.getDSGroupdef = function () {}, t.prototype.getDSdef = function () {\n          return n[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    542: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = o(118),\n          r = l(o(346)),\n          n = o(125),\n          i = l(o(543));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      (0, n.addDep)({\n        name: \"stepLineAnimation\",\n        type: \"animationRule\",\n        extension: i[\"default\"]\n      });\n\n      var c = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return s(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"stepLine\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.drawverticaljoins = void 0, t.useforwardsteps = void 0;\n        }, t.prototype._addLegend = function () {\n          var e,\n              t = this.config,\n              o = this.getFromEnv(\"legend\"),\n              r = (0, a.pluckNumber)(t.drawanchors, 1),\n              n = {\n            enabled: t.includeinlegend,\n            type: \"line\",\n            drawLine: (0, a.pluck)(t.drawLine, !0),\n            anchorSide: r ? t.anchorsides : 0,\n            label: (0, a.getFirstValue)(this.config.JSONData.seriesname)\n          };\n          t.includeinlegend ? ((e = o.getItem(this.config.legendItemId)) || (this.config.legendItemId = o.createItem(this), e = o.getItem(this.config.legendItemId), this.addExtEventListener(\"click\", function () {\n            e.itemClickFn();\n          }, e)), e.configure(n), e.setStateCosmetics(\"default\", {\n            symbol: {\n              fill: (0, a.toRaphaelColor)({\n                color: t.anchorbgcolor,\n                alpha: t.anchorbgalpha\n              }),\n              rawFillColor: t.anchorbgcolor,\n              rawStrokeColor: t.anchorbordercolor,\n              stroke: (0, a.toRaphaelColor)({\n                color: t.anchorbordercolor,\n                alpha: \"100\"\n              }),\n              \"stroke-width\": t.anchorborderthickness\n            }\n          }), this.getState(\"visible\") ? e.removeLegendState(\"hidden\") : e.setLegendState(\"hidden\")) : this.config.legendItemId && o.disposeItem(this.config.legendItemId);\n        }, t.prototype.getLinePath = function (e, t) {\n          var o,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u = this.config,\n              p = this.getFromEnv(\"chartConfig\"),\n              h = (0, a.pluckNumber)(p.connectnulldata),\n              d = {},\n              g = this.getFromEnv(\"xAxis\"),\n              f = (0, a.pluckNumber)(u.drawverticaljoins),\n              m = (0, a.pluckNumber)(u.useforwardsteps),\n              v = (0, a.pluckNumber)(p.stepatmiddle) ? .5 * g.getPVR() : 0,\n              b = d.lastValidValue || !1,\n              y = d.temp || [],\n              x = d.temp2 || [],\n              w = d.pathArr || [],\n              k = d.path2Arr || [],\n              C = e.length,\n              N = d.pointsJoined || 0,\n              S = t && t.begin || 0,\n              E = t && t.end || C,\n              A = p.viewPortConfig.step || 1,\n              D = [];\n\n          for (D = D.concat(e), r = S; r < E; r += A) {\n            (s = D[r]) && (void 0 === (c = (n = s.config).setValue) || n && !0 === n.isSkipped ? n && delete n.isSkipped : (i = n._Px, l = n._Py, null === c || c.isNull ? h || (y = [], x = [], b = !1) : b ? (y.length && (w = w.concat(y), y = [], N++), m ? (w.push([\"H\", i - v]), f ? w.push([\"V\", l]) : w.push([\"M\", i - v, l]), v && w.push([\"H\", i])) : (f ? w.push([\"V\", l]) : w.push([\"M\", o, l]), w.push([\"H\", i]), o = i)) : (y.push([\"M\", i, l]), o = i, N = 0, b = !0)));\n          }\n\n          return {\n            pathArr: w,\n            path2Arr: k,\n            lastValidValue: b,\n            pointsJoined: N,\n            temp: y,\n            temp2: x,\n            getPathArr: function getPathArr() {\n              var e = this.pathArr,\n                  t = this.path2Arr;\n              return e.length || t.length ? e.concat(t) : [];\n            }\n          };\n        }, t;\n      }(r[\"default\"]);\n\n      t[\"default\"] = c;\n    },\n    543: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"*.dataset.stepLine\": n[\"default\"][\"*.dataset.line\"]\n      };\n    },\n    544: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t.configurer = undefined;\n      var a = g(o(484)),\n          r = g(o(545)),\n          n = g(o(547)),\n          i = g(o(549)),\n          l = g(o(551)),\n          s = o(118),\n          c = o(125),\n          u = g(o(552)),\n          p = o(486),\n          h = g(o(417)),\n          d = o(151);\n\n      function g(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function f(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var m,\n          v = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this)),\n              a = o;\n\n          return a.fireGroupEvent = !0, a.usesXYinCategory = !0, a.dontShowLegendByDefault = !0, o.registerFactory(\"dataset\", u[\"default\"], [\"vCanvas\"]), o.registerFactory(\"axis\", h[\"default\"], [\"canvas\"]), o;\n        }\n\n        return f(t, e), t.getName = function () {\n          return \"DragNode\";\n        }, t.prototype.getName = function () {\n          return \"DragNode\";\n        }, t.prototype._checkInvalidSpecificData = function () {\n          if (!this.getFromEnv(\"dataSource\").dataset) return !0;\n        }, t.prototype._mouseEvtHandler = function (e, t) {\n          (0, d._mouseEvtHandler)(this, e, t);\n        }, t.prototype.parseChartAttr = function (t) {\n          var o,\n              a = this.getFromEnv(\"dataSource\").chart,\n              r = (0, c.getDepsByType)(\"transcoder\");\n          e.prototype.parseChartAttr.call(this, t), (o = this.config).formAction = (0, s.getValidValue)(a.formaction), o.showLegend = (0, s.pluckNumber)(a.showlegend, 0), a.submitdataasxml !== s.ZEROSTRING || a.formdataformat || (a.formdataformat = r.csv().format), o.formDataFormat = (0, s.pluck)(a.formdataformat, r.xml().format), o.formTarget = (0, s.pluck)(a.formtarget, \"_self\"), o.formMethod = (0, s.pluck)(a.formmethod, \"POST\"), o.submitFormAsAjax = (0, s.pluckNumber)(a.submitformusingajax, 1), o.viewMode = (0, s.pluckNumber)(a.viewmode, 0), o.drawTrendRegion = 0;\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.hasLegend = !0, t.friendlyName = \"Dragable Node Chart\", t.defaultDatasetType = \"dragnode\", t.limitUpdaterEnabled = !1, t.skipClipping = !0, t.numVDivLines = 0, t.numDivLines = 0, t.setadaptivexmin = 1, t.showLimits = 0, t.showdivlinevalues = 0, t.showzeroplane = 0, t.showyaxisvalues = 0, t.enablemousetracking = !0, t.showzeroplaneontop = 0;\n        }, t.prototype.addConfigureOptions = function () {\n          var e,\n              t,\n              o = this,\n              a = o.config,\n              r = a.restoreBtnTitle,\n              n = a.submitBtnTitle,\n              i = o.getFromEnv(\"chartMenuList\"),\n              l = o.config.viewMode,\n              s = [{\n            \"Add Node\": {\n              handler: function handler() {\n                o.getChildren(\"canvas\")[0].getChildren(\"vCanvas\")[0].getChildren(\"datasetGroup_dragNode\")[0].showNodeAddUI();\n              },\n              action: \"click\"\n            }\n          }, {\n            \"Add Connector\": {\n              handler: function handler() {\n                o.getChildren(\"canvas\")[0].getChildren(\"vCanvas\")[0].getChildren(\"datasetGroup_dragNode\")[0].showConnectorAddUI();\n              },\n              action: \"click\"\n            }\n          }, {\n            \"Add Label\": {\n              handler: function handler() {\n                o.getChildren(\"canvas\")[0].getChildren(\"vCanvas\")[0].getChildren(\"datasetGroup_dragNode\")[0].showLabelUpdateUI();\n              },\n              action: \"click\"\n            }\n          }];\n          a.showRestoreBtn && ((e = {})[r] = {\n            handler: function handler() {\n              o.getChildren(\"canvas\")[0].getChildren(\"vCanvas\")[0].getChildren(\"datasetGroup_dragNode\")[0].restoreData();\n            },\n            action: \"click\"\n          }, s.push(e)), a.showFormBtn && ((t = {})[n] = {\n            handler: function handler() {\n              p.submitData.call(o);\n            },\n            action: \"click\"\n          }, s.push(t)), !l && i.appendAsList(s);\n        }, t.prototype.getDSdef = function (e) {\n          switch (e) {\n            case \"connector\":\n              return n[\"default\"];\n\n            case \"dragnode\":\n              return r[\"default\"];\n\n            case \"dragableLabels\":\n              return i[\"default\"];\n          }\n        }, t.prototype.getDSGroupdef = function () {\n          return l[\"default\"];\n        }, t.prototype._setCategories = function () {\n          var e,\n              t,\n              o = this.getFromEnv(\"dataSource\"),\n              a = this.getChildren(\"xAxis\"),\n              r = o.categories && o.categories[0].category || [],\n              n = r.length,\n              i = [];\n\n          for (e = 0; e < n; e++) {\n            (t = r[e] || {}).x !== undefined && i.push(t);\n          }\n\n          a && a[0].setTickValues(i);\n        }, t.prototype.getJSONData = function () {\n          var e,\n              t = this.getChildren(\"canvas\")[0].getChildren(\"vCanvas\")[0].getChildren(\"datasetGroup_dragNode\")[0],\n              o = this.getFromEnv(\"dataSource\"),\n              a = {};\n          return t && (a = t.getJSONData()), (e = (0, s.extend2)({}, o)).dataset = a.dataset, e.connectors = a.connectors, e.labels = a.labels, e;\n        }, t;\n      }(a[\"default\"]);\n\n      t.configurer = m = v.prototype.configure, t[\"default\"] = v, t.configurer = m;\n    },\n    545: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = u(o(347)),\n          r = o(118),\n          n = o(122),\n          i = o(125),\n          l = u(o(546)),\n          s = u(o(211)),\n          c = u(o(419));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = (0, i.getDep)(\"redraphael\", \"plugin\"),\n          d = Math.max,\n          g = Math.min,\n          f = r.preDefStr.CIRCLE,\n          m = r.preDefStr.POLYGON,\n          v = r.preDefStr.RECTANGLE,\n          b = r.preDefStr.UNDERSCORE,\n          y = r.preDefStr.GROUPID,\n          x = r.preDefStr.EVENTARGS,\n          w = r.preDefStr.OBJECTBOUNDINGBOX,\n          k = r.preDefStr.DEFAULT,\n          C = r.preDefStr.COMMA,\n          N = r.preDefStr.POSITION_TOP,\n          S = !!r.hasSVG,\n          E = function E() {\n        this.hide();\n      },\n          A = function A(e) {\n        return e !== undefined && null !== e;\n      },\n          D = function D(e, t, o, a) {\n        return t.setAnimation({\n          el: \"group\",\n          attr: {\n            name: e\n          },\n          container: o,\n          component: a\n        });\n      },\n          T = function T(e, t, o) {\n        var a, i, l;\n        return e = (0, n.getFirstColor)(e), t = (0, n.getFirstAlpha)(t), i = (0, n.getLightColor)(e, 80), l = (0, n.getDarkColor)(e, 65), a = {\n          FCcolor: {\n            gradientUnits: w,\n            color: i + C + l,\n            alpha: t + C + t,\n            ratio: r.BGRATIOSTRING\n          }\n        }, o ? a.FCcolor.angle = 1 === o ? 0 : 180 : (a.FCcolor.cx = .4, a.FCcolor.cy = .4, a.FCcolor.r = \"50%\", a.FCcolor.radialGradient = !0), a;\n      },\n          L = function L(e, t, o) {\n        var a,\n            n = e.setTooltext,\n            i = e.formatedVal,\n            l = t.seriesname,\n            s = e.label,\n            c = e.xValue,\n            u = e.pointLabel,\n            p = t.tooltipSepChar;\n        return n !== undefined ? a = (0, r.parseTooltext)(n, [3, 4, 5, 6, 8, 9, 10, 11], {\n          yaxisName: (0, r.parseUnsafeString)(o.yaxisname),\n          xaxisName: (0, r.parseUnsafeString)(o.xaxisname),\n          yDataValue: i,\n          xDataValue: c,\n          label: s\n        }, e, o, t) : u !== undefined ? a = s : null === i ? a = !1 : (t.seriesNameInToolTip && (l = (0, r.getFirstValue)(t.seriesname)), a = l ? l + p : r.BLANK, a += c ? c + p : r.BLANK, a += i), a;\n      };\n\n      (0, i.addDep)({\n        name: \"dragNodeAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      }), (0, s[\"default\"])(h);\n\n      var _ = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return p(t, e), t.prototype.getName = function () {\n          return \"dragNode\";\n        }, t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.hide = function () {\n          var e = this.getLinkedParent(),\n              t = {\n            hide: !0\n          };\n          this.setState(\"dirty\", !0), this.setState(\"visible\", !1), e.childChanged(t), this.getFromEnv(\"chart\").getChildren(\"legend\")[0].getItem(this.config.legendItemId).setLegendState(\"hidden\"), this.asyncDraw();\n        }, t.prototype.show = function () {\n          var e = this.getLinkedParent(),\n              t = this.getFromEnv(\"legend\").getItem(this.config.legendItemId),\n              o = {\n            show: !0\n          };\n          this.setState(\"visible\", !0), this.setState(\"dirty\", !0), e.childChanged(o), t && t.removeLegendState(\"hidden\"), this.asyncDraw();\n        }, t.prototype._setDatasetIndex = function () {\n          var e = this.getLinkedParent().getChildren(\"dataset\");\n          this.config.datasetIndex = e.indexOf(this);\n        }, t.prototype.pointInShape = function (e, t, o) {\n          var a,\n              r,\n              n,\n              i,\n              l,\n              s = this.getFromEnv(\"chart\").getChildren(\"canvas\")[0].config,\n              c = o.symbol,\n              u = o._xPos,\n              p = o._yPos;\n          return !(e < s.canvasLeft || e > s.canvasLeft + s.canvasWidth || t < s.canvasTop || t > s.canvasTop + s.canvasHeight) && (\"rectangle\" === c ? (i = o._plotWidth, p -= (l = o._plotHeight) / 2, e >= (u -= i / 2) && t >= p && e <= u + i && t <= p + l) : (a = (e - u) * (e - u), r = (t - p) * (t - p), n = Number(o.radius), a + r <= (n *= n)));\n        }, t.prototype._firePlotEvent = function (e, t, o) {\n          var a,\n              n,\n              i,\n              l = this.getFromEnv(\"chart\"),\n              s = this.components,\n              c = this.getFromEnv(\"toolTipController\"),\n              u = s.data[t] || {},\n              p = this.getGraphicalElement(\"sharedAnchor\"),\n              h = u.graphics && u.graphics.element || void 0 !== (u.config && u.config.setValue) && p,\n              d = this.config.currentToolTip,\n              g = this.config.viewMode,\n              f = this.getLinkedParent(),\n              m = u.graphics.element;\n          if (h) switch (i = (a = u.config).setLink, n = a.eventArgs, e) {\n            case \"mouseover\":\n              this._decideTooltipType(t, o), this._rolloverResponseSetter(l, u, o), i && (h.node.style.cursor = r.POINTER);\n              break;\n\n            case \"mouseout\":\n              c.hide(d), this._rolloutResponseSetter(l, u, o), i && (h.node.style.cursor = k);\n              break;\n\n            case \"click\":\n              m.data(\"fire_click_event\") && l.plotEventHandler(h, o, \"dataplotclick\", n);\n              break;\n\n            case \"mousemove\":\n              f.hideWaitElem(), f.clearLongPress(), this._decideTooltipType(t, o);\n              break;\n\n            case \"mousedown\":\n              clearTimeout(m._longpressactive), m.data(\"fire_click_event\", 1), g || f.drawWaitingRing(u, this.config.datasetIndex);\n              break;\n\n            case \"mouseup\":\n              f.hideWaitElem(), f.clearLongPress();\n          }\n        }, t.prototype.dragUp = function (e) {\n          this.data(\"drag-options\").dataset._dragUp.call(this, e);\n        }, t.prototype.dragMove = function (e, t) {\n          var o = this.data(\"drag-options\").dataset,\n              a = t[0],\n              r = t[1],\n              n = t[2],\n              i = t[3];\n\n          o._dragMove.call(this, a, r, n, i);\n        }, t.prototype.dragStart = function (e) {\n          this.data(\"drag-options\").dataset._dragStart.call(this, e);\n        }, t.prototype._dragStart = function () {\n          var e,\n              t = this.data(\"drag-options\"),\n              o = t.dataObj,\n              a = o.graphics.element,\n              r = a.getBBox(),\n              n = o.config,\n              i = t.dataset,\n              l = i.getFromEnv(\"chart\"),\n              s = n.dragStart || (n.dragStart = {}),\n              c = o.graphics.cloneGraphic,\n              u = i.getContainer(\"cloneGraphicGroup\"),\n              p = o.graphics.cloneText,\n              h = o.graphics.image,\n              d = o.graphics.cloneImage,\n              g = o.graphics.label;\n          S && (a._.dirty = 1), n.allowDrag && (!c && o.graphics.element && (c = o.graphics.cloneGraphic = o.graphics.element.clone(), u.appendChild(c)), g && !p && ((p = o.graphics.cloneText = o.graphics.label.clone()).followers[0] && p.followers[0].el && u.appendChild(p.followers[0].el), u.appendChild(p)), h && !d && (d = o.graphics.cloneImage = o.graphics.image.clone(), u.appendChild(d)), p && p.show(), d && d.show(), c && c.show()), s.xPos = n._xPos, s.yPos = n._yPos, s.x = n.x, s.y = n.y, s.bBox = r, s.origX = s.lastDx || (s.lastDx = 0), s.origY = s.lastDy || (s.lastDy = 0), e = a.data(x), l.fireChartInstanceEvent(\"dataplotdragstart\", e), c && c.show(), p && p.show(), d && d.show();\n        }, t.prototype._dragMove = function (e, t) {\n          var o,\n              a = this.data(\"drag-options\"),\n              r = a.dataObj,\n              n = r.graphics.element,\n              i = r.graphics.cloneGraphic,\n              l = r.graphics.cloneImage,\n              s = r.graphics.cloneText,\n              c = r.config,\n              u = c.dragStart,\n              p = u.bBox.x + e,\n              h = u.bBox.x2 + e,\n              d = u.bBox.y + t,\n              g = u.bBox.y2 + t,\n              f = a.dataset,\n              m = f.getFromEnv(\"animationManager\"),\n              v = f.getLinkedParent(),\n              b = f.getFromEnv(\"chartConfig\"),\n              y = b.canvasLeft,\n              x = b.canvasRight,\n              w = b.canvasTop,\n              k = b.canvasBottom;\n          p < y && (e += y - p), h > x && (e -= h - x), d < w && (t += w - d), g > k && (t -= g - k), (e || t) && (n.data(\"fire_click_event\", 0), v.hideWaitElem(), v.clearLongPress()), c.allowDrag && (u.draged = !0, u.lastDx = e, u.lastDy = t, o = a._transformObj = {\n            transform: \"t\" + (u.origX + e) + C + (u.origY + t)\n          }, i && m.setAnimation({\n            el: i,\n            attr: o,\n            component: f\n          }), l && m.setAnimation({\n            el: l,\n            attr: o,\n            component: f\n          }), s && m.setAnimation({\n            el: s,\n            attr: {\n              x: c._xPos + e,\n              y: c._yPos + t\n            },\n            component: f\n          }));\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o = this.config.tree.getNeighbour({\n            x: e,\n            y: t\n          }, !1);\n          if (o) return {\n            pointIndex: o.index || o.i,\n            hovered: !0,\n            pointObj: o.data\n          };\n        }, t.prototype._rolloutResponseSetter = function (e, t, o) {\n          var a = this.getFromEnv(\"animationManager\"),\n              n = t.config,\n              i = t.graphics.element,\n              l = n.dragStart,\n              s = i.data(\"unHoverAttr\");\n          l && Object.keys(l).length || (\"poly\" !== n.shapeType && n.shapeType !== f || (s.path = (0, r.polyPathToPath)([n.shapeArg.sides, n._xPos, n._yPos, s.r, n.startAngle, 0])), n.rollOverProperties.enabled && a.setAnimation({\n            el: i,\n            attr: s,\n            component: this\n          }), e && e.plotEventHandler(i, o, \"DataPlotRollOut\"));\n        }, t.prototype._rolloverResponseSetter = function (e, t, o) {\n          var a = this.getFromEnv(\"animationManager\"),\n              n = t.config,\n              i = t.graphics.element,\n              l = n.dragStart,\n              s = i.data(\"hoverAttr\");\n          l && Object.keys(l).length || (\"poly\" !== n.shapeType && n.shapeType !== f || (s.path = (0, r.polyPathToPath)([n.shapeArg.sides, n._xPos, n._yPos, s.r, n.startAngle, 0])), n.rollOverProperties.enabled && a.setAnimation({\n            el: i,\n            attr: s,\n            component: this\n          }), e && e.plotEventHandler(i, o, \"DataPlotRollOver\"));\n        }, t.prototype._dragUp = function (e) {\n          var t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s = this.data(\"drag-options\"),\n              c = s.dataset,\n              u = c.getFromEnv(\"chart\"),\n              p = c.components.data,\n              h = s.dataObj,\n              d = h.graphics.element,\n              g = c.getLinkedParent(),\n              f = h.config,\n              m = h.config.dragStart || {},\n              v = c.getFromEnv(\"yAxis\"),\n              b = h.graphics.cloneText,\n              y = c.getFromEnv(\"xAxis\"),\n              w = {},\n              k = c.config.datasetIndex,\n              C = h.graphics.cloneGraphic,\n              N = h.graphics.cloneImage;\n\n          if (g.hideWaitElem(), g.clearLongPress(), m.draged) {\n            for (m.origX += m.lastDx, m.origY += m.lastDy, h.config._xPos = m.xPos + m.lastDx, h.config._yPos = m.yPos + m.lastDy, w.x = y.getValue(h.config._xPos), w.y = v.getValue(h.config._yPos), w.update = !0, a = 0, i = p.length; a < i && (n = p[a], h.config.id !== n.config.id); a++) {\n              ;\n            }\n\n            c.updatePointConfig(w, a), (l = d.data(x)).x = w.x, l.y = w.y, c.parsePlotAttributes(a), c._drawNode(a), t = h.config.startConnectors, o = h.config.endConnectors, g.drawNodeConnectors(t, k), g.drawNodeConnectors(o, k), (0, r.getMouseCoordinate)(u.getFromEnv(\"chart-container\"), e).sourceEvent = \"dataplotdragend\", u.fireChartInstanceEvent(\"chartupdated\", (0, r.extend2)({\n              sourceEvent: \"dataplotdragend\"\n            }, l), e), u.fireChartInstanceEvent(\"dataplotdragend\", l, e), m.draged = !1, c._setupKdTree();\n          }\n\n          b && b.hide(), C && C.hide(), N && N.hide(), delete f.dragStart;\n        }, t.prototype.updatePointConfig = function (e, t) {\n          var o,\n              a = this.components.data,\n              n = this.config,\n              i = (a[t] || {}).config,\n              l = this.getFromEnv(\"number-formatter\"),\n              s = this.getFromEnv(\"chart-attrib\");\n          i !== undefined && (i.y = l.getCleanValue((0, r.pluck)(e.y)), i.x = l.getCleanValue((0, r.pluck)(e.x)), i._options.x = i.x, i._options.y = i.y, o = l.xAxis(i.x), i.formatedVal = null === i.y ? i.y : l.dataLabels(i.y), i.xValue = o, n.showTooltip ? i.toolText = L(i, n, s) : i.toolText = !1, i.update = e.update);\n        }, t.prototype.getNode = function (e) {\n          return e ? this.components.nodes[e] : this.components.nodes;\n        }, t.prototype.configureAttributes = function (e) {\n          if (e) this.trimData(e), this.config.JSONData = e;else if (!e && !this.config.JSONData) return !1;\n          var t,\n              o,\n              a,\n              i,\n              l,\n              s,\n              c,\n              u = this.config.datasetIndex,\n              p = this.config.JSONData,\n              h = p.data || [],\n              d = this.getFromEnv(\"chart-attrib\"),\n              g = this.getFromEnv(\"chartConfig\"),\n              f = h.length,\n              m = this.config,\n              v = r.ZEROSTRING,\n              b = this.getFromEnv(\"color-manager\"),\n              y = r.HUNDREDSTRING;\n\n          for (m.context = {}, this.components.nodes = {}, m.showValues = (0, r.pluckNumber)(p.showvalues, d.showvalues, 1), c = m.useRoundEdges = (0, r.pluckNumber)(d.useroundedges), m.zIndex = 1, m.name = (0, r.getValidValue)(p.seriesname), m.viewMode = (0, r.pluckNumber)(d.viewmode, 0), m.id = (0, r.pluck)(p.id, this.index), 0 !== (0, r.pluckNumber)(p.includeinlegend) && m.name !== undefined || (m.showInLegend = !1), m.seriesname = (0, r.parseUnsafeString)(p.seriesname), m.includeinlegend = (0, r.pluckNumber)(p.includeinlegend, m.seriesname ? 1 : 0), m.showTooltip = (0, r.pluckNumber)(d.showtooltip, 1), m.seriesNameInTooltip = (0, r.pluckNumber)(d.seriesnameintooltip, 1), m.tooltipSepChar = (0, r.pluck)(d.tooltipsepchar, \" - \"), o = m.plotFillAlpha = (0, r.pluck)(d.plotfillalpha, y), a = m.showPlotBorder = (0, r.pluckNumber)(d.showplotborder, 1), i = m.plotBorderColor = (0, n.getFirstColor)((0, r.pluck)(d.plotbordercolor, \"666666\")), l = m.plotBorderThickness = (0, r.pluckNumber)(d.plotborderthickness, c ? 2 : 1), s = m.plotBorderAlpha = (0, r.pluck)(d.plotborderalpha, d.plotfillalpha, c ? \"35\" : \"95\"), m.use3DLighting = Boolean((0, r.pluckNumber)(d.use3dlighting, d.is3d, c ? 1 : 0)), m.color = (0, n.getFirstColor)((0, r.pluck)(p.color, b.getPlotColor(u))), m.alpha = (0, r.pluck)(p.plotfillalpha, p.nodeFillAlpha, p.alpha, o), m.datasetShowPlotBorder = Boolean((0, r.pluckNumber)(p.showplotborder, a)), m.datasetPlotBorderColor = (0, n.getFirstColor)((0, r.pluck)(p.plotbordercolor, p.nodebordercolor, i)), m.datasetPlotBorderThickness = (0, r.pluckNumber)(p.plotborderthickness, p.nodeborderthickness, l), m.datasetPlotBorderAlpha = m.datasetShowPlotBorder ? (0, r.pluck)(p.plotborderalpha, p.nodeborderalpha, p.alpha, s) : v, m.datasetAllowDrag = Boolean((0, r.pluckNumber)(p.allowdrag, 1)), m.colorObj = {\n            fillColor: (0, n.convertColor)(m.color, m.alpha),\n            lineColor: {\n              FCcolor: {\n                color: m.datasetPlotBorderColor,\n                alpha: m.datasetPlotBorderAlpha\n              }\n            }\n          }, m.lineWidth = void 0, m.symbol = \"poly_4\", this.components.data || (this.components.data = []), this.setState(\"visible\", 1 === (0, r.pluckNumber)(p.visible, !Number(p.initiallyhidden), 1)), m.yMin = m.yMax = m.xMax = m.xMin = 0, this._refreshData = !0, t = 0; t < f; t += 1) {\n            this._setConfigure(t);\n          }\n\n          this._refreshData = !1, g.showLegend && this._addLegend(), this._setDatasetIndex(), this.setState(\"dirty\", !0);\n        }, t.prototype._setConfigure = function (e, t) {\n          var o,\n              a,\n              i,\n              l,\n              s,\n              c,\n              u = this.config.JSONData,\n              p = u.data,\n              h = t || p[e],\n              v = this.components.data,\n              b = this.config,\n              y = v[e] = v[e] || (v[e] = {}),\n              x = y.config = y.config || (y.config = {}),\n              w = b.id,\n              k = b.yMin || +Infinity,\n              C = b.yMax || -Infinity,\n              S = b.xMax || -Infinity,\n              E = b.xMin || +Infinity,\n              D = b.use3DLighting,\n              _ = b.datasetPlotBorderThickness,\n              P = b.datasetPlotBorderColor,\n              O = b.datasetPlotBorderAlpha,\n              V = this.getFromEnv(\"chart-attrib\"),\n              M = b.color,\n              F = b.alpha,\n              I = b.datasetAllowDrag,\n              B = this.getFromEnv(\"number-formatter\");\n\n          if (!y.graphics && (y.graphics = {}), x._options = (0, r.extend2)({}, h), h || t) {\n            if (a = x.y = B.getCleanValue((0, r.pluck)(h.y)), i = x.x = B.getCleanValue((0, r.pluck)(h.x)), x.index = e, x.dragStart || (x.dragStart = {}), C = d(C, x.y), k = g(k, x.y), S = d(S, x.x), E = g(E, x.x), null === a) x.value = null;else {\n              switch (l = B.xAxis(i), x.formatedVal = null === a ? a : B.dataLabels(a), x.setTooltext = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(h.tooltext, u.plottooltext, V.plottooltext))), x.pointLabel = (0, r.pluck)(h.label, h.name), s = (0, r.parseUnsafeString)(x.pointLabel), x.label = s, x.name = s, x.displayValue = s, x.xValue = l, t || (x.startConnectors = {}, x.endConnectors = {}), b.showTooltip ? x.toolText = L(x, b, V) : x.toolText = !1, x.link = h.link, x.id = (0, r.pluck)(h.id, w + r.preDefStr.UNDERSCORE + e), x.allowDrag = Boolean((0, r.pluckNumber)(h.allowdrag, I)), o = x.shape = (0, r.getValidValue)((0, r.pluck)(h.shape), r.preDefStr.RECTANGLE).toLowerCase(), x.height = (0, r.getValidValue)((0, r.pluck)(h.height), 10), x.width = (0, r.getValidValue)((0, r.pluck)(h.width), 10), x.radius = (0, r.getValidValue)((0, r.pluck)(h.radius), 10), x.numSides = (0, r.getValidValue)((0, r.pluck)(h.numsides), 4), x.color = (0, n.getFirstColor)((0, r.pluck)(h.color, M)), x.borderColor = (0, n.getFirstColor)((0, r.pluck)(h.bordercolor, P)), x.alpha = (0, r.pluck)(h.alpha, F), x.imageURL = (0, r.getValidValue)(h.imageurl), x.imageNode = Boolean((0, r.pluckNumber)(h.imagenode)), x.imageWidth = h.imagewidth, x.imageHeight = h.imageheight, x.imageAlign = (0, r.getValidValue)(h.imagealign, r.BLANK).toLowerCase(), x.labelAlign = (0, r.pluck)(h.labelalign, x.imageNode && A(x.imageURL) ? N : r.preDefStr.POSITION_MIDDLE), x.hovercolor = (0, r.pluck)(h.hovercolor, u.hovercolor), x.borderhoveralpha = (0, r.pluck)(h.borderhoveralpha, u.borderhoveralpha), x.borderhovercolor = (0, r.pluck)(h.borderhovercolor, u.borderhovercolor), x.borderhoverthickness = (0, r.pluck)(h.borderhoverthickness, u.borderhoverthickness), x.hoveralpha = (0, r.pluck)(h.hoveralpha, u.hoveralpha), x.hoverheight = (0, r.pluck)(h.hoverheight, u.hoverheight), x.hoverradius = (0, r.pluck)(h.hoverradius, u.hoverradius), x.hoverwidth = (0, r.pluck)(h.hoverwidth, u.hoverwidth), x.shape) {\n                case f:\n                  c = 0;\n                  break;\n\n                case m:\n                  c = 2, o = (0, n.mapSymbolName)(x.numSides);\n                  break;\n\n                default:\n                  c = 1;\n              }\n\n              x.symbol = o, D ? (x.fillColor = T(x.color, x.alpha, c), x.cloneFillColor = T(x.color, 50, c)) : (x.fillColor = {\n                color: x.color,\n                alpha: x.alpha\n              }, x.cloneFillColor = (0, n.convertColor)(x.color, 50)), x.colorArr = [{\n                FCcolor: {\n                  color: x.color,\n                  alpha: x.alpha\n                }\n              }, {\n                FCcolor: {\n                  color: x.borderColor,\n                  alpha: O\n                }\n              }], x.rollOverProperties = this.pointHoverOptions(y, V, {\n                shapeType: c,\n                use3D: D,\n                height: x.height,\n                width: x.width,\n                radius: x.radius,\n                color: x.color,\n                alpha: x.alpha,\n                borderColor: x.borderColor,\n                borderAlpha: O,\n                borderThickness: _\n              });\n            }\n            !x.update && t && (x.update = t.update), !x.add && t && (x.add = t.add), !0 === this._refreshData && delete y.removed;\n          }\n\n          y.dataset = this, b.xMax = S, b.xMin = E, b.yMin = k, b.yMax = C;\n        }, t.prototype.pointHoverOptions = function (e, t, o) {\n          var a,\n              i,\n              l,\n              s = (0, r.pluckNumber)(e.config.showhovereffect, this.config.showhovereffect, t.plothovereffect, t.showhovereffect),\n              c = {},\n              u = !!(0, r.pluck)(e.config.hovercolor, this.config.hovercolor, t.plotfillhovercolor, e.config.hoveralpha, this.config.hoveralpha, t.plotfillhoveralpha, e.config.borderhovercolor, this.config.borderhovercolor, t.plotborderhovercolor, e.config.borderhoveralpha, this.config.borderhoveralpha, t.plotborderhoveralpha, e.config.borderhoverthickness, this.config.borderhoverthickness, t.plotborderhoverthickness, e.config.hoverheight, this.config.hoverheight, t.plothoverheight, e.config.hoverwidth, this.config.hoverwidth, t.plothoverwidth, e.config.hoverradius, this.config.hoverradius, t.plothoverradius, s),\n              p = !1;\n          return (s === undefined && u || s) && (p = !0, a = (0, r.pluck)(e.config.hovercolor, this.config.hovercolor, t.plotfillhovercolor, (0, n.getLightColor)(o.color, 70)), i = (0, r.pluck)(e.config.hoveralpha, this.config.hoveralpha, t.plotfillhoveralpha, o.alpha), c = {\n            stroke: (0, n.convertColor)((0, r.pluck)(e.config.borderhovercolor, this.config.borderhovercolor, t.plotborderhovercolor, o.borderColor), (0, r.pluckNumber)(e.config.borderhoveralpha, this.config.borderhoveralpha, t.plotborderhoveralpha, i, o.borderAlpha)),\n            \"stroke-width\": (0, r.pluckNumber)(e.config.borderhoverthickness, this.config.borderhoverthickness, t.plotborderhoverthickness, o.borderThickness),\n            height: (0, r.pluckNumber)(e.config.hoverheight, this.config.hoverheight, t.plothoverheight, o.height),\n            width: (0, r.pluckNumber)(e.config.hoverwidth, this.config.hoverwidth, t.plothoverwidth, o.width),\n            r: (0, r.pluckNumber)(e.config.hoverradius, this.config.hoverradius, t.plothoverradius, o.radius)\n          }, l = o.use3D ? T((0, n.getFirstColor)((0, r.pluck)(e.config.hovercolor, this.config.hovercolor, t.plotfillhovercolor, (0, n.getLightColor)(o.color, 70))), (0, r.pluck)(e.config.hoveralpha, this.config.hoveralpha, t.plotfillhoveralpha, o.alpha), o.shapeType) : (0, n.convertColor)(a, i), c.fill = (0, r.toRaphaelColor)(l)), {\n            enabled: p,\n            rollOverAttrs: c\n          };\n        }, t.prototype._addLegend = function () {\n          var e,\n              t = this.config,\n              o = this.getFromEnv(\"legend\"),\n              a = {\n            enabled: t.includeInLegend,\n            type: this.type,\n            anchorSide: 4,\n            label: (0, r.getFirstValue)(this.config.JSONData.seriesname)\n          };\n          t.includeinlegend ? ((e = o.getItem(this.config.legendItemId)) ? e.configure({\n            style: o.config.itemStyle,\n            hiddenStyle: o.config.itemHiddenStyle,\n            datasetVisible: o.config.datasetVisible,\n            hoverStyle: o.config.itemHoverStyle\n          }) : (this.config.legendItemId = o.createItem(this), e = o.getItem(this.config.legendItemId), this.addExtEventListener(\"click\", function () {\n            e.itemClickFn();\n          }, e)), e.configure(a), e.setStateCosmetics(\"default\", {\n            symbol: {\n              fill: (0, r.toRaphaelColor)({\n                color: t.color,\n                alpha: t.alpha\n              }),\n              rawFillColor: t.color,\n              stroke: (0, r.toRaphaelColor)({\n                color: t.plotBorderColor,\n                alpha: r.HUNDREDSTRING\n              }),\n              \"stroke-width\": t.anchorBorderThickness\n            }\n          }), this.getState(\"visible\") ? e.removeLegendState(\"hidden\") : e.setLegendState(\"hidden\")) : this.config.legendItemId && o.disposeItem(this.config.legendItemId);\n        }, t.prototype.createContainer = function () {\n          var e = this.getFromEnv(\"animationManager\"),\n              t = this.getLinkedParent().getChildContainer();\n          !this.getContainer(\"nodesGroup\") && this.addContainer(\"nodesGroup\", D(\"nodesGroup\", e, t.defaultVcanvasGroup, this)), !this.getContainer(\"dataLabelsGroup\") && this.addContainer(\"dataLabelsGroup\", D(\"dataLabelsGroup\", e, t.vcanvasLabelGroup, this)), !this.getContainer(\"cloneGraphicGroup\") && this.addContainer(\"cloneGraphicGroup\", D(\"cloneGraphicGroup\", e, t.defaultVcanvasGroup, this));\n        }, t.prototype.draw = function () {\n          var e,\n              t,\n              o,\n              a = this.components,\n              r = this.getFromEnv(\"smartLabel\"),\n              n = a.data,\n              i = this.components.removeDataArr || [],\n              l = i.length,\n              s = this.getFromEnv(\"dataLabelStyle\"),\n              c = {\n            fontFamily: s.fontFamily,\n            fontSize: s.fontSize,\n            lineHeight: s.lineHeight,\n            fontWeight: s.fontWeight,\n            fontStyle: s.fontStyle\n          };\n\n          if (this.getState(\"dirty\") || this._contextChanged()) {\n            for (this.createContainer(), o = this.getContainer(\"nodesGroup\"), this.getFromEnv(\"animationManager\").setAnimation({\n              el: this.getContainer(\"cloneGraphicGroup\"),\n              attr: {\n                opacity: .3\n              },\n              component: this\n            }), o.css(c), r.useEllipsesOnOverflow(this.getFromEnv(\"chartConfig\").useEllipsesWhenOverflow), e = 0, t = n.length; e < t; e += 1) {\n              !n[e].removed && this._drawNode(e);\n            }\n\n            for (this.config.drawn = !0, e = 0; e < l; e++) {\n              this._removeDataVisuals(i.shift());\n            }\n\n            this._setupKdTree();\n          }\n        }, t.prototype._setupKdTree = function () {\n          var e,\n              t,\n              o,\n              a,\n              n,\n              i = this.config,\n              l = this.components.data,\n              s = -Infinity;\n\n          for (n = i.searchDataArr = [], e = l.length, t = 0; t < e; t++) {\n            o = l[t].config, l[t].removed || o._yPos === undefined || isNaN(o._yPos) || (a = o.props.element.attr, s = Math.max(s, (0, r.pluckNumber)(o.radius, 0)), n.push({\n              x: (0, r.pluckNumber)(a.x, o._xPos),\n              y: (0, r.pluckNumber)(a.y, o._yPos),\n              index: t,\n              data: l[t],\n              shapeInfo: {\n                type: o.shape,\n                radius: (0, r.pluck)(o.radius, 0),\n                width: (0, r.pluckNumber)(o.width),\n                height: (0, r.pluckNumber)(o.height),\n                sides: (0, r.pluckNumber)(o.numSides)\n              }\n            }));\n          }\n\n          i.tree = new c[\"default\"](!0).buildKdTree(n), i.tree._setSearchLimit(s, s);\n        }, t.prototype.drawLabel = function (e) {\n          var t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              w,\n              k,\n              C,\n              S,\n              E,\n              D,\n              T = this.getFromEnv(\"chart\"),\n              L = this.config.datasetIndex,\n              _ = this.getFromEnv(\"animationManager\"),\n              P = this.components.data,\n              O = P.length,\n              V = this.getContainer(\"nodesGroup\"),\n              M = this.getFromEnv(\"chartConfig\"),\n              F = this.getFromEnv(\"dataLabelStyle\"),\n              I = this.dragUp,\n              B = this.dragMove,\n              R = this.dragStart,\n              j = this.getFromEnv(\"smartLabel\"),\n              G = this.getState(\"visible\");\n\n          for (e !== undefined ? O = (t = e) + 1 : t = 0; t < O; t++) {\n            if (v = (n = (p = P[t]).config)._plotWidth, b = n._plotHeight, i = n.displayValue, w = n.labelAlign, m = (k = p.graphics).cloneText, C = p.config.rollOverProperties, S = n.shapeType, G && (A(i) || i !== r.BLANK)) {\n              switch (j.useEllipsesOnOverflow(M.useEllipsesWhenOverflow), c = .5 * b - .5 * (s = j.getSmartText(i, v, b)).height, w) {\n                case N:\n                  c = -c;\n                  break;\n\n                case r.POSITION_BOTTOM:\n                  break;\n\n                default:\n                  c = 0;\n              }\n\n              d = n._xPos, E = n._yPos, p._yAdjustment = h = c, g = E + h, l = n.link ? r.POINTER : n.allowDrag ? \"move\" : r.BLANKSTRING, o = {\n                text: s.text,\n                title: s.tooltext || r.BLANKSTRING,\n                fill: F.color,\n                \"text-bound\": [F.backgroundColor, F.borderColor, F.borderThickness, F.borderPadding, F.borderRadius, F.borderDash],\n                x: d,\n                y: g,\n                cursor: l\n              }, a = k.label, a = _.setAnimation({\n                el: a || \"text\",\n                attr: o,\n                container: V,\n                component: this\n              }), k.label ? a.show() : (a = this.addGraphicalElement(\"plotLabel\", a, !0), k.label = a, a.drag(B, R, I)), (D = k && (k.image || k.element)) && a.insertAfter(D), m && _.setAnimation({\n                el: m,\n                attr: {\n                  transform: r.BLANKSTRING,\n                  x: d,\n                  y: g,\n                  text: s.text,\n                  title: s.tooltext || r.BLANKSTRING,\n                  fill: F.color,\n                  \"text-bound\": [F.backgroundColor, F.borderColor, F.borderThickness, F.borderPadding, F.borderRadius, F.borderDash]\n                },\n                component: this\n              }), a.data(\"drag-options\", {\n                dataObj: p,\n                dataset: this,\n                datasetIndex: L,\n                pointIndex: p.config.index,\n                cursor: l,\n                chart: T,\n                link: p.link\n              }), u = {\n                index: t,\n                link: n.link,\n                y: n.y,\n                x: n.x,\n                shape: (0, r.pluck)(S, \"rect\"),\n                width: n.width,\n                height: n.height,\n                radius: n.radius,\n                sides: n.numSides,\n                label: n.displayValue,\n                toolText: n.toolText,\n                id: n.id,\n                datasetIndex: L,\n                datasetName: this.config.JSONData.seriesname,\n                sourceType: \"dataplot\"\n              }, f = L + \"_\" + t, a.data(y, f), a.data(x, u), a.data(\"hoverAttr\", C && C.rollOverAttrs), a.data(\"unHoverAttr\", D.data(\"unHoverAttr\"));\n            } else k.label && k.label.hide();\n          }\n        }, t.prototype.parsePlotAttributes = function (e) {\n          var t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              m,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D = this.config.datasetIndex,\n              T = this.components,\n              L = T.nodes,\n              _ = this.getFromEnv(\"xAxis\"),\n              P = this.getFromEnv(\"yAxis\"),\n              O = T.data[e],\n              V = O.config,\n              M = this.config,\n              F = O.graphics || (O.graphics = {}),\n              I = V.symbol,\n              B = M.colorObj.lineColor,\n              R = M.datasetPlotBorderThickness,\n              j = O.config.rollOverProperties,\n              G = V.shape,\n              H = V.link ? r.POINTER : V.allowDrag ? \"move\" : r.BLANKSTRING,\n              W = F.cloneImage;\n\n          if (V._yPos = o = P.getPixel(V.y), V._xPos = t = _.getPixel(V.x), o !== undefined && !isNaN(o)) {\n            if (V.shapeArg = {}, c = V.shapeArg, n = (0, r.pluckNumber)(V.height), a = (0, r.pluckNumber)(V.width), i = (0, r.pluckNumber)(V.radius), g = I === v, l = V.id, s = V.imageNode, u = V.imageURL, p = V.imageAlign, h = g ? a : 1.4 * i, m = (0, r.pluckNumber)(V.imageWidth, h), d = g ? n : 1.4 * i, y = (0, r.pluckNumber)(V.imageHeight, d), k = (0, r.toRaphaelColor)(V.fillColor), V._plotWidth = h, V._plotHeight = d, w = {\n              fill: k,\n              \"stroke-width\": R,\n              stroke: (0, r.toRaphaelColor)(B)\n            }, N = [(I = (I = c.symbol = (0, r.pluck)(V.symbol, M.symbol, r.BLANK)).split(b))[1], t, o, V.radius, V.startAngle, 0], \"poly\" === I[0] || I[0] === f ? (V.shapeType = I[0], V.elemType = \"path\", S = {\n              path: (0, r.polyPathToPath)(N)\n            }, c.x = t, c.y = o, c.radius = V.radius, c.sides = I[1], w.r = V.radius, delete w.width, delete w.x, delete w.y, delete w.height, j && j.enabled && (delete (C = j.rollOverAttrs).x, delete C.y, delete C.width, delete C.height)) : (V.shapeType = r.SHAPE_RECT, V.elemType = \"rect\", c.x = t - a / 2, c.y = o - n / 2, c.r = 0, c.width = a, c.height = n, S = {\n              x: c.x,\n              y: c.y,\n              width: a,\n              height: n,\n              r: 0\n            }, w.width = a, w.height = n, w.x = t - a / 2, w.y = o - n / 2, j && j.enabled && ((C = j.rollOverAttrs).x = t - C.width / 2, C.y = o - C.height / 2, delete C.r)), S.fill = k, S[\"stroke-width\"] = R, S.stroke = (0, r.toRaphaelColor)(B), V.eventArgs = {\n              index: e,\n              link: V.link,\n              y: V.y,\n              x: V.x,\n              shape: (0, r.pluck)(G, \"rect\"),\n              width: a,\n              height: n,\n              radius: i,\n              sides: V.numSides,\n              label: V.displayValue,\n              toolText: V.toolText,\n              id: V.id,\n              datasetIndex: D,\n              datasetName: this.config.JSONData.seriesname,\n              sourceType: \"dataplot\"\n            }, s && u) {\n              switch (y > d && (y = d), m > h && (m = h), p) {\n                case r.POSITION_MIDDLE:\n                  x = o - y / 2;\n                  break;\n\n                case r.POSITION_BOTTOM:\n                  x = d > y ? o + d / 2 - y : o - y / 2;\n                  break;\n\n                default:\n                  x = d > y ? o - .5 * d : o - y / 2;\n              }\n\n              V.imageX = t - m / 2, V.imageY = x, V.imageWidth = m, V.imageHeight = y, A = {\n                src: u,\n                x: V.imageX,\n                y: x,\n                width: m,\n                height: y,\n                cursor: H\n              }, W && (E = {\n                transform: r.BLANKSTRING,\n                src: u,\n                x: V.imageX,\n                y: x,\n                width: m,\n                height: y\n              });\n            }\n\n            V.pointAttr = w, L[l] = O, V.props = {\n              element: {\n                attr: S\n              },\n              imageElement: {\n                attr: A\n              },\n              cloneImage: {\n                attr: E\n              },\n              cloneGraphic: {\n                attr: S\n              }\n            };\n          }\n        }, t.prototype.allocatePosition = function (e) {\n          var t, o;\n          if (o = this.components.data.length, e !== undefined) this.parsePlotAttributes(e);else for (t = 0; t < o; t++) {\n            this.parsePlotAttributes(t);\n          }\n        }, t.prototype._drawNode = function (e) {\n          var t,\n              o,\n              a = this.getFromEnv(\"chart\"),\n              n = this.config.datasetIndex,\n              i = this.getLinkedParent(),\n              l = this.components,\n              s = this.getFromEnv(\"animationManager\"),\n              c = l.data[e],\n              u = c.config,\n              p = c.graphics || (c.graphics = {}),\n              h = u.imageNode,\n              d = u.imageURL,\n              g = this.getContainer(\"nodesGroup\"),\n              f = c.config.rollOverProperties,\n              m = this.dragUp,\n              v = this.dragMove,\n              b = this.dragStart,\n              w = u.link ? r.POINTER : u.allowDrag ? \"move\" : r.BLANKSTRING,\n              k = p.graphic,\n              C = p.cloneText,\n              N = p.cloneGraphic,\n              S = p.cloneImage,\n              A = p.image,\n              D = p.label,\n              T = this.getState(\"visible\");\n          u._yPos === undefined || isNaN(u._yPos) ? (p.element && (p.element = s.setAnimation({\n            el: p.element,\n            component: this\n          })), p.image && (p.image = s.setAnimation({\n            el: p.image,\n            component: this\n          })), p.label && (p.label = s.setAnimation({\n            el: p.label,\n            component: this\n          }))) : (o = (k = p.element) && k.type, -1 === u.elemType.indexOf(o) && k && (k.remove(), k = p.element = null, D && D.remove(), A && A.remove(), delete p.label, delete p.image, A = null, D = null), k = s.setAnimation({\n            el: k || u.elemType,\n            label: \"node\",\n            attr: u.props.element.attr,\n            container: g,\n            component: this\n          }), p.graphic || k.drag(v, b, m), p.element = k, k.show(), i.animationDone = !0, t = n + \"_\" + e, N && (N.type === k.type ? s.setAnimation({\n            el: N,\n            attr: u.props.element.attr,\n            component: this\n          }).transform(r.BLANKSTRING) : (N.remove(), delete c.graphics.cloneGraphic, C && (C.remove(), delete c.graphics.cloneText))), h && d ? (A = s.setAnimation({\n            el: p.image || \"image\",\n            attr: T && u.props.imageElement.attr,\n            doNotRemove: !0,\n            container: g,\n            component: this,\n            callback: !T && E\n          }), !p.image && A && A.drag(v, b, m), p.image = A, T && A.show(), A.data(\"drag-options\", {\n            dataObj: c,\n            dataset: this,\n            datasetIndex: this.index,\n            pointIndex: c.config.index,\n            cursor: w,\n            link: c.link\n          }), A.data(y, t), A.data(x, u.eventArgs), A.data(\"hoverAttr\", f && f.rollOverAttrs), A.data(\"unHoverAttr\", u.pointAttr), S && s.setAnimation({\n            el: S,\n            attr: u.props.cloneImage.attr,\n            component: this\n          })) : p.image && (p.image = s.setAnimation({\n            el: p.image,\n            component: this\n          })), this.drawLabel(e), s.setAnimation({\n            el: k,\n            attr: {\n              cursor: w\n            },\n            component: this\n          }), k.data(\"drag-options\", {\n            dataObj: c,\n            dataset: this,\n            datasetIndex: this.index,\n            pointIndex: c.config.index,\n            cursor: w,\n            chart: a,\n            link: c.link\n          }), k.data(y, t), k.data(x, u.eventArgs), k.data(\"hoverAttr\", f && f.rollOverAttrs), k.data(\"unHoverAttr\", u.pointAttr), T ? k.show() : k.hide());\n        }, t.prototype.trimData = function (e) {\n          if (this.config.JSONData) {\n            var t = this.components,\n                o = t.data && t.data.length,\n                a = e.data && e.data.length || 0,\n                r = o - a;\n            r > 0 && this.removeData(a, r);\n          }\n        }, t.prototype.removeData = function (e, t) {\n          var o = this.components,\n              a = this.getLinkedParent(),\n              r = o.data,\n              n = o.removeDataArr || (o.removeDataArr = []);\n          t = t || 1, (e = e || 0) < 0 && (e = 0), o.removeDataArr = n = n.concat(r.splice(e, t)), a._clearConnectors();\n        }, t.prototype._removeDataVisuals = function (e) {\n          var t, o, a;\n          if (e) for (t in o = e.graphics) {\n            (a = o[t]).hide && \"function\" == typeof a.hide && (this.getFromEnv(\"animationManager\").setAnimation({\n              el: a,\n              attr: {\n                \"text-bound\": []\n              },\n              component: this\n            }), a.hide(), a.transform && a.transform(r.BLANKSTRING));\n          }\n        }, t.prototype.getJSONData = function () {\n          var e,\n              t,\n              o = this.components.data,\n              a = o.length,\n              r = [];\n\n          for (t = 0; t < a; t++) {\n            (e = o[t]).removed || e.config._options && (delete e.config._options.update, delete e.config._options.add, r.push(e.config._options));\n          }\n\n          return r;\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = _;\n    },\n    546: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.dragNode\": function initialDatasetDragNode() {\n          return {\n            \"node.appearing\": function nodeAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"axis\"\n              }];\n            }\n          };\n        }\n      };\n    },\n    547: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = s(o(545)),\n          r = o(118),\n          n = o(122),\n          i = o(125),\n          l = s(o(548));\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var u = r.preDefStr.EVENTARGS,\n          p = r.preDefStr.configStr,\n          h = function h(e) {\n        var t,\n            o = e.config,\n            a = o.fromPointObj,\n            n = o.toPointObj,\n            i = o.fromX,\n            l = o.fromY,\n            s = o.toX,\n            c = o.toY,\n            u = [\"M\", i, l];\n        return o.arrowAtStart && (u = (t = a.config).shapeType === r.SHAPE_RECT ? u.concat(g._drawArrow(i, l, s, c, t.shapeArg.width, t.shapeArg.height)) : u.concat(g._drawArrow(i, l, s, c, t.shapeArg.radius))), o.arrowAtEnd && (u = (t = n.config).shapeType === r.SHAPE_RECT ? u.concat(g._drawArrow(s, c, i, l, t.shapeArg.width, t.shapeArg.height)) : u.concat(g._drawArrow(s, c, i, l, t.shapeArg.radius))), u.push(\"L\", s, c), u;\n      },\n          d = function d(e, t, o) {\n        return o.getFromEnv(\"animationManager\").setAnimation({\n          el: \"group\",\n          attr: {\n            name: e\n          },\n          container: t,\n          component: o,\n          label: \"group\"\n        });\n      };\n\n      (0, i.addDep)({\n        name: \"connectorAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var g = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"dragNodeConnector\";\n        }, t.prototype._setDatasetIndex = function () {\n          var e = this.getLinkedParent().getChildren(\"connector\");\n          this.config.datasetIndex = e.indexOf(this);\n        }, t.prototype.configureAttributes = function (e) {\n          if (e) this.trimData(e), this.config.JSONData = e;else if (!e && !this.config.JSONData) return !1;\n          var t,\n              o = this.getFromEnv(\"chart-attrib\"),\n              a = this.config,\n              i = this.config.JSONData,\n              l = i.connector,\n              s = l && l.length,\n              c = r.HUNDREDSTRING;\n\n          for (a.connectorsTooltext = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(i.connectortooltext, o.connectortooltext))), a.stdThickness = (0, r.pluckNumber)(i.stdthickness, 1), a.conColor = (0, n.getFirstColor)((0, r.pluck)(i.color, \"FF5904\")), a.conAlpha = (0, r.pluck)(i.alpha, c), a.conDashGap = (0, r.pluckNumber)(i.dashgap, 5), a.conDashLen = (0, r.pluckNumber)(i.dashlen, 5), a.conDashed = Boolean((0, r.pluckNumber)(i.dashed, 0)), a.arrowAtStart = Boolean((0, r.pluckNumber)(i.arrowatstart, 1)), a.arrowAtEnd = Boolean((0, r.pluckNumber)(i.arrowatend, 1)), a.conStrength = (0, r.pluckNumber)(i.strength, 1), a.toolTipSepChar = (0, r.pluck)(o.tooltipsepchar, \" - \"), a.showTooltip = (0, r.pluckNumber)(o.showtooltip, 1), a.viewMode = (0, r.pluckNumber)(o.viewmode, 1), a._refreshData = !0, this._setDatasetIndex(\"connector\"), t = 0; t < s; t += 1) {\n            this._setConfigure(t, l[t]);\n          }\n\n          a._refreshData = !0;\n        }, t.prototype._setConfigure = function (e, t) {\n          var o,\n              a,\n              i,\n              l = this.components.data || (this.components.data = []),\n              s = l[e] || (l[e] = l[e] = {}),\n              c = this.config,\n              u = (0, r.parseUnsafeString)((0, r.pluck)(t.label, t.name)),\n              p = (0, r.pluck)(t.alpha, c.conAlpha),\n              h = this.getFromEnv(\"smartLabel\"),\n              d = \"$fromLabel\" + c.toolTipSepChar + \"$toLabel\",\n              g = {\n            FCcolor: {\n              color: (0, n.getFirstColor)((0, r.pluck)(t.color, c.conColor)),\n              alpha: p\n            }\n          },\n              f = c.connectorsTooltext,\n              m = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(t.tooltext, f))),\n              v = Boolean((0, r.pluckNumber)(t.dashed, c.conDashed));\n          h.useEllipsesOnOverflow(this.getFromEnv(\"chartConfig\").useEllipsesWhenOverflow), i = h.getOriSize(u), a = s.config = s.config || (s.config = {}), !s.graphics && (s.graphics = {}), o = !!c.showTooltip && (0, r.pluck)(m, u ? \"$label\" : d), (a = s.config = {\n            _options: t,\n            id: (0, r.pluck)(t.id, e).toString(),\n            from: (0, r.pluck)(t.from, r.BLANK),\n            to: (0, r.pluck)(t.to, r.BLANK),\n            label: u,\n            toolText: o,\n            customToolText: m,\n            color: g,\n            index: e,\n            dashStyle: v ? (0, r.getDashStyle)((0, r.pluckNumber)(t.dashlen, c.conDashLen), (0, r.pluckNumber)(t.dashgap, c.conDashGap)) : r.DASH_DEF,\n            dashed: t.dashed,\n            dashlen: t.dashlen,\n            dashgap: t.dashgap,\n            arrowAtStart: Boolean((0, r.pluckNumber)(t.arrowatstart, c.arrowAtStart)),\n            arrowAtEnd: Boolean((0, r.pluckNumber)(t.arrowatend, c.arrowAtEnd)),\n            conStrength: (0, r.pluckNumber)(t.strength, c.conStrength),\n            link: t.link,\n            stdThickness: c.stdThickness,\n            labelWidth: i.widht,\n            labelHeight: i.height\n          }).datasetIndex = this.config.datasetIndex, a.add = t.add, a.update = t.update, c._refreshData && delete s.removed;\n        }, t.prototype.createContainer = function () {\n          var e = this.getLinkedParent().getChildContainer();\n          !this.getContainer(\"connectorGroup\") && this.addContainer(\"connectorGroup\", d(\"connectorGroup\", e.connectorGroup, this)), !this.getContainer(\"connectorDataLabelGroup\") && this.addContainer(\"connectorDataLabelGroup\", d(\"connectorDataLabelGroup\", e.connectorGroup, this));\n        }, t.prototype.draw = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l = this.getLinkedParent(),\n              s = this.config,\n              c = this.components.data,\n              u = this.getFromEnv(\"dataLabelStyle\"),\n              p = c.length,\n              h = this.components.removeDataArr || [],\n              d = h.length;\n\n          for (this.createContainer(), s.cleared = !1, this.getContainer(\"connectorDataLabelGroup\").css(u), n = 0; n < p; n++) {\n            t = (i = (e = c[n]).config).from, o = i.to, a = l.getNode(t), r = l.getNode(o), a && r && !0 !== i.deleted && this.drawConnector(e, a, r, n);\n          }\n\n          for (this.config.drawn = !0, n = 0; n < d; n++) {\n            this._removeDataVisuals(h.shift());\n          }\n        }, t.prototype.parsePlotAttributes = function (e, t, o) {\n          var a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              d,\n              g,\n              f,\n              m,\n              v = this.getFromEnv(\"number-formatter\"),\n              b = e.config,\n              y = b.eventArgs || (b.eventArgs = {});\n          b.fromPointObj = t, b.toPointObj = o, d = t.config, g = o.config, b.fromX = a = d._xPos, b.fromY = i = d._yPos, b.toX = n = g._xPos, b.toY = l = g._yPos, b._labelX = (a + n) / 2, b._labelY = (i + l) / 2, b.strokeWidth = s = b.conStrength * b.stdThickness, f = b.color, b.textBgColor = f && f.FCcolor && f.FCcolor.color, y.label = b.label, y.arrowAtStart = b.arrowAtStart, y.arrowAtEnd = b.arrowAtEnd, y.link = b.link, y.id = b.id, y.fromNodeId = d.id, y.toNodeId = g.id, b.toolText = (0, r.parseTooltext)(b.toolText, [3, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92], {\n            label: b.label,\n            fromXValue: v.dataLabels(t.config.x),\n            fromYValue: v.dataLabels(t.config.y),\n            fromXDataValue: t.config.x,\n            fromYDataValue: t.config.y,\n            fromLabel: (0, r.pluck)(t.config.displayValue, t.config.id),\n            toXValue: v.dataLabels(o.config.x),\n            toYValue: v.dataLabels(o.config.y),\n            toXDataValue: o.config.x,\n            toYDataValue: o.config.y,\n            toLabel: (0, r.pluck)(o.config.displayValue, o.config.id)\n          }), d = t.config, g = o.config, u = d.startConnectors || (d.startConnectors = {}), p = g.endConnectors || (g.endConnectors = {}), u[m = e.config.id + \"-\" + d.id + \"-\" + g.id] = e, p[m] = e, c = h(e), b.props = {\n            element: {\n              attr: {\n                path: c,\n                \"stroke-width\": s,\n                \"stroke-dasharray\": b.dashStyle,\n                cursor: b.link ? r.POINTER : r.BLANKSTRING,\n                stroke: (0, r.toRaphaelColor)(f)\n              }\n            }\n          };\n        }, t.prototype.allocatePosition = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l = this.getLinkedParent(),\n              s = this.components.data,\n              c = s.length;\n\n          for (e = 0; e < c; e++) {\n            a = (o = (t = s[e]).config).from, r = o.to, n = l.getNode(a), i = l.getNode(r), n && i && !0 !== o.deleted && this.parsePlotAttributes(t, n, i, e);\n          }\n        }, t.prototype.drawConnector = function (e) {\n          var t,\n              o,\n              a = this.getFromEnv(\"toolTipController\"),\n              r = this.getFromEnv(\"animationManager\"),\n              n = e.graphics,\n              i = this.getContainer(\"connectorGroup\"),\n              l = e.config,\n              s = l.toolText,\n              c = l.eventArgs || (l.eventArgs = {}),\n              h = this.config,\n              d = this.components.pool || {};\n          e.removed || (t = o = n.graphic, n.graphic || d.graphic && d.graphic.path && d.graphic.path.length && (o = n.graphic = d.graphic.path.shift()), t = r.setAnimation({\n            el: o || \"path\",\n            container: i,\n            attr: l.props.element.attr,\n            label: \"path\",\n            component: this\n          }), o || (n.graphic = t, t.mousedown(this.mouseDown).mousemove(this.mousemove).mouseup(this.mouseup).hover(this.hoverIn, this.hoverOut)), t.show().data(u, c).data(\"viewMode\", h.viewMode).data(p, l).data(\"dataset\", this), h.showTooltip ? a.enableToolTip(t, s) : a.disableToolTip(t), this.drawLabel(e));\n        }, t.prototype.drawLabel = function (e) {\n          var t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              h,\n              d,\n              g,\n              f = this,\n              m = f.getFromEnv(\"toolTipController\"),\n              v = f.config,\n              b = f.getFromEnv(\"animationManager\"),\n              y = f.getContainer(\"connectorDataLabelGroup\"),\n              x = f.getFromEnv(\"dataLabelStyle\"),\n              w = f.components.data,\n              k = f.components.pool || {},\n              C = w.length,\n              N = function N(e) {\n            t = e.config, a = t.toolText, s = e.graphics, o = t.label, h = t._labelX, d = t._labelY, g = t.textBgColor, o ? (l = s.text = s.text || k.element && k.element.text && k.element.text.shift(), n = {\n              text: o,\n              fill: x.color,\n              direction: r.BLANKSTRING,\n              cursor: t.link ? r.POINTER : r.BLANKSTRING,\n              \"text-bound\": [(0, r.pluck)(x.backgroundColor, g), (0, r.pluck)(x.borderColor, g), 1, \"2\"],\n              x: h,\n              y: d\n            }, (i = b.setAnimation({\n              el: l || \"text\",\n              attr: n,\n              container: y,\n              label: \"text\",\n              component: f\n            })).show(), l || (s.text = i, i.mousedown(f.mouseDown).mousemove(f.mousemove).mouseup(f.mouseup).hover(f.hoverIn, f.hoverOut)), i.data(u, t.eventArgs).data(\"viewMode\", v.viewMode).data(p, t).data(\"dataset\", f), v.showTooltip ? m.enableToolTip(i, a) : m.disableToolTip(i)) : s.text && s.text.hide();\n          };\n\n          if (e) N(e);else for (c = 0; c < C; c++) {\n            N(w[c]);\n          }\n        }, t.prototype.mouseDown = function () {\n          var e = this.data(\"dataset\").getLinkedParent();\n          e.clearLongPress(), this.data(\"fire_click_event\", 1), e.triggerConnectorUI(this);\n        }, t.prototype.mousemove = function () {\n          var e = this.data(\"dataset\").getLinkedParent();\n          this.data(\"fire_click_event\", 0), e.clearLongPress();\n        }, t.prototype.mouseup = function () {\n          this.data(\"dataset\").getLinkedParent().clearLongPress();\n        }, t._drawArrow = function (e, t, o, a, r, n) {\n          var i,\n              l,\n              s,\n              c,\n              u = (t - a) / (e - o),\n              p = Math.atan(u),\n              h = [];\n          return p < 0 && (p = 2 * Math.PI + p), a > t ? (o >= e && p > Math.PI || o < e && p > Math.PI) && (p -= Math.PI) : (o >= e && p < Math.PI && 0 !== p || o < e && p < Math.PI) && (p += Math.PI), void 0 === n ? (i = e + r * Math.cos(p), l = t + r * Math.sin(p)) : (s = Math.abs(r) / 2, c = Math.abs(n) / 2, i = e + (s = e < o ? s : -s), l = t + s * Math.tan(p), Math.abs(t - l) > Math.abs(c) && (l = t + (c = t < a ? c : -c), i = e + c / Math.tan(p))), h.push(\"L\", i, l, i + 10 * Math.cos(p + .79), l + 10 * Math.sin(p + .79), \"M\", i + 10 * Math.cos(p - .79), l + 10 * Math.sin(p - .79), \"L\", i, l), h;\n        }, t.prototype.removeData = function (e, t) {\n          var o = this.components,\n              a = o.data;\n          e < 0 && (e = 0), o.removeDataArr = a.splice(e, t);\n        }, t.prototype.trimData = function (e) {\n          if (this.config.JSONData) {\n            var t = this.components,\n                o = t.data && t.data.length,\n                a = e.connector && e.connector.length || 0,\n                r = o - a;\n            r > 0 && this.removeData(a, r);\n          }\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = g;\n    },\n    548: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.dragNodeConnector\": function initialDatasetDragNodeConnector() {\n          return {\n            \"path.appearing\": function pathAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"text.appearing\": function textAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0,\n                  \"text-bound\": \"none\"\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }];\n            },\n            \"*\": null\n          };\n        }\n      };\n    },\n    549: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(545)),\n          r = o(118),\n          n = o(125),\n          i = l(o(550));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c = r.preDefStr.PX,\n          u = \"rgba(192,192,192,\" + (r.isIE ? .002 : 1e-6) + \")\",\n          p = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return (0, n.addDep)({\n            name: \"draggablelabelAnimation\",\n            type: \"animationRule\",\n            extension: i[\"default\"]\n          }), o;\n        }\n\n        return s(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"dragNodeLabels\";\n        }, t.prototype.configure = function (e) {\n          if (e) this.trimData(e), this.config.JSONData = e.label;else if (!e && !this.config.JSONData) return !1;\n          var t,\n              o = this.getFromEnv(\"chart-attrib\"),\n              a = this.config,\n              n = (this.config.JSONData || []).length,\n              i = this.components.data;\n\n          for (a.viewMode = (0, r.pluckNumber)(o.viewmode, 0), i || (i = this.components.data = []), t = 0; t < n; t++) {\n            this._setConfigure(t);\n          }\n        }, t.prototype._setConfigure = function (e, t) {\n          var o,\n              a,\n              n,\n              i,\n              l = this.config.JSONData,\n              s = t || l[e],\n              u = this.components.data,\n              p = this.getFromEnv(\"style\").inCanvasStyle,\n              h = p.fontSize;\n          !(o = u[e]) && (o = u[e] = {}), !o.graphics && (o.graphics = {}), n = o.config = o.config || (o.config = {}), a = (0, r.parseUnsafeString)((0, r.pluck)(s.text, s.label)), n._options = s, n.add = s.add, a && (n.text = a, n.x = s.x || 0, n.y = s.y || 0, n.labelFontSize = i = (0, r.pluckNumber)(s.fontsize, h), n.labelColor = (0, r.hashify)((0, r.pluck)(s.color, p.color)), n.alpha = (0, r.pluckNumber)(s.alpha, 100) / 100, n.allowDrag = (0, r.pluckNumber)(s.allowdrag, 1), n.padding = (0, r.pluckNumber)(s.padding, 5), s.fontsize ? n.labelCSS = {\n            fontSize: i + c\n          } : n.labelCSS = {}, n.labelBGColor = (0, r.pluck)(s.bgcolor && s.bgcolor.replace(r.dropHash, r.HASHSTRING)), n.labelBDColor = (0, r.pluck)(s.bordercolor && s.bordercolor.replace(r.dropHash, r.HASHSTRING)), n.link = s.link, n.borderThickness = s.borderthickness, n.dashLen = s.dashlen, n.dashGap = s.dashgap, n.dashed = s.dashed, n.radius = s.radius);\n        }, t.prototype.getJSONData = function () {\n          var e,\n              t,\n              o = this.components.data,\n              a = o.length,\n              r = [];\n\n          for (t = 0; t < a; t++) {\n            (e = o[t]).removed || e.config._options && r.push(e.config._options);\n          }\n\n          return r;\n        }, t.prototype.createContainer = function () {\n          var e = this.getFromEnv(\"animationManager\"),\n              t = this.getLinkedParent().getChildContainer();\n          !this.getContainer(\"dragLabelGroup\") && this.addContainer(\"dragLabelGroup\", e.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"dragLabelGroup\"\n            },\n            label: \"group\",\n            component: this,\n            container: t.defaultVcanvasGroup\n          }));\n        }, t.prototype.allocatePosition = function () {\n          this.parsePlotAttributes();\n        }, t.prototype.parsePlotAttributes = function () {\n          var e,\n              t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k = this.components.data,\n              C = this.getFromEnv(\"yAxis\"),\n              N = this.getFromEnv(\"xAxis\"),\n              S = this.getFromEnv(\"smartLabel\"),\n              E = this.getFromEnv(\"dataLabelStyle\"),\n              A = k && k.length,\n              D = this.getFromEnv(\"chartConfig\");\n\n          for (x = 0; x < A; x++) {\n            (d = k[x]).removed || (p = d.config, !d.graphics && (d.graphics = {}), p.index = x, a = N.getPixel(p.x), n = C.getPixel(p.y), l = p.text, s = p.labelBGColor, c = p.labelBDColor, u = p.padding, g = p.allowDrag, f = p.labelFontSize, i = p.labelColor, m = p.radius, o = p.dashed, b = p.borderThickness, e = p.dashLen, t = p.dashGap, b = p.borderThickness, w = p.labelCSS, h = {\n              x: a,\n              y: n,\n              text: l,\n              align: r.POSITION_CENTER,\n              fill: i,\n              \"text-bound\": [s || r.BLANKSTRING, c || r.BLANKSTRING, (0, r.pluckNumber)(b, 1), u, (0, r.pluckNumber)(m, 0), (0, r.pluckNumber)(o, 0) ? (0, r.getDashStyle)((0, r.pluckNumber)(e, 5), (0, r.pluckNumber)(t, 4)) : r.DASH_DEF],\n              visibility: r.visibleStr\n            }, y = {\n              backgroundColor: s,\n              borderColor: c,\n              borderPadding: u,\n              fontSize: f + r.PXSTRING,\n              fontStyle: E.fontStyle,\n              fontWeight: E.fontWeight,\n              borderRadius: 0,\n              borderDash: r.DASH_DEF,\n              fontFamily: E.fontFamily\n            }, (0, r.setLineHeight)(y), S.useEllipsesOnOverflow(D.useEllipsesWhenOverflow), S.setStyle(y), w[\"line-height\"] = y.lineHeight, p.eventArgs = {\n              link: p.link,\n              text: l,\n              x: a,\n              y: n,\n              allowdrag: g,\n              sourceType: \"labelnode\"\n            }, p.props = {\n              element: {\n                attr: h\n              }\n            }, p.labelCSSApplied = w, v = S.getOriSize(l), p.width = v.width, p.height = v.height, p.xPos = a, p.yPos = n);\n          }\n        }, t.prototype.draw = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i = this.components.data,\n              l = this.getFromEnv(\"animationManager\"),\n              s = this.getFromEnv(\"dataLabelStyle\"),\n              c = i && i.length,\n              u = this.components.removeDataArr || [],\n              p = u.length;\n\n          for (this.createContainer(), (n = this.getContainer(\"dragLabelGroup\")).css({\n            \"font-weight\": s.fontWeight,\n            \"font-style\": s.fontStyle,\n            \"font-size\": s.fontSize,\n            \"font-family\": s.fontFamily\n          }), r = 0; r < c; r++) {\n            (t = i[r]).removed || (e = t.config, a = t.graphics.element, o = l.setAnimation({\n              el: a || \"text\",\n              container: n,\n              css: e.labelCSS,\n              attr: e.props.element.attr,\n              component: this\n            }), a ? (e.labelCSSApplied && o.removeCSS(), o.show().css(e.labelCSS)) : t.graphics.element = o, o.data(\"eventArgs\", e.eventArgs));\n          }\n\n          for (this.drawTracker(), r = 0; r < p; r++) {\n            this._removeDataVisuals(u.shift());\n          }\n        }, t.prototype.drawTracker = function () {\n          var e,\n              t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m = this,\n              v = m.components.data,\n              b = m.getFromEnv(\"animationManager\"),\n              y = m.getFromEnv(\"chart\"),\n              x = m.getLinkedParent(),\n              w = m.config,\n              k = m.getContainer(\"dragLabelGroup\"),\n              C = v && v.length,\n              N = function N() {\n            var e = this.data(\"drag-options\"),\n                t = e.dataset,\n                o = e.index,\n                a = t.components.data[o];\n            this.data(\"fire_click_event\", 1), x.clearLongPress(), x.triggerLabelUI(this, a);\n          },\n              S = function S() {\n            this.data(\"fire_click_event\") && (this.data(\"fire_click_event\", 0), x.clearLongPress());\n          },\n              E = function E(e) {\n            var t = this.data(\"fire_click_event\");\n            x.clearLongPress(), t && y.plotEventHandler(this, e, \"LabelClick\");\n          },\n              A = function A(e) {\n            y.plotEventHandler(this, e, \"LabelRollover\");\n          },\n              D = function D(e) {\n            y.plotEventHandler(this, e, \"LabelRollout\");\n          },\n              T = function T(e, t) {\n            m._labelDragMove.call(this, e, t, y);\n          },\n              L = function L(e) {\n            m._labelDragStart.call(this, e, y);\n          },\n              _ = function _(e) {\n            m._labelDragUp.call(this, e);\n          };\n\n          for (f = 0; f < C; f++) {\n            (e = v[f]).removed || (o = (t = e.config).padding || 0, d = t.width, g = t.height, p = t.xPos - d / 2, h = t.yPos - g / 2, i = t.allowDrag, l = t.text, c = e.graphics.trackerElement, n = {\n              x: p - o,\n              y: h - o,\n              width: d + 2 * o,\n              height: g + 2 * o,\n              cursor: t.allowDrag ? \"move\" : r.BLANKSTRING,\n              fill: u,\n              stroke: u\n            }, a = {\n              link: t.link,\n              text: l,\n              x: p,\n              y: h,\n              allowdrag: i,\n              sourceType: \"labelnode\"\n            }, s = b.setAnimation({\n              el: c || \"rect\",\n              container: k,\n              attr: n,\n              component: m\n            }), c || (e.graphics.trackerElement = s, s.mousedown(N).mousemove(S).mouseup(E).data(\"viewMode\", w.viewMode).data(r.preDefStr.EVENTARGS, a).hover(A, D), t.allowDrag && s.drag(T, L, _)), s.data(\"drag-options\", {\n              index: f,\n              dataset: m\n            }));\n          }\n        }, t.prototype._labelDragStart = function () {\n          var e = this.getBBox(),\n              t = this.data(\"drag-options\"),\n              o = t.dataset,\n              a = o.getLinkedParent(),\n              r = t.index,\n              n = o.components.data[r],\n              i = n.graphics.element,\n              l = n.dragStart = n.dragStart || (n.dragStart = {});\n          t.ox = i.attr(\"x\"), t.oy = i.attr(\"y\"), t.bBox = e, l.xPos = n.config.xPos, l.yPos = n.config.yPos, l.bBox = e, this.data(\"fire_click_event\", 1), this.data(\"fire_dragend\", 0), a.clearLongPress(), a.triggerLabelUI(this, n);\n        }, t.prototype._labelDragMove = function (e, t) {\n          var o,\n              a,\n              r = this.data(\"drag-options\"),\n              n = r.index,\n              i = r.dataset,\n              l = i.getFromEnv(\"chart\"),\n              s = i.getFromEnv(\"chartConfig\"),\n              c = s.canvasLeft,\n              u = s.canvasRight,\n              p = s.canvasBottom,\n              h = s.canvasTop,\n              d = i.getLinkedParent(),\n              g = i.components.data[n],\n              f = g.graphics.element,\n              m = g.dragStart,\n              v = m.bBox,\n              b = t[0],\n              y = t[1],\n              x = m.bBox.x + b,\n              w = m.bBox.x2 + b,\n              k = m.bBox.y + y,\n              C = m.bBox.y2 + y,\n              N = i.getFromEnv(\"yAxis\"),\n              S = i.getFromEnv(\"xAxis\");\n          x < c && (b += c - x), w > u && (b -= w - u), k < h && (y += h - k), C > p && (y -= C - p), m.draged = !0, this.attr({\n            x: v.x + b,\n            y: v.y + y\n          }), o = r.ox + b, a = r.oy + y, f.attr({\n            x: r.ox + b,\n            y: r.oy + y\n          }), g.config.x = S.getValue(o), g.config.y = N.getValue(a), this.data(\"fire_dragend\") || (l.plotEventHandler(this, e, \"LabelDragStart\"), this.data(\"fire_dragend\", 1)), this.data(\"fire_click_event\") && (this.data(\"fire_click_event\", 0), d.clearLongPress());\n        }, t.prototype._labelDragUp = function (e) {\n          var t = this.data(\"drag-options\"),\n              o = t.index,\n              a = t.dataset,\n              n = a.getFromEnv(\"chart\"),\n              i = n.getChildren(\"xAxis\")[0],\n              l = n.getChildren(\"yAxis\")[0],\n              s = a.getLinkedParent(),\n              c = a.components.data[o].dragStart,\n              u = this.data(\"eventArgs\");\n          u.x = i.getValue(this.attr(\"x\")), u.y = l.getValue(this.attr(\"y\")), c.draged = !1, this.data(\"fire_dragend\") && (n.fireChartInstanceEvent(\"chartupdated\", (0, r.extend2)({\n            sourceEvent: \"labeldragend\"\n          }, u), e), n.fireChartInstanceEvent(\"chartupdated\", u, e), n.plotEventHandler(this, e, \"labeldragend\")), s.clearLongPress();\n        }, t.prototype.removeData = function (e, t) {\n          var o = this.components,\n              a = o.data;\n          o.removeDataArr = a.splice(e, t);\n        }, t.prototype.trimData = function (e) {\n          if (this.config.JSONData) {\n            var t = this.config.JSONData,\n                o = t && t.length,\n                a = e.label && e.label.length || 0,\n                r = o - a;\n            r > 0 && this.removeData(a, r);\n          }\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = p;\n    },\n    550: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.dragNodeLabels\": function initialDatasetDragNodeLabels() {\n          return {\n            \"group.appearing\": function groupAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"plot\"\n              }];\n            }\n          };\n        }\n      };\n    },\n    551: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(131)),\n          r = l(o(549)),\n          n = o(118),\n          i = o(122);\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c,\n          u,\n          p,\n          h = {\n        circle: \"circ\",\n        rectangle: \"rect\",\n        polygon: \"poly\"\n      },\n          d = void 0,\n          g = n.preDefStr.INPUT,\n          f = n.preDefStr.BLANKSPACE,\n          m = n.preDefStr.BLANK,\n          v = n.preDefStr.PX,\n          b = n.preDefStr.LABEL,\n          y = n.preDefStr.DATASET,\n          x = n.preDefStr.COMMA,\n          w = \"appearing\",\n          k = function k(e) {\n        return e !== d && null !== e;\n      },\n          C = function C(e, t) {\n        switch (e.shape) {\n          case n.preDefStr.CIRCLE:\n            e.radius = t.radius;\n            break;\n\n          case n.preDefStr.POLYGON:\n            e.radius = t.radius, e.sides = t.numsides;\n            break;\n\n          default:\n            e.width = t.width, e.height = t.height;\n        }\n      },\n          N = (c = function c() {\n        for (var e, t = this.getGraphicalElement(\"cacheUpdateUI\"), o = t.fields.shape, a = [\"rectWidth\", \"rectHeight\", \"circPolyRadius\", \"polySides\"], r = a.length; r--;) {\n          /rect|poly|circ/gi.test(e = a[r]) && (t.labels[e].hide(), t.fields[e].hide()), new RegExp((0, n.pluck)(o.val(), \"rect\"), \"ig\").test(e) && (t.labels[e].show(), t.fields[e].show());\n        }\n      }, u = function u() {\n        var e = this.getGraphicalElement(\"cacheUpdateUI\").fields,\n            t = (0, i.getValidColor)(e.color.val());\n        t && e.colorOut.css({\n          background: (0, i.parseColor)(t)\n        });\n      }, p = function p(e) {\n        var t,\n            o,\n            a,\n            r = this.getGraphicalElement(\"cacheUpdateUI\"),\n            n = this.getFromEnv(\"animationManager\"),\n            i = r.fields.image,\n            l = this.getFromEnv(\"chartConfig\").height,\n            s = i.val(),\n            c = [\"imgWidth\", \"imgHeight\", \"imgAlign\", \"imgUrl\"];\n\n        for (t = s ? 250 : 215, e && (r.ok.hide(), r.cancel.hide(), r.removeItem.hide(), r.error.hide()), o = c.length; !s && o--;) {\n          a = c[o], r.labels[a].hide(), r.fields[a].hide();\n        }\n\n        e && n.setAnimationState(\"uichange\"), n.setAnimation({\n          el: r.dialog,\n          state: \"updating\",\n          attr: {\n            top: (l - t) / 2,\n            height: t\n          },\n          component: this,\n          label: \"uidialog\",\n          callback: function callback() {\n            for (o = c.length; o-- && s;) {\n              a = c[o], r.labels[a].show(), r.fields[a].show();\n            }\n\n            r.ok.attr({\n              y: t - 23 - 5\n            }).show(), r.cancel.attr({\n              y: t - 23 - 5\n            }).show(), r.removeItem.attr({\n              y: t - 23 - 5\n            }), r.error.attr({\n              y: t - 23 - 5 + 4\n            }).show(), r.edit ? r.removeItem.show() : r.removeItem.hide();\n          }\n        });\n      }, function (e, t) {\n        var o,\n            a,\n            r = this,\n            i = r.getGraphicalElement(\"cacheUpdateUI\"),\n            l = r.getFromEnv(\"style\").inCanvasStyle || {},\n            s = r.getFromEnv(\"paper\"),\n            h = {\n          width: 80 + v,\n          border: \"1px solid #cccccc\",\n          fontSize: 10 + v,\n          lineHeight: 15 + v,\n          padding: 2 + v,\n          fontFamily: l.fontFamily\n        },\n            g = {\n          textAlign: \"right\"\n        },\n            f = i && i.fields,\n            y = i && i.labels;\n        r.getFromEnv(\"animationManager\").setAnimationState(\"uichange\"), i || (o = !0), i = r.addGraphicalElement(\"cacheUpdateUI\", r.createHtmlDialog(350, 215, function (e) {\n          e.stopPropagation();\n          var t,\n              o,\n              a,\n              l,\n              s,\n              c = i && i.fields,\n              u = i.edit,\n              p = c.shape.val();\n\n          if (t = r.getFromEnv(\"xAxis\").getLimit().min, o = r.getFromEnv(\"yAxis\").getLimit().min, c) {\n            switch (s = {\n              x: (0, n.getFirstValue)(c.x.val(), t),\n              y: (0, n.getFirstValue)(c.y.val(), o),\n              id: l = c.id.val(),\n              datasetId: c.dataset.val(),\n              name: c.label.val(),\n              tooltext: c.tooltip.val(),\n              color: c.color.val(),\n              alpha: c.alpha.val(),\n              labelalign: c.labelalign.val(),\n              allowdrag: c.draggable.val(),\n              imagenode: c.image.val(),\n              imagewidth: c.imgWidth.val(),\n              imageheight: c.imgHeight.val(),\n              imagealign: c.imgAlign.val(),\n              imageurl: c.imgUrl.val(),\n              link: c.link.val()\n            }, p) {\n              case \"circ\":\n                s.shape = n.preDefStr.CIRCLE, s.radius = c.circPolyRadius.val();\n                break;\n\n              case \"poly\":\n                s.shape = n.preDefStr.POLYGON, s.radius = c.circPolyRadius.val(), s.numsides = c.polySides.val();\n                break;\n\n              default:\n                s.shape = n.preDefStr.RECTANGLE, s.width = c.rectWidth.val(), s.height = c.rectHeight.val();\n            }\n\n            if (r.getNode(s.id) && (a = !0), !a || u !== d) return void (((l = s.datasetId) !== n.BLANKSTRING || u) && (l = Number(l), u ? r.updateNode(s) : r.addNode(s), i.hide(), i.visible = !1));\n            i.error.attr({\n              text: \"ID already exist.\"\n            }), c.label.focus();\n          }\n\n          i.enableFields();\n        }, function (e) {\n          e.stopPropagation(), i.hide(), i.visible = !1, i.enableFields(), i.error.attr({\n            text: m\n          }), i.visible = !1;\n        }, function (e) {\n          e.stopPropagation(), r.deleteNode(i.fields.id.val()), i.hide(), i.visible = !1;\n        }, i)), o && (a = i.dialog, y = i.labels = {}, f = i.fields = {}), i.config = e, i.edit = t, i.error || (i.error = s.html(\"span\", {\n          color: \"ff0000\",\n          x: 30,\n          y: 228\n        }, d, a)), i.enableFields || (i.enableFields = function () {\n          var t;\n\n          for (t in e) {\n            e[t] && e[t].disabled && f[t] && f[t].element.removeAttribute(\"disabled\");\n          }\n        }), i.clearFields || (i.clearFields = function () {\n          var e,\n              t = i.fields;\n\n          for (e in t) {\n            t[e].element.disabled || (t[e].element.value = n.BLANKSTRING);\n          }\n        }), (0, n.fcEach)(this.nodeUpdateUIDefinition, function (t) {\n          var o,\n              l,\n              d,\n              v = t.key,\n              x = {},\n              w = e[v] || {};\n          !y[v] && (y[v] = s.html(b, {\n            x: t.x,\n            y: t.y,\n            width: t.labelWidth || 45,\n            text: t.text\n          }, g, a)), t.noInput || ((o = f[v]) || (h.border = \"checkbox\" == t.type ? m : \"1px solid #cccccc\", o = f[v] = s.html(t.inputType || \"input\", {\n            x: t.labelWidth && t.labelWidth + 5 || 50,\n            y: -2 + (t.inputPaddingTop || 0),\n            width: t.inputWidth || 50,\n            name: v || n.BLANKSTRING\n          }, h), \"select\" !== t.inputType && o.attr({\n            type: t.type || \"text\"\n          }).on(\"keyup\", i.handleKeyPress), o.add(y[v])), k(l = (0, n.getFirstValue)(w.innerHTML, t.innerHTML)) && (x.innerHTML = l), w.disabled ? x.disabled = \"disabled\" : o.element && (o.element.disabled = !1), o.attr(x), k(d = (0, n.getFirstValue)(w.value, t.value)) && o.val(d), \"shape\" === v && o.on(\"change\", function () {\n            c.call(r);\n          }), \"image\" === v && o.on(\"click\", function () {\n            p.call(r, !0);\n          }), \"color\" === v && o.on(\"keyup\", function () {\n            u.call(r);\n          }));\n        }), u.call(this), p.call(this), c.call(this), i.visible = !0, i.fields[t ? b : \"id\"].focus();\n      }),\n          S = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this)),\n              a = o;\n\n          return a.setState(\"visible\", !0), a.connectorUpdateUIDefinition = [{\n            key: \"fromid\",\n            text: \"Connect From\",\n            inputType: \"select\",\n            x: 10,\n            y: 15,\n            labelWidth: 80,\n            inputWidth: 100\n          }, {\n            key: \"toid\",\n            text: \"Connect To\",\n            inputType: \"select\",\n            x: 10,\n            y: 40,\n            labelWidth: 80,\n            inputWidth: 100\n          }, {\n            key: \"arratstart\",\n            text: \"Arrow At Start\",\n            x: 200,\n            y: 15,\n            type: \"checkbox\",\n            inputPaddingTop: 3,\n            labelWidth: 80,\n            inputWidth: 15\n          }, {\n            key: \"arratend\",\n            text: \"Arrow At End\",\n            x: 200,\n            y: 40,\n            type: \"checkbox\",\n            inputPaddingTop: 3,\n            labelWidth: 80,\n            inputWidth: 15\n          }, {\n            key: b,\n            text: \"Label\",\n            x: 10,\n            y: 75,\n            labelWidth: 40,\n            inputWidth: 120\n          }, {\n            key: \"id\",\n            text: \"Node ID\",\n            x: 190,\n            y: 75,\n            inputWidth: 55\n          }, {\n            key: \"color\",\n            text: \"Color\",\n            x: 10,\n            y: 100,\n            labelWidth: 40,\n            inputWidth: 35\n          }, {\n            key: \"alpha\",\n            text: \"Alpha\",\n            x: 110,\n            y: 100,\n            inputWidth: 25,\n            labelWidth: 35\n          }, {\n            key: \"strength\",\n            text: \"Strength\",\n            x: 190,\n            y: 100,\n            inputWidth: 55,\n            val: \"0.1\"\n          }, {\n            key: \"url\",\n            text: \"Link\",\n            x: 10,\n            y: 125,\n            labelWidth: 40,\n            inputWidth: 120\n          }, {\n            key: \"tooltext\",\n            text: \"Tooltip\",\n            x: 190,\n            y: 125,\n            labelWidth: 40,\n            inputWidth: 60\n          }, {\n            key: \"dashed\",\n            text: \"Dashed\",\n            x: 10,\n            y: 150,\n            type: \"checkbox\",\n            inputPaddingTop: 3,\n            inputWidth: 15,\n            labelWidth: 40\n          }, {\n            key: \"dashgap\",\n            text: \"Dash Gap\",\n            x: 85,\n            y: 150,\n            labelWidth: 60,\n            inputWidth: 25\n          }, {\n            key: \"dashlen\",\n            text: \"Dash Length\",\n            x: 190,\n            y: 150,\n            labelWidth: 70,\n            inputWidth: 30\n          }], a.nodeUpdateUIDefinition = [{\n            key: \"id\",\n            text: \"Id\",\n            inputWidth: 60,\n            x: 10,\n            y: 15\n          }, {\n            key: y,\n            text: y,\n            inputType: \"select\",\n            inputWidth: 110,\n            innerHTML: d,\n            x: 170,\n            y: 15\n          }, {\n            key: \"x\",\n            text: \"Value\",\n            x: 10,\n            y: 40,\n            inputWidth: 21\n          }, {\n            key: \"y\",\n            text: x,\n            x: 88,\n            y: 40,\n            inputWidth: 21,\n            labelWidth: 5\n          }, {\n            text: \"(x, y)\",\n            x: 125,\n            y: 40,\n            labelWidth: 33,\n            noInput: !0\n          }, {\n            key: \"tooltip\",\n            text: \"Tooltip\",\n            inputWidth: 105,\n            x: 170,\n            y: 40\n          }, {\n            key: b,\n            text: \"Label\",\n            inputWidth: 92,\n            x: 10,\n            y: 65\n          }, {\n            key: \"labelalign\",\n            text: \"Align\",\n            labelWidth: 70,\n            inputWidth: 110,\n            inputType: \"select\",\n            innerHTML: '<option></option><option value=\"top\">Top</option><option value=\"middle\">Middle</option><option value=\"bottom\">Bottom</option>',\n            x: 145,\n            y: 63\n          }, {\n            key: \"color\",\n            text: \"Color\",\n            x: 10,\n            y: 90,\n            inputWidth: 60\n          }, {\n            key: \"colorOut\",\n            innerHTML: \"&nbsp;\",\n            x: 85,\n            y: 90,\n            inputWidth: 15,\n            inputType: \"span\"\n          }, {\n            key: \"alpha\",\n            text: \"Alpha\",\n            x: 170,\n            y: 90,\n            inputWidth: 20\n          }, {\n            key: \"draggable\",\n            text: \"Allow Drag\",\n            value: !0,\n            inputWidth: 20,\n            x: 250,\n            y: 90,\n            labelWidth: 58,\n            inputPaddingTop: 3,\n            type: \"checkbox\"\n          }, {\n            key: \"shape\",\n            text: \"Shape\",\n            inputType: \"select\",\n            inputWidth: 97,\n            innerHTML: '<option value=\"rect\">Rectangle</option><option value=\"circ\">Circle</option><option value=\"poly\">Polygon</option>',\n            x: 10,\n            y: 115\n          }, {\n            key: \"rectHeight\",\n            text: \"Height\",\n            x: 170,\n            y: 115,\n            inputWidth: 20\n          }, {\n            key: \"rectWidth\",\n            text: \"Width\",\n            x: 255,\n            y: 115,\n            inputWidth: 20\n          }, {\n            key: \"circPolyRadius\",\n            text: \"Radius\",\n            x: 170,\n            y: 115,\n            inputWidth: 20\n          }, {\n            key: \"polySides\",\n            text: \"Sides\",\n            x: 255,\n            y: 115,\n            inputWidth: 20\n          }, {\n            key: \"link\",\n            text: \"Link\",\n            x: 10,\n            y: 140,\n            inputWidth: 92\n          }, {\n            key: \"image\",\n            text: \"Image\",\n            type: \"checkbox\",\n            inputPaddingTop: 4,\n            inputWidth: 20,\n            x: 10,\n            y: 170\n          }, {\n            key: \"imgUrl\",\n            text: \"URL\",\n            inputWidth: 105,\n            x: 170,\n            y: 170\n          }, {\n            key: \"imgWidth\",\n            text: \"Width\",\n            inputWidth: 20,\n            x: 10,\n            y: 195\n          }, {\n            key: \"imgHeight\",\n            text: \"Height\",\n            inputWidth: 20,\n            x: 82,\n            y: 195\n          }, {\n            key: \"imgAlign\",\n            text: \"Align\",\n            inputType: \"select\",\n            inputWidth: 75,\n            innerHTML: '<option value=\"top\">Top</option><option value=\"middle\">Middle</option><option value=\"bottom\">Bottom</option>',\n            x: 170,\n            y: 195\n          }], a.labelUpdateUIDefinition = [{\n            key: b,\n            text: \"Label*\",\n            x: 10,\n            y: 15,\n            inputWidth: 235\n          }, {\n            key: \"size\",\n            text: \"Size\",\n            x: 10,\n            y: 40\n          }, {\n            key: \"padding\",\n            text: \"Padding\",\n            x: 10,\n            y: 65\n          }, {\n            key: \"x\",\n            text: \"Position\",\n            x: 120,\n            y: 65,\n            labelWidth: 70,\n            inputWidth: 25\n          }, {\n            key: \"y\",\n            text: x,\n            x: 225,\n            y: 65,\n            labelWidth: 10,\n            inputWidth: 25\n          }, {\n            key: \"xy\",\n            text: \"(x, y)\",\n            x: 260,\n            y: 65,\n            noInput: !0\n          }, {\n            key: \"allowdrag\",\n            text: \"Allow Drag\",\n            x: 120,\n            y: 40,\n            inputType: \"checkbox\",\n            inputPaddingTop: 3,\n            inputWidth: 15,\n            labelWidth: 70,\n            val: 1\n          }, {\n            key: \"color\",\n            text: \"Color\",\n            x: 10,\n            y: 90\n          }, {\n            key: \"alpha\",\n            text: \"Alpha\",\n            x: 145,\n            y: 90,\n            inputWidth: 30,\n            val: n.preDefStr.HUNDREDSTRING\n          }, {\n            key: \"bordercolor\",\n            text: \"Border Color\",\n            x: 10,\n            y: 125,\n            labelWidth: 100\n          }, {\n            key: \"bgcolor\",\n            text: \"Background Color\",\n            x: 10,\n            y: 150,\n            labelWidth: 100\n          }], o;\n        }\n\n        return s(t, e), t.prototype.configure = function () {\n          this.setState(\"configured\", !0);\n        }, t.prototype.getType = function () {\n          return \"group\";\n        }, t.prototype.getName = function () {\n          return \"dragNodeGroup\";\n        }, t.prototype.showLabelUpdateUI = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n              i = this,\n              l = i.getFromEnv(\"paper\"),\n              s = i.getFromEnv(\"style\").inCanvasStyle || {},\n              c = i.getGraphicalElement(\"cacheLabelUpdateUI\"),\n              u = {\n            border: \"1px solid #cccccc\",\n            fontSize: 10 + v,\n            lineHeight: 15 + v,\n            fontFamily: s.fontFamily,\n            padding: 2 + v\n          },\n              p = {\n            textAlign: \"right\"\n          },\n              h = c && c.fields,\n              f = c && c.labels;\n          i.getFromEnv(\"animationManager\").setAnimationState(\"uichange\"), c || (e = !0), c = i.addGraphicalElement(\"cacheLabelUpdateUI\", i.createHtmlDialog(315, 205, function () {\n            var e,\n                t = c && c.fields;\n            t && ((e = {\n              text: t.label.val(),\n              x: t.x.val(),\n              y: t.y.val(),\n              color: t.color.val(),\n              alpha: t.alpha.val(),\n              bgcolor: t.bgcolor.val(),\n              bordercolor: t.bordercolor.val(),\n              fontsize: t.size.val(),\n              allowdrag: t.allowdrag.val(),\n              padding: t.padding.val()\n            }).text ? (i.addLabel && i.addLabel(e), c.hide()) : (c.error.attr({\n              text: \"Label cannot be blank.\"\n            }), t.label.focus()));\n          }, function () {\n            c.error.attr({\n              text: n.BLANKSTRING\n            }), c.hide();\n          }, d, c)), e && (a = c.dialog, f = c.labels = {}, h = c.fields = {}), (0, n.fcEach)(i.labelUpdateUIDefinition, function (e) {\n            var i = e.key;\n            f[i] || (f[i] = l.html(b, {\n              x: e.x,\n              y: e.y,\n              width: e.labelWidth || 45,\n              text: e.text\n            }, p, a)), e.noInput || ((t = h[i]) || (t = h[i] = l.html(g, {\n              y: -2 + (e.inputPaddingTop || 0),\n              x: e.labelWidth && e.labelWidth + 5 || 50,\n              width: e.inputWidth || 50,\n              type: e.inputType || \"text\",\n              name: i || n.BLANKSTRING\n            }, u, f[i]).on(\"keyup\", c.handleKeyPress)), k(o = (0, n.getFirstValue)(r[i], e.val)) && t.val(o));\n          }), c.error || (c.error = l.html(\"span\", {\n            color: \"ff0000\",\n            x: 10,\n            y: 180\n          }, d, a)), c.fields.label.focus();\n        }, t.prototype.restoreData = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s = this.getChildren(\"dataset\"),\n              c = this.getFromEnv(\"chart\"),\n              u = this.getFromEnv(\"legend\"),\n              p = (0, n.pluckNumber)(c.config.showlegend, 0),\n              h = this.getChildren(\"connector\"),\n              d = c.getFromEnv(\"dataSource\"),\n              g = d.dataset,\n              f = d.connectors,\n              m = d.labels,\n              v = this.getChildren(\"labels\"),\n              b = function b(e) {\n            var t, o;\n\n            for (t = 0; t < (e && e.length); t++) {\n              if (delete (a = e[t]).removed, a.config.add) {\n                for (o in r = e[t].graphics) {\n                  r[o].remove();\n                }\n\n                e.splice(t, 1), t--;\n              }\n            }\n          },\n              y = function y(e, a, r) {\n            t = a[e], o = t.components.data, b(o), t.drawn = !1, t.configure(r[e]);\n          };\n\n          for (e = 0, l = s && s.length; e < l; e++) {\n            y(e, s, g);\n          }\n\n          for (e = 0, l = h && h.length; e < l; e++) {\n            y(e, h, f);\n          }\n\n          v && v.length && (i = v[0], (o = i.components.data) && b(o), i.configure(m)), c.fireChartInstanceEvent(\"dataRestored\"), this.asyncDraw(), p && u.asyncDraw();\n        }, t.prototype.addLabel = function (e) {\n          var t,\n              o,\n              a = this.getChildren(\"labels\"),\n              i = this.getFromEnv(\"chart\");\n          e.add = !0, a ? a = a[0] : ((0, n.componentFactory)(this, r[\"default\"], \"labels\", 1, [{}]), a = this.getChildren(\"labels\")[0]), o = (a.components.data || (a.components.data = [])).length, a._setConfigure(o, e), t = {\n            text: e.text,\n            x: e.x,\n            y: e.y,\n            allowdrag: e.allowdrag,\n            sourceType: \"labelnode\",\n            link: e.link\n          }, i.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n            sourceEvent: \"labeladded\"\n          }, t)), i.fireChartInstanceEvent(\"labeladded\", t), a.asyncDraw();\n        }, t.prototype.showNodeAddUI = function () {\n          var e,\n              t,\n              o,\n              a = this.getChildren(\"dataset\"),\n              r = n.BLANKSTRING;\n\n          for (o = 0; o < a.length; o++) {\n            e = (t = a[o] || {}).config, \"dragNode\" === t.getName() && (r += '<option value=\"' + t.config.datasetIndex + '\">' + (e.name !== m && e.name !== d && e.name + n.COMMASTRING + f || m) + t.config.datasetIndex + \"</option>\");\n          }\n\n          this.showNodeUpdateUI({\n            dataset: {\n              innerHTML: r\n            }\n          });\n        }, t.prototype.showConnectorAddUI = function () {\n          var e,\n              t,\n              o = this.getNode(),\n              a = n.BLANKSTRING;\n\n          for (t in o) {\n            a += '<option value=\"' + (e = o[t].config.id) + '\">' + e + \"</option>\";\n          }\n\n          this.showConnectorUpdateUI({\n            fromid: {\n              innerHTML: a\n            },\n            toid: {\n              innerHTML: a\n            }\n          });\n        }, t.prototype.showConnectorUpdateUI = function (e, t) {\n          var o,\n              a,\n              r,\n              i,\n              l,\n              s = this,\n              c = s.getFromEnv(\"paper\"),\n              u = s.getFromEnv(\"style\").inCanvasStyle || {},\n              p = \"cacheConnectorUpdateUI\" + (t ? \"edit\" : \"new\"),\n              h = s.getGraphicalElement(p),\n              f = {\n            border: \"1px solid #cccccc\",\n            fontSize: 10 + v,\n            lineHeight: 15 + v,\n            fontFamily: u.fontFamily,\n            padding: 2 + v\n          },\n              m = {\n            textAlign: \"right\"\n          },\n              y = h && h.fields,\n              x = h && h.labels;\n          s.getFromEnv(\"animationManager\").setAnimationState(\"uichange\"), h || (o = !0), h = s.addGraphicalElement(p, s.createHtmlDialog(315, 215, function () {\n            var e,\n                o = h && h.fields;\n            o && ((e = {\n              from: o.fromid.val(),\n              to: o.toid.val(),\n              id: o.id.val(),\n              label: o.label.val(),\n              color: o.color.val(),\n              alpha: o.alpha.val(),\n              link: o.url.val(),\n              tooltext: o.tooltext.val(),\n              strength: o.strength.val(),\n              arrowatstart: o.arratstart.val(),\n              arrowatend: o.arratend.val(),\n              dashed: o.dashed.val(),\n              dashlen: o.dashlen.val(),\n              dashgap: o.dashgap.val()\n            }).from ? e.to ? e.from != e.to ? (t ? s.editConnector(e) : s.addConnector(e), h.enableFields(), h.hide(), h.clearFields()) : (h.error.attr({\n              text: \"Connector cannot start and end at the same node!\"\n            }), o.fromid.focus()) : (h.error.attr({\n              text: \"Please select a valid connector end.\"\n            }), o.toid.focus()) : (h.error.attr({\n              text: \"Please select a valid connector start.\"\n            }), o.fromid.focus()));\n          }, function () {\n            h.error.attr({\n              text: n.BLANKSTRING\n            }), h.enableFields(), h.hide();\n          }, function () {\n            var e = h && h.fields,\n                t = {\n              from: e.fromid.val(),\n              to: e.toid.val(),\n              id: e.id.val()\n            };\n            s.deleteConnector(t), h.hide();\n          }, h)), o && (l = h.dialog, x = h.labels = {}, y = h.fields = {}), h.config = e, h.enableFields || (h.enableFields = function () {\n            var t;\n\n            for (t in e) {\n              e[t] && e[t].disabled && y[t] && y[t].element.removeAttribute(\"disabled\");\n            }\n          }), h.clearFields || (h.clearFields = function () {\n            var e,\n                t = h.fields;\n\n            for (e in t) {\n              t[e].element.disabled || (t[e].element.value = n.BLANKSTRING);\n            }\n          }), (0, n.fcEach)(s.connectorUpdateUIDefinition, function (t) {\n            var o = t.key,\n                s = e[o] || {};\n            x[o] || (x[o] = c.html(b, {\n              x: t.x,\n              y: t.y,\n              width: t.labelWidth || 45,\n              text: t.text\n            }, m, l)), t.noInput || ((r = y[o]) || (r = y[o] = c.html(t.inputType || g, {\n              y: -2 + (t.inputPaddingTop || 0),\n              x: t.labelWidth && t.labelWidth + 5 || 50,\n              width: t.inputWidth || 50,\n              name: o || n.BLANKSTRING\n            }, f), \"select\" !== t.inputType && r.attr({\n              type: t.type || \"text\"\n            }).on(\"keyup\", h.handleKeyPress), r.add(x[o])), (a = (0, n.pluck)(s.innerHTML, t.innerHTML)) && r.attr({\n              innerHTML: a\n            }), (i = (0, n.pluck)(s.val, t.val)) !== d && r.val(i), s.disabled ? r.attr({\n              disabled: \"disabled\"\n            }) : r.element && (r.element.disabled = !1));\n          }), h.checkDash = function () {\n            var e = y.dashed && y.dashed.val() ? \"show\" : \"hide\";\n            x.dashgap && x.dashgap[e](), y.dashgap && y.dashgap[e](), x.dashlen && x.dashlen[e](), y.dashlen && y.dashlen[e]();\n          }, h.checkDash(), y.dashed.on(\"click\", h.checkDash), h.error || (h.error = c.html(\"span\", {\n            color: \"ff0000\",\n            x: 10,\n            y: 170\n          }, d, l)), h.removeItem[t ? \"show\" : \"hide\"]();\n        }, t.prototype.showNodeUpdateUI = function () {\n          return N.apply(this, arguments);\n        }, t.prototype.addNode = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c = this.getChildren(\"dataset\"),\n              u = e.datasetId,\n              p = c.length,\n              h = this.getFromEnv(\"chart\");\n\n          for (i = 0; i < p; i++) {\n            if ((r = (t = c[i] || {}).config.datasetIndex) !== d && (r = r.toString()), r === u) {\n              a = !0;\n              break;\n            }\n          }\n\n          t && a && (s = t.components.data, e.add = !0, l = {\n            index: o = s.length,\n            dataIndex: o,\n            link: e.link,\n            y: e.y,\n            x: e.x,\n            shape: e.shape,\n            label: e.name,\n            toolText: e.tooltext,\n            id: e.id,\n            datasetIndex: t.config.datasetIndex,\n            datasetName: t.config.seriesname,\n            sourceType: \"dataplot\"\n          }, C(l, e), t._setConfigure(o, e), t.parsePlotAttributes(o), t._drawNode(o), t.setState(\"dirty\", !0), h.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n            sourceEvent: \"nodeAdded\"\n          }, l)), h.fireChartInstanceEvent(\"nodeAdded\", l), t._setupKdTree());\n        }, t.prototype.updateNode = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c = this.getChildren(\"dataset\"),\n              u = c.length,\n              p = this.getFromEnv(\"chart\");\n\n          for (e.update = !0, r = 0; r < u; r++) {\n            for (t = (i = (a = c[r]).components.data || []).length, s = 0; s < t; s++) {\n              if (i[s].config.id === e.id) {\n                o = !0;\n                break;\n              }\n            }\n          }\n\n          a && o && (l = {\n            index: s,\n            dataIndex: s,\n            link: e.link,\n            y: e.y,\n            x: e.x,\n            shape: e.shape,\n            label: e.name,\n            toolText: e.tooltext,\n            id: e.id,\n            datasetIndex: a.config.datasetIndex,\n            datasetName: a.config.seriesname,\n            sourceType: \"dataplot\"\n          }, C(l, e), a._setConfigure(s, e), a.parsePlotAttributes(s), a._drawNode(s), a.setState(\"dirty\", !0), p.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n            sourceEvent: \"nodeupdated\"\n          }, l)), p.fireChartInstanceEvent(\"nodeupdated\", l), a._setupKdTree());\n        }, t.prototype.deleteNode = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g = this.getNode(e),\n              f = this.getFromEnv(\"chart\"),\n              m = function m(e) {\n            for (var t in e) {\n              e[t].remove();\n            }\n          };\n\n          if (g) {\n            for (o = (t = g.dataset).components.data, a = g.config.startConnectors, r = g.config.endConnectors, u = o.length, i = 0; i < u; i++) {\n              if ((s = o[i]).config.id === e) {\n                d = !0;\n                break;\n              }\n            }\n\n            if (!0 === d) {\n              for (c in m(s.graphics), a) {\n                m((l = a[c] || {}).graphics), delete l.graphics, l.removed = !0;\n              }\n\n              for (c in r) {\n                m((l = r[c] || {}).graphics), delete l.graphics, l.removed = !0;\n              }\n\n              s.removed = !0, p = {\n                index: i,\n                dataIndex: i,\n                link: (h = s.config || {}).link,\n                y: h.y,\n                x: h.x,\n                shape: h.shape,\n                label: h.displayValue,\n                toolText: h.toolText,\n                id: h.id,\n                datasetIndex: t.config.datasetIndex,\n                datasetName: t.config.seriesname,\n                sourceType: \"dataplot\"\n              }, C(p, {\n                width: h.width,\n                height: h.height,\n                radius: h.radius,\n                numsides: h.numSides\n              }), f.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n                sourceEvent: \"nodedeleted\"\n              }, p)), f.fireChartInstanceEvent(\"nodedeleted\", p), t._setupKdTree();\n            }\n          }\n        }, t.prototype.addConnector = function (e) {\n          var t,\n              o = this.getChildren(\"connector\")[0],\n              a = o.components.data,\n              r = this.getFromEnv(\"chart\"),\n              i = a.length;\n          e.add = !0, o._setConfigure(i, e), t = {\n            arrowAtEnd: Boolean(e.arrowatend),\n            arrowAtStart: Boolean(e.arrowatstart),\n            fromNodeId: e.from,\n            id: e.id,\n            label: e.label,\n            link: e.connectorLink,\n            sourceType: \"connector\",\n            toNodeId: e.to\n          }, r.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n            sourceEvent: \"connectoradded\"\n          }, t)), r.fireChartInstanceEvent(\"connectoradded\", t), o.asyncDraw();\n        }, t.prototype.editConnector = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h = e.from,\n              d = e.to,\n              g = this.getChildren(\"connector\"),\n              f = this.getFromEnv(\"chart\"),\n              m = g.length;\n\n          for (t = 0; t < m; t++) {\n            for (o = (a = (c = g[t]) && c.components.data || []).length, l = 0; l < o; l++) {\n              if (r = (u = a[l].config).from, i = u.to, r === h && i === d) {\n                s = !0;\n                break;\n              }\n            }\n          }\n\n          e.update = !0, s && (c._setConfigure(l, e), p = {\n            arrowAtEnd: Boolean(e.arrowatend),\n            arrowAtStart: Boolean(e.arrowatstart),\n            fromNodeId: e.from,\n            id: e.id,\n            label: e.label,\n            link: e.link,\n            sourceType: \"connector\",\n            toNodeId: e.to\n          }, f.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n            sourceEvent: \"connectorupdated\"\n          }, p)), f.fireChartInstanceEvent(\"connectorupdated\", p), c.asyncDraw());\n        }, t.prototype.deleteConnector = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c = e.from,\n              u = e.to,\n              p = this.getChildren(\"connector\"),\n              h = !1,\n              d = p.length,\n              g = this.getFromEnv(\"chart\");\n\n          for (t = 0; t < d; t++) {\n            for (i = (r = p[t].components.data).length, o = 0; o < i; o++) {\n              if ((a = r[o]).config.from === c && a.config.to === u) {\n                h = !0;\n                break;\n              }\n            }\n          }\n\n          h && (l = {\n            arrowAtEnd: (s = a.config || {}).arrowAtEnd,\n            arrowAtStart: s.arrowAtStart,\n            fromNodeId: s.from,\n            id: s.id,\n            label: s.label,\n            link: s.connectorLink,\n            sourceType: \"connector\",\n            toNodeId: s.to\n          }, function (e) {\n            var t;\n\n            for (t in e) {\n              e[t].remove();\n            }\n          }(a.graphics), delete a.graphics, a.removed = !0, g.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n            sourceEvent: \"connectordeleted\"\n          }, l)), g.fireChartInstanceEvent(\"connectordeleted\", l));\n        }, t.prototype.createHtmlDialog = function (e, t, o, a, r, i) {\n          var l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f = this.getFromEnv(\"chartConfig\"),\n              m = this.getFromEnv(\"chart-container\"),\n              b = this.getFromEnv(\"style\").inCanvasStyle || {},\n              y = Number(f.width),\n              x = Number(f.height),\n              k = this.getFromEnv(\"animationManager\"),\n              C = {\n            color: (0, n.hashify)(b.color),\n            textAlign: \"center\",\n            paddingTop: 1 + v,\n            border: \"1px solid #cccccc\",\n            borderRadius: 4 + v,\n            cursor: n.preDefStr.POINTER,\n            _cursor: \"hand\",\n            backgroundColor: n.HASHSTRING + \"ffffff\",\n            zIndex: 21,\n            \"-webkit-border-radius\": 4 + v\n          },\n              N = i;\n          return g = {\n            width: y,\n            height: x\n          }, i || (g.fill = \"transparent\", g.type = \"div\"), N = k.setAnimation({\n            el: i || \"html\",\n            attr: g,\n            component: this,\n            label: \"ui\",\n            state: w,\n            css: {\n              fontSize: 10 + v,\n              lineHeight: 15 + v,\n              fontFamily: b.fontFamily,\n              display: \"block\"\n            },\n            container: !i && m\n          }), g = {\n            width: y,\n            height: x,\n            opacity: .3\n          }, N.veil || (g.fill = \"000000\", g.type = \"div\"), N.veil = k.setAnimation({\n            el: N.veil || \"html\",\n            attr: g,\n            component: this,\n            state: w,\n            label: \"uiveil\",\n            container: !N.veil && N\n          }), u = {\n            x: (y - e) / 2,\n            y: (x - t) / 2,\n            width: e,\n            height: t\n          }, N.dialog || (u.fill = \"efefef\", u.strokeWidth = 1, u.stroke = \"000000\", u.type = \"div\"), N.dialog = k.setAnimation({\n            el: N.dialog || \"html\",\n            attr: u,\n            component: this,\n            state: w,\n            label: \"uidialog\",\n            container: !N.dialog && N,\n            css: {\n              borderRadius: 5 + v,\n              boxShadow: \"1px 1px 3px #000000\",\n              \"-webkit-border-radius\": 5 + v,\n              \"-webkit-box-shadow\": \"1px 1px 3px #000000\",\n              filter: 'progid:DXImageTransform.Microsoft.Shadow(Strength=4, Direction=135, Color=\"#000000\")'\n            }\n          }), p = {\n            x: e - 70 - 5,\n            y: t - 23 - 5,\n            width: 65,\n            height: 17\n          }, N.ok || (p.text = \"Submit\", p.tabIndex = 1, p.type = \"div\"), l = k.setAnimation({\n            el: N.ok || \"html\",\n            state: w,\n            attr: p,\n            component: this,\n            label: \"uiok\",\n            css: C,\n            container: !N.ok && N.dialog\n          }), !N.ok && (N.ok = l) && l.on(\"mousedown\", o), h = {\n            x: e - 140 - 5,\n            y: t - 23 - 5,\n            width: 65,\n            height: 17\n          }, N.cancel || (h.text = \"Cancel\", h.tabIndex = 2, h.type = \"div\"), s = k.setAnimation({\n            el: N.cancel || \"html\",\n            state: w,\n            attr: h,\n            component: this,\n            label: \"uicancel\",\n            css: C,\n            container: !N.cancel && N.dialog\n          }), !N.cancel && (N.cancel = s) && s.on(\"mousedown\", a), d = {\n            x: e - 210 - 5,\n            y: t - 23 - 5,\n            width: 65,\n            height: 17\n          }, N.removeItem || (d.text = \"Delete\", d.tabIndex = 3, d.type = \"div\"), c = k.setAnimation({\n            el: N.removeItem || \"html\",\n            state: w,\n            attr: d,\n            component: this,\n            label: \"uiremove\",\n            css: C,\n            container: !N.removeItem && N.dialog\n          }), !N.removeItem && (N.removeItem = c) && c.on(\"mousedown\", r), N.handleKeyPress || (N.handleKeyPress = function (e) {\n            13 === e.keyCode ? N.ok.element && N.ok.element.onmousedown && N.ok.element.onmousedown(e) : 27 === e.keyCode && N.cancel.element && N.cancel.element.onmousedown && N.cancel.element.onmousedown(e);\n          }), N;\n        }, t.prototype.getNode = function (e) {\n          for (var t, o = {}, a = this.getChildren(\"dataset\"), r = 0, n = a.length; r < n; r++) {\n            if (e) {\n              if (t = a[r].getNode(e)) return t;\n            } else Object.assign(o, a[r].getNode());\n          }\n\n          return !e && o;\n        }, t.prototype.createContainer = function () {\n          var e = this,\n              t = e.getFromEnv(\"animationManager\"),\n              o = e.getLinkedParent().getChildContainer();\n          [\"connectorGroup\", \"defaultVcanvasGroup\", \"vcanvasLabelGroup\", \"cloneGroup\"].forEach(function (a) {\n            !e.getChildContainer(a) && e.addChildContainer(a, t.setAnimation({\n              el: \"group\",\n              attr: {\n                name: \"manager-\" + a\n              },\n              component: e,\n              container: o[a] || o.defaultVcanvasGroup\n            }));\n          }), !e.getContainer(\"waitContainer\") && e.addContainer(\"waitContainer\", t.setAnimation({\n            el: \"group\",\n            attr: {\n              name: \"manager-waitContainer\"\n            },\n            container: o.defaultVcanvasGroup,\n            component: e\n          }));\n        }, t.prototype.draw = function () {\n          var e,\n              t,\n              o = {\n            cacheUpdateUI: [350, 215],\n            cacheLabelDeleteUI: [250, 100],\n            cacheLabelUpdateUI: [350, 205],\n            cacheConnectorUpdateUIedit: [315, 215],\n            cacheConnectorUpdateUInew: [315, 215]\n          };\n\n          if (!this.getState(\"configured\")) {\n            for (e in w = \"update\", o) {\n              if ((t = this.getGraphicalElement(e)) && t.isVisible()) {\n                if (\"cacheUpdateUI\" === e) {\n                  var a = t.fields.image.val();\n                  o[e][1] = a ? 250 : 215;\n                }\n\n                this.createHtmlDialog(o[e][0], o[e][1], d, d, d, t);\n              }\n            }\n\n            w = \"appearing\";\n          }\n\n          this.setState(\"configured\", !1), this.createContainer();\n        }, t.prototype.getDataLimits = function () {\n          var e,\n              t,\n              o = this.getChildren(\"dataset\"),\n              a = +Infinity,\n              r = -Infinity,\n              n = -Infinity,\n              i = +Infinity;\n\n          for (e = 0; e < o.length; e++) {\n            t = o[e].config, r = Math.max(r, t.yMax), a = Math.min(a, t.yMin), n = Math.max(n, t.xMax), i = Math.min(i, t.xMin);\n          }\n\n          return {\n            max: r,\n            min: a,\n            xMax: n,\n            xMin: i\n          };\n        }, t.prototype.isVisible = function () {\n          return !this.isNotVisible;\n        }, t.prototype.childChanged = function () {\n          return this;\n        }, t.prototype.hideWaitElem = function () {\n          this.getGraphicalElement(\"waitElement\") && this.getGraphicalElement(\"waitElement\").hide();\n        }, t.prototype.clearLongPress = function () {\n          clearTimeout(this.config._longpressactive), delete this.config._longpressactive;\n        }, t.prototype.triggerLabelUI = function (e, t) {\n          var o = this;\n          o.config._longpressactive = setTimeout(function () {\n            e.data(\"fire_click_event\", 0), e.data(\"viewMode\") || o.showLabelDeleteUI(t);\n          }, 1e3);\n        }, t.prototype.triggerConnectorUI = function (e) {\n          var t = this,\n              o = e.data(\"dataset\"),\n              a = o.config,\n              r = e.data(n.preDefStr.configStr),\n              i = r || {};\n          t.config._longpressactive = setTimeout(function () {\n            e.data(\"fire_click_event\", 0), e.data(\"viewMode\") || t.showConnectorUpdateUI({\n              fromid: {\n                val: i.from,\n                innerHTML: \"<option>\" + i.from + \"</option>\",\n                disabled: !0\n              },\n              toid: {\n                val: i.to,\n                innerHTML: \"<option>\" + i.to + \"</option>\",\n                disabled: !0\n              },\n              datasetIndex: o.config.datasetIndex,\n              index: r.index,\n              arratstart: {\n                val: Boolean((0, n.pluckNumber)(i.arrowatstart, 1))\n              },\n              arratend: {\n                val: Boolean((0, n.pluckNumber)(i.arrowatend, 1))\n              },\n              dashed: {\n                val: (0, n.pluckNumber)(i.dashed)\n              },\n              dashgap: {\n                val: i.dashgap\n              },\n              dashlen: {\n                val: i.dashlen\n              },\n              label: {\n                val: i.label\n              },\n              tooltext: {\n                val: i.tooltext\n              },\n              id: {\n                val: a.id,\n                disabled: !0\n              },\n              strength: {\n                val: i.conStrength\n              },\n              alpha: {\n                val: i.alpha\n              },\n              color: {\n                val: i.color.FCcolor.color\n              }\n            }, !0);\n          }, 1e3);\n        }, t.prototype.deleteLabel = function (e) {\n          var t,\n              o,\n              a,\n              r = this.getChildren(\"labels\")[0],\n              i = (0, n.pluckNumber)(e, r.config.lastTappedLabelIndex),\n              l = r.components.data[i],\n              s = this.getFromEnv(\"chart\");\n          t = l.graphics.element, o = l.graphics.trackerElement, t && (a = t.data(\"eventArgs\"), t.remove(), o && o.remove(), delete l.graphics), s.fireChartInstanceEvent(\"chartupdated\", (0, n.extend2)({\n            sourceEvent: \"labeldeleted\"\n          }, a)), s.fireChartInstanceEvent(\"labeldeleted\", a), l.removed = !0;\n        }, t.prototype.showLabelDeleteUI = function (e) {\n          var t = this,\n              o = t.getChildren(\"labels\")[0],\n              a = t.getFromEnv(\"paper\"),\n              r = t.getGraphicalElement(\"cacheLabelDeleteUI\");\n          o.config.lastTappedLabelIndex = e.config.index, r ? r.show() : ((r = t.addGraphicalElement(\"cacheLabelDeleteUI\", t.createHtmlDialog(250, 100, d, function () {\n            r.hide();\n          }, function () {\n            t.deleteLabel(), r.hide();\n          }))).message = a.html(\"span\", {\n            x: 10,\n            y: 10,\n            width: 230,\n            height: 80\n          }).add(r.dialog), r.ok.hide(), r.removeItem.translate(175).show()), r.message.attr({\n            text: 'Would you really like to delete the label: \"' + e.config.text + '\"?'\n          });\n        }, t.prototype.drawWaitingRing = function (e, t) {\n          var o = this,\n              a = o.config,\n              r = o.getFromEnv(\"animationManager\"),\n              i = o.getContainer(\"waitContainer\"),\n              l = e.config,\n              s = o.getChildren(\"dataset\")[t].config,\n              c = o.getGraphicalElement(\"waitElement\");\n          o.clearLongPress(), c = r.setAnimation({\n            el: c || \"ringpath\",\n            attr: {\n              ringpath: [l._xPos, l._yPos, 8, 11, 0, 0],\n              fill: (0, n.toRaphaelColor)({\n                alpha: \"100,100\",\n                angle: 120,\n                color: \"CCCCCC,FFFFFF\",\n                ratio: \"30,50\"\n              }),\n              \"stroke-width\": 0\n            },\n            container: i,\n            component: o\n          }), o.getGraphicalElement(\"waitElement\") || o.addGraphicalElement(\"waitElement\", c), c.show().animate({\n            ringpath: [l._xPos, l._yPos, 8, 11, 0, 6.28]\n          }, 1e3), a._longpressactive = setTimeout(function () {\n            var e = s.name !== m && s.name !== d ? s.name + n.preDefStr.BLANKSPACE : m,\n                a = s.id !== d ? (e ? n.COMMASTRING : e) + s.id : m;\n            c && c.hide(), o.showNodeUpdateUI({\n              x: {\n                value: l.x\n              },\n              y: {\n                value: l.y\n              },\n              draggable: {\n                value: (0, n.getFirstValue)(l.allowdrag, 1)\n              },\n              color: {\n                value: l.color\n              },\n              alpha: {\n                value: l.alpha\n              },\n              label: {\n                value: (0, n.getFirstValue)(l.label, l.name)\n              },\n              tooltip: {\n                value: l.toolText\n              },\n              shape: {\n                value: h[l.shape]\n              },\n              rectWidth: {\n                value: l.width\n              },\n              rectHeight: {\n                value: l.height\n              },\n              circPolyRadius: {\n                value: l.radius\n              },\n              polySides: {\n                value: l.numsides\n              },\n              image: {\n                value: l.imageNode\n              },\n              imgWidth: {\n                value: l.imageWidth\n              },\n              imgHeight: {\n                value: l.imageHeight\n              },\n              imgAlign: {\n                value: l.imageAlign\n              },\n              imgUrl: {\n                value: l.imageURL\n              },\n              id: {\n                value: l.id,\n                disabled: !0\n              },\n              link: {\n                value: l.link\n              },\n              dataset: {\n                innerHTML: '<option value=\"' + a + '\">' + e + a + \"</option>\",\n                disabled: !0\n              },\n              datasetIndex: t\n            }, !0);\n          }, 1e3);\n        }, t.prototype.drawNodeConnectors = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l = this.getChildren(\"connector\");\n          if (e) for (t in e) {\n            (r = e[t]) && (o = r.config.datasetIndex, n = r.config.fromPointObj, i = r.config.toPointObj, (a = l[o]) && (a && a.parsePlotAttributes(r, n, i), a && a.drawConnector(r, n, i)));\n          }\n        }, t.prototype._clearConnectors = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              i,\n              l = this.getNode();\n\n          for (e in l) {\n            if (i = l[e]) {\n              for (r in t = i.config.startConnectors || {}, o = i.config.endConnectors || {}, t) {\n                a = {\n                  graphics: t[r].graphics || {}\n                }, n.componentDispose.call(a);\n              }\n\n              for (r in o) {\n                a = {\n                  graphics: o[r].graphics || {}\n                }, n.componentDispose.call(a);\n              }\n            }\n          }\n        }, t.prototype.getJSONData = function () {\n          var e,\n              t,\n              o,\n              a = this.getChildren(),\n              r = a.dataset,\n              i = a.connector,\n              l = a.labels,\n              s = {};\n\n          for (s.dataset = [], s.connectors = [], s.labels = [], e = 0, t = r && r.length; e < t; e++) {\n            o = r[e], s.dataset[e] || (s.dataset[e] = (0, n.extend2)({}, o.JSONData)), s.dataset[e].data = o.getJSONData();\n          }\n\n          for (e = 0, t = i && i.length; e < t; e++) {\n            o = i[e], s.connectors[e] || (s.connectors[e] = (0, n.extend2)({}, o.JSONData)), s.connectors[e].connector = o.getJSONData();\n          }\n\n          for (e = 0, t = l && l.length; e < t; e++) {\n            o = l[e], s.labels[e] || (s.labels[e] = {\n              label: []\n            }), s.labels[e].label = o.getJSONData();\n          }\n\n          return s;\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = S;\n    },\n    552: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o,\n            n = e.getFromEnv(\"dataSource\"),\n            i = n.dataset,\n            l = n.connectors,\n            s = n.labels,\n            c = void 0,\n            u = c = e.getChildren().canvas[0].getChildren(\"vCanvas\")[0],\n            p = [];\n        s && (s = [s]), i || l || s ? (t = e.getDSGroupdef(), (0, a.componentFactory)(c, t, \"datasetGroup_dragNode\"), (o = c.getChildren(\"datasetGroup_dragNode\")) && (u = o[0]), i && i.length ? (0, a.componentFactory)(u, e.getDSdef(\"dragnode\"), \"dataset\", i.length, i) : p.push(\"dataset\"), l && l.length ? (0, a.componentFactory)(u, e.getDSdef(\"connector\"), \"connector\", l.length, l) : p.push(\"connector\"), s && s.length ? (0, a.componentFactory)(u, e.getDSdef(\"dragableLabels\"), \"labels\", s.length, s) : p.push(\"labels\"), p.length && r(u, p)) : e.setChartMessage();\n      };\n\n      var a = o(118),\n          r = function r(e, t) {\n        var o = e.getChildren(),\n            a = void 0,\n            r = void 0,\n            n = void 0;\n        if (t && t.length) for (n = t.length - 1; n > -1; n--) {\n          for (r = (a = o[t[n]]) && a.length - 1; r > -1; a[r].remove(), r--) {\n            ;\n          }\n        }\n      };\n    },\n    553: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = o(118),\n          r = o(122),\n          n = h(o(354)),\n          i = h(o(326)),\n          l = h(o(554)),\n          s = h(o(560)),\n          c = h(o(556)),\n          u = h(o(561)),\n          p = h(o(563));\n\n      function h(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function d(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var g = a.preDefStr.altHGridColorStr,\n          f = a.preDefStr.altHGridAlphaStr,\n          m = Math,\n          v = m.max,\n          b = m.round,\n          y = a.preDefStr.POSITION_BOTTOM,\n          x = a.preDefStr.divLineAlpha3DStr,\n          w = a.preDefStr.defaultFontStr,\n          k = a.preDefStr.divLineAlphaStr,\n          C = a.preDefStr.altVGridColorStr,\n          N = a.preDefStr.altVGridAlphaStr,\n          S = a.preDefStr.colors.c000000,\n          E = {\n        chart2D: {\n          bgColor: \"bgColor\",\n          bgAlpha: \"bgAlpha\",\n          bgAngle: \"bgAngle\",\n          bgRatio: \"bgRatio\",\n          canvasBgColor: \"canvasBgColor\",\n          canvasBaseColor: \"canvasBaseColor\",\n          divLineColor: \"divLineColor\",\n          legendBgColor: \"legendBgColor\",\n          legendBorderColor: \"legendBorderColor\",\n          toolTipbgColor: \"toolTipbgColor\",\n          toolTipBorderColor: \"toolTipBorderColor\",\n          baseFontColor: \"baseFontColor\",\n          anchorBgColor: \"anchorBgColor\"\n        },\n        chart3D: {\n          bgColor: \"bgColor3D\",\n          bgAlpha: \"bgAlpha3D\",\n          bgAngle: \"bgAngle3D\",\n          bgRatio: \"bgRatio3D\",\n          canvasBgColor: \"canvasBgColor3D\",\n          canvasBaseColor: \"canvasBaseColor3D\",\n          divLineColor: \"divLineColor3D\",\n          divLineAlpha: x,\n          legendBgColor: \"legendBgColor3D\",\n          legendBorderColor: \"legendBorderColor3D\",\n          toolTipbgColor: \"toolTipbgColor3D\",\n          toolTipBorderColor: \"toolTipBorderColor3D\",\n          baseFontColor: \"baseFontColor3D\",\n          anchorBgColor: \"anchorBgColor3D\"\n        }\n      },\n          A = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.isDual = !0, o.paletteIndex = 3, o.canvasborderthickness = 1, o.hasInteractiveLegend = !1, o.numOfCanvas = 2, o.registerFactory(\"vCanvas\", i[\"default\"], [\"axis\"]), o.registerFactory(\"axis\", s[\"default\"], [\"canvas\"]), o.registerFactory(\"dataset\", l[\"default\"], [\"vCanvas\"]), o;\n        }\n\n        return d(t, e), t.prototype.getName = function () {\n          return \"candlestick\";\n        }, t.getName = function () {\n          return \"candlestick\";\n        }, t.prototype.getDSdef = function (e) {\n          return \"bar\" === e ? u[\"default\"] : \"line\" === e ? p[\"default\"] : c[\"default\"];\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.hasLegend = !0, t.defaultDatasetType = \"candlestick\", t.drawanchors = 0, t.enablemousetracking = !0, t.iscandlestick = !0;\n        }, t.prototype.configureAttributes = function (t) {\n          e.prototype.configureAttributes.call(this, t);\n        }, t.prototype.parseChartAttr = function (t) {\n          e.prototype.parseChartAttr.call(this, t);\n          var o,\n              n = this.config,\n              i = this.getFromEnv(\"chart-attrib\"),\n              l = this.getFromEnv(\"color-manager\");\n          n.showVolumeChart = (0, a.pluckNumber)(i.showvolumechart, function (e) {\n            if (!e || !e.dataset) return 0;\n            var t = e.dataset[0].data;\n            return !!(Array.isArray(t) && t.filter(function (e) {\n              return e.volume;\n            }) || []).length;\n          }(t), 1), n.rollOverBandColor = (0, r.convertColor)((0, a.pluck)(i.rolloverbandcolor, l.getColor(g)), (0, a.pluck)(i.rolloverbandalpha, l.getColor(f))), n.crosslinecolor = (0, a.pluck)(i.crosslinecolor, i.rolloverbandcolor, l.getColor(g)), n.drawcrosslineontop = 0, n.crosslinealpha = (0, a.pluckNumber)(i.crosslinealpha, i.rolloverbandalpha, l.getColor(f)), n.drawcrossline = 1, n.skipClipping = !0, i = this.getFromEnv(\"chart-attrib\"), n.vplotbordercolor = (0, a.getFirstValue)(i.vplotbordercolor, \"\"), n.vplotborderalpha = (0, a.getFirstValue)(i.vplotborderalpha, \"\"), n.vplotborderthickness = (0, a.pluckNumber)(i.vplotborderthickness, 1), n.showplotborder = (0, a.pluckNumber)(i.showvplotborder, 1), o = (0, a.pluckNumber)(i.volumeheightpercent, 40), n.volumeHeightPercent = o < 20 ? 20 : o > 80 ? 80 : o, n.canvasBorderWidth = (0, a.pluckNumber)(i.canvasborderthickness, 1);\n        }, t.prototype._spaceManager = function () {\n          var e,\n              t,\n              o,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              A = this.config,\n              D = this.getChildren(),\n              T = A.legendPosition,\n              L = D.xAxis && D.xAxis[0],\n              _ = D.yAxis && D.yAxis[0],\n              P = D.yAxis && D.yAxis[1],\n              O = A.hasLegend,\n              V = this.getFromEnv(\"legend\"),\n              M = this.config.showVolumeChart,\n              F = M ? A.volumeHeightPercent : 0,\n              I = D.canvas[0],\n              B = I.config,\n              R = A.width,\n              j = A.height,\n              G = {},\n              H = A.chartBorderWidth,\n              W = B.canvasBorderWidth,\n              z = A.minCanvasHeight,\n              U = A.minCanvasWidth,\n              J = A.canvasMarginLeft,\n              K = A.canvasMarginRight,\n              q = A.canvasMarginTop,\n              Y = A.canvasMarginBottom,\n              X = A.origCanvasTopMargin,\n              Q = A.origCanvasBottomMargin,\n              Z = A.origCanvasLeftMargin,\n              $ = A.origCanvasRightMargin;\n\n          this._allocateSpace({\n            top: H,\n            bottom: H,\n            left: H,\n            right: H\n          }), e = .225 * A.availableHeight, t = this._manageActionBarSpace && this._manageActionBarSpace(e) || {}, this._allocateSpace(t), d = T === a.POSITION_RIGHT ? .225 * A.canvasWidth : .3 * A.canvasHeight, !1 !== O && L && A.showLegend && this._allocateSpace(V._manageLegendPosition(d)), o = .7 * A.canvasWidth, p = _.placeAxis(o), h = M ? P.placeAxis(o) : {}, G.left = v(p.left, h.left || 0), G.right = v(p.right, h.right || 0), this._allocateSpace(G), U > R - J - K && (S = !0, g = A.canvasWidth - U, E = J + K, J = A.canvasMarginLeft = g * J / E, K = A.canvasMarginRight = g * K / E), w = J > A.canvasLeft ? J - A.canvasLeft : 0, k = K > R - A.canvasRight ? K + A.canvasRight - R : 0, this._allocateSpace({\n            left: w,\n            right: k\n          }), S && (E = Z + $, (m = A.canvasWidth) > U && (w = (g = m - U) * Z / E, k = g * $ / E), this._allocateSpace({\n            left: w,\n            right: k\n          })), r = .225 * A.canvasHeight, r = T === y ? .6 * A.canvasHeight : .6 * A.canvasWidth, this._manageChartMenuBar(r), this._allocateSpace({\n            top: A.canvasMarginTop,\n            bottom: A.canvasMarginBottom\n          }), r = .3 * A.canvasHeight, i = L.placeAxis(r), L && this._allocateSpace(i), i.bottom += 6, B.intermediarySpace = i.bottom, M && this._allocateSpace({\n            bottom: 10\n          }), this._allocateSpace({\n            top: W,\n            bottom: 2 * W,\n            left: W,\n            right: W\n          }), z > j - q - Y && (x = !0, g = A.canvasHeight - z, E = q + Y, q = A.canvasMarginTop = g * q / E, Y = A.canvasMarginBottom = g * Y / E), C = q > A.canvasTop ? q - A.canvasTop : 0, N = Y > j - A.canvasBottom ? Y + A.canvasBottom - j : 0, this._allocateSpace({\n            top: C,\n            bottom: N\n          }), x && (E = X + Q, (f = A.canvasHeight) > z && (C = (g = f - z) * X / E, N = g * Q / E), this._allocateSpace({\n            top: C,\n            bottom: N\n          })), n = A.canvasHeight, B.canvasHeight = b((100 - F) / 100 * n), B.canvasTop = A.canvasTop, B.canvasLeft = A.canvasLeft, B.canvasBottom = B.canvasTop + B.canvasHeight, B.canvasWidth = A.canvasWidth, B.canvasRight = A.canvasRight, u = A.canvasTop + B.canvasHeight + W, B.canvasY = u, I.setDimension({\n            top: B.canvasTop,\n            left: B.canvasLeft,\n            width: B.canvasWidth,\n            height: B.canvasHeight\n          }), M && ((s = (l = D.canvas[1]).config).canvasHeight = F / 100 * n, s.canvasTop = B.canvasBottom + i.bottom + 2 * W, s.canvasLeft = A.canvasLeft, s.canvasBottom = s.canvasTop + s.canvasHeight + 2 * W, s.canvasRight = A.canvasRight, s.canvasWidth = A.canvasWidth, c = A.canvasTop + B.canvasHeight + i.bottom + 2 * W, s.canvasY = c, l.setDimension({\n            top: s.canvasTop,\n            left: s.canvasLeft,\n            width: s.canvasWidth,\n            height: s.canvasHeight\n          }));\n        }, t.prototype._postSpaceManagement = function () {\n          e.prototype._postSpaceManagement.call(this);\n        }, t.prototype.setAxisDimention = function () {\n          var e = this.getChildren(),\n              t = this.config.showVolumeChart,\n              o = e.xAxis && e.xAxis[0],\n              a = e.yAxis && e.yAxis[0],\n              r = e.yAxis && e.yAxis[1],\n              n = e.canvas,\n              i = n[0].config,\n              l = void 0,\n              s = i.canvasBorderWidth;\n          o && o.setAxisDimention({\n            x: i.canvasLeft,\n            y: i.canvasY,\n            opposite: i.canvasTop - s,\n            axisLength: i.canvasWidth\n          }), a && a.setAxisDimention({\n            x: i.canvasLeft - s,\n            y: i.canvasTop,\n            opposite: i.canvasRight + s,\n            axisLength: i.canvasHeight\n          }), o.setCanvas(i), a.setCanvas(i), t && (l = n[1].config, r && r.setAxisDimention({\n            x: i.canvasLeft - s,\n            y: l.canvasTop,\n            opposite: l.canvasRight + s,\n            axisLength: l.canvasHeight\n          }), r && r.setCanvas(l));\n        }, t.prototype._feedAxesRawData = function () {\n          var e,\n              t,\n              o,\n              r = this.getFromEnv(\"color-manager\"),\n              n = this.getFromEnv(\"dataSource\"),\n              i = this.getFromEnv(\"chart-attrib\"),\n              l = [],\n              s = [],\n              c = this.config.is3D,\n              u = c ? E.chart3D : E.chart2D;\n          return (e = {\n            isVertical: !1,\n            isReverse: !1,\n            isOpposit: !1,\n            drawTrendLabels: !0,\n            outCanfontFamily: (0, a.pluck)(i.outcnvbasefont, i.basefont, w),\n            outCanfontSize: (0, a.pluckFontSize)(i.outcnvbasefontsize, i.basefontsize, 10),\n            outCancolor: (0, a.pluck)(i.outcnvbasefontcolor, i.basefontcolor, r.getColor(u.baseFontColor)).replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: i.xaxisnamepadding,\n            axisValuePadding: i.labelpadding,\n            axisNameFont: i.xaxisnamefont,\n            axisNameFontSize: i.xaxisnamefontsize,\n            axisNameFontColor: i.xaxisnamefontcolor,\n            axisNameFontBold: i.xaxisnamefontbold,\n            axisNameFontItalic: i.xaxisnamefontitalic,\n            axisNameBgColor: i.xaxisnamebgcolor,\n            axisNameBorderColor: i.xaxisnamebordercolor,\n            axisNameAlpha: i.xaxisnamealpha,\n            axisNameFontAlpha: i.xaxisnamefontalpha,\n            axisNameBgAlpha: i.xaxisnamebgalpha,\n            axisNameBorderAlpha: i.xaxisnameborderalpha,\n            axisNameBorderPadding: i.xaxisnameborderpadding,\n            axisNameBorderRadius: i.xaxisnameborderradius,\n            axisNameBorderThickness: i.xaxisnameborderthickness,\n            axisNameBorderDashed: i.xaxisnameborderdashed,\n            axisNameBorderDashLen: i.xaxisnameborderdashlen,\n            axisNameBorderDashGap: i.xaxisnameborderdashgap,\n            useEllipsesWhenOverflow: i.useellipseswhenoverflow,\n            divLineColor: (0, a.pluck)(i.vdivlinecolor, i.divlinecolor, r.getColor(u.divLineColor)),\n            divLineAlpha: (0, a.pluck)(i.vdivlinealpha, i.divlinealpha, c ? r.getColor(x) : r.getColor(k)),\n            divLineThickness: (0, a.pluckNumber)(i.vdivlinethickness, i.divlinethickness, 1),\n            divLineIsDashed: Boolean((0, a.pluckNumber)(i.vdivlinedashed, i.vdivlineisdashed, i.divlinedashed, i.divlineisdashed, 0)),\n            divLineDashLen: (0, a.pluckNumber)(i.vdivlinedashlen, i.divlinedashlen, 4),\n            divLineDashGap: (0, a.pluckNumber)(i.vdivlinedashgap, i.divlinedashgap, 2),\n            showAlternateGridColor: (0, a.pluckNumber)(i.showalternatevgridcolor, 0),\n            alternateGridColor: (0, a.pluck)(i.alternatevgridcolor, r.getColor(C)),\n            alternateGridAlpha: (0, a.pluck)(i.alternatevgridalpha, r.getColor(N)),\n            numDivLines: i.numvdivlines,\n            labelFont: i.labelfont,\n            labelFontSize: i.labelfontsize,\n            labelFontColor: i.labelfontcolor,\n            labelFontAlpha: i.labelalpha,\n            labelFontBold: i.labelfontbold,\n            labelFontItalic: i.labelfontitalic,\n            axisName: i.xaxisname,\n            axisMinValue: i.xaxisminvalue,\n            axisMaxValue: i.xaxismaxvalue,\n            setAdaptiveMin: i.setadaptivexmin,\n            adjustDiv: i.adjustvdiv,\n            labelDisplay: i.labeldisplay,\n            showLabels: i.showlabels,\n            rotateLabels: i.rotatelabels,\n            slantLabel: (0, a.pluckNumber)(i.slantlabels, i.slantlabel),\n            labelStep: (0, a.pluckNumber)(i.labelstep, i.xaxisvaluesstep),\n            showAxisValues: (0, a.pluckNumber)(i.showxaxisvalues, i.showxaxisvalue),\n            showLimits: i.showvlimits,\n            showDivLineValues: (0, a.pluckNumber)(i.showvdivlinevalues, i.showvdivlinevalues),\n            showZeroPlane: i.showvzeroplane,\n            zeroPlaneColor: i.vzeroplanecolor,\n            zeroPlaneThickness: i.vzeroplanethickness,\n            zeroPlaneAlpha: i.vzeroplanealpha,\n            showZeroPlaneValue: i.showvzeroplanevalue,\n            trendlineColor: i.trendlinecolor,\n            trendlineToolText: i.trendlinetooltext,\n            trendlineThickness: i.trendlinethickness,\n            trendlineAlpha: i.trendlinealpha,\n            showTrendlinesOnTop: i.showtrendlinesontop,\n            showAxisLine: (0, a.pluckNumber)(i.showxaxisline, i.showaxislines, i.drawAxisLines, 0),\n            axisLineThickness: (0, a.pluckNumber)(i.xaxislinethickness, i.axislinethickness, 1),\n            axisLineAlpha: (0, a.pluckNumber)(i.xaxislinealpha, i.axislinealpha, 100),\n            axisLineColor: (0, a.pluck)(i.xaxislinecolor, i.axislinecolor, S),\n            freezeLimit: !0\n          }).vtrendlines = n.vtrendlines, s.push(e), (t = {\n            isVertical: !0,\n            isReverse: !0,\n            isOpposit: !1,\n            drawLabelsOpposit: 1,\n            axisNameAlignCanvas: 1,\n            outCanfontFamily: (0, a.pluck)(i.outcnvbasefont, i.basefont, w),\n            outCanfontSize: (0, a.pluckFontSize)(i.outcnvbasefontsize, i.basefontsize, 10),\n            outCancolor: (0, a.pluck)(i.outcnvbasefontcolor, i.basefontcolor, r.getColor(u.baseFontColor)).replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: i.yaxisnamepadding,\n            axisValuePadding: i.yaxisvaluespadding,\n            axisNameFont: i.pyaxisnamefont,\n            axisNameFontSize: i.pyaxisnamefontsize,\n            axisNameFontColor: i.pyaxisnamefontcolor,\n            axisNameFontBold: i.pyaxisnamefontbold,\n            axisNameFontItalic: i.pyaxisnamefontitalic,\n            axisNameBgColor: i.pyaxisnamebgcolor,\n            axisNameBorderColor: i.pyaxisnamebordercolor,\n            axisNameAlpha: i.pyaxisnamealpha,\n            axisNameFontAlpha: i.pyaxisnamefontalpha,\n            axisNameBgAlpha: i.pyaxisnamebgalpha,\n            axisNameBorderAlpha: i.pyaxisnameborderalpha,\n            axisNameBorderPadding: i.pyaxisnameborderpadding,\n            axisNameBorderRadius: i.pyaxisnameborderradius,\n            axisNameBorderThickness: i.pyaxisnameborderthickness,\n            axisNameBorderDashed: i.pyaxisnameborderdashed,\n            axisNameBorderDashLen: i.pyaxisnameborderdashlen,\n            axisNameBorderDashGap: i.pyaxisnameborderdashgap,\n            axisNameWidth: i.yaxisnamewidth,\n            useEllipsesWhenOverflow: i.useellipseswhenoverflow,\n            rotateAxisName: (0, a.pluckNumber)(i.rotateyaxisname, 1),\n            axisName: i.pyaxisname,\n            divLineColor: (0, a.pluck)(i.divlinecolor, r.getColor(u.divLineColor)),\n            divLineAlpha: (0, a.pluck)(i.divlinealpha, r.getColor(k)),\n            divLineThickness: (0, a.pluckNumber)(i.divlinethickness, 1),\n            divLineIsDashed: Boolean((0, a.pluckNumber)(i.divlinedashed, i.divlineisdashed, 1)),\n            divLineDashLen: (0, a.pluckNumber)(i.divlinedashlen, 4),\n            divLineDashGap: (0, a.pluckNumber)(i.divlinedashgap, 2),\n            showAlternateGridColor: (0, a.pluckNumber)(i.showalternatehgridcolor, 1),\n            alternateGridColor: (0, a.pluck)(i.alternatehgridcolor, r.getColor(g)),\n            alternateGridAlpha: (0, a.pluck)(i.alternatehgridalpha, r.getColor(f)),\n            numDivLines: (0, a.pluckNumber)(i.numpdivlines, 5),\n            axisMinValue: i.pyaxisminvalue,\n            axisMaxValue: i.pyaxismaxvalue,\n            setAdaptiveMin: (0, a.pluckNumber)(i.setadaptiveymin, 1),\n            adjustDiv: i.adjustdiv,\n            labelStep: i.yaxisvaluesstep,\n            showAxisValues: (0, a.pluckNumber)(i.showyaxisvalues, i.showyaxisvalue),\n            showLimits: (0, a.pluckNumber)(i.showyaxislimits, i.showlimits, this.showLimits),\n            showDivLineValues: (0, a.pluckNumber)(i.showdivlinevalues, i.showdivlinevalue),\n            showZeroPlane: i.showzeroplane,\n            zeroPlaneColor: i.zeroplanecolor,\n            zeroPlaneThickness: i.zeroplanethickness,\n            zeroPlaneAlpha: i.zeroplanealpha,\n            showZeroPlaneValue: i.showzeroplanevalue,\n            trendlineColor: i.trendlinecolor,\n            trendlineToolText: i.trendlinetooltext,\n            trendlineThickness: i.trendlinethickness,\n            trendlineAlpha: i.trendlinealpha,\n            showTrendlinesOnTop: i.showtrendlinesontop,\n            showAxisLine: (0, a.pluckNumber)(i.showyaxisline, i.showaxislines, i.drawAxisLines, 0),\n            axisLineThickness: (0, a.pluckNumber)(i.yaxislinethickness, i.axislinethickness, 1),\n            axisLineAlpha: (0, a.pluckNumber)(i.yaxislinealpha, i.axislinealpha, 100),\n            axisLineColor: (0, a.pluck)(i.yaxislinecolor, i.axislinecolor, S)\n          }).trendlines = n.trendlines, l.push(t), this.config.showVolumeChart && (o = {\n            isVertical: !0,\n            isReverse: !0,\n            isOpposit: !1,\n            axisIndex: 1,\n            drawLabelsOpposit: 1,\n            axisNameAlignCanvas: 1,\n            uniqueClassName: 1,\n            outCanfontFamily: (0, a.pluck)(i.outcnvbasefont, i.basefont, w),\n            outCanfontSize: (0, a.pluckFontSize)(i.outcnvbasefontsize, i.basefontsize, 10),\n            outCancolor: (0, a.pluck)(i.outcnvbasefontcolor, i.basefontcolor, r.getColor(u.baseFontColor)).replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: i.yaxisnamepadding,\n            axisValuePadding: i.yaxisvaluespadding,\n            axisNameFont: i.vyaxisnamefont,\n            axisNameFontSize: i.vyaxisnamefontsize,\n            axisNameFontColor: i.vyaxisnamefontcolor,\n            axisNameFontBold: i.vyaxisnamefontbold,\n            axisNameFontItalic: i.vyaxisnamefontitalic,\n            axisNameBgColor: i.vyaxisnamebgcolor,\n            axisNameBorderColor: i.vyaxisnamebordercolor,\n            axisNameAlpha: i.vyaxisnamealpha,\n            axisNameFontAlpha: i.vyaxisnamefontalpha,\n            axisNameBgAlpha: i.vyaxisnamebgalpha,\n            axisNameBorderAlpha: i.vyaxisnameborderalpha,\n            axisNameBorderPadding: i.vyaxisnameborderpadding,\n            axisNameBorderRadius: i.vyaxisnameborderradius,\n            axisNameBorderThickness: i.vyaxisnameborderthickness,\n            axisNameBorderDashed: i.vyaxisnameborderdashed,\n            axisNameBorderDashLen: i.vyaxisnameborderdashlen,\n            axisNameBorderDashGap: i.vyaxisnameborderdashgap,\n            axisNameWidth: i.yaxisnamewidth,\n            useEllipsesWhenOverflow: i.useellipseswhenoverflow,\n            rotateAxisName: (0, a.pluckNumber)(i.rotateyaxisname, 1),\n            axisName: i.vyaxisname,\n            divLineColor: (0, a.pluck)(i.divlinecolor, r.getColor(u.divLineColor)),\n            divLineAlpha: (0, a.pluck)(i.divlinealpha, r.getColor(k)),\n            divLineThickness: (0, a.pluckNumber)(i.divlinethickness, 1),\n            divLineIsDashed: Boolean((0, a.pluckNumber)(i.divlinedashed, i.divlineisdashed, 1)),\n            divLineDashLen: (0, a.pluckNumber)(i.divlinedashlen, 4),\n            divLineDashGap: (0, a.pluckNumber)(i.divlinedashgap, 2),\n            showAlternateGridColor: (0, a.pluckNumber)(i.showalternatehgridcolor, 1),\n            alternateGridColor: (0, a.pluck)(i.alternatehgridcolor, r.getColor(g)),\n            alternateGridAlpha: (0, a.pluck)(i.alternatehgridalpha, r.getColor(f)),\n            numDivLines: i.numdivlines,\n            axisMinValue: i.vyaxisminvalue,\n            axisMaxValue: i.vyaxismaxvalue,\n            setAdaptiveMin: i.setadaptiveymin,\n            adjustDiv: i.adjustdiv,\n            labelStep: i.yaxisvaluesstep,\n            showAxisValues: (0, a.pluckNumber)(i.showyaxisvalues, i.showyaxisvalue),\n            showLimits: (0, a.pluckNumber)(i.showsecondarylimits, i.showlimits),\n            showDivLineValues: (0, a.pluckNumber)(i.showdivlinevalues, i.showdivlinevalue),\n            showZeroPlane: i.showzeroplane,\n            zeroPlaneColor: i.zeroplanecolor,\n            zeroPlaneThickness: i.zeroplanethickness,\n            zeroPlaneAlpha: i.zeroplanealpha,\n            showZeroPlaneValue: i.showzeroplanevalue,\n            trendlineColor: i.trendlinecolor,\n            trendlineToolText: i.trendlinetooltext,\n            trendlineThickness: i.trendlinethickness,\n            trendlineAlpha: i.trendlinealpha,\n            showTrendlinesOnTop: i.showtrendlinesontop,\n            showAxisLine: (0, a.pluckNumber)(i.showyaxisline, i.showaxislines, i.drawAxisLines, 0),\n            axisLineThickness: (0, a.pluckNumber)(i.yaxislinethickness, i.axislinethickness, 1),\n            axisLineAlpha: (0, a.pluckNumber)(i.yaxislinealpha, i.axislinealpha, 100),\n            axisLineColor: (0, a.pluck)(i.yaxislinecolor, i.axislinecolor, S)\n          }, l.push(o)), {\n            xAxisConfigure: s,\n            yAxisConfigure: l\n          };\n        }, t.prototype.mouseoutHandler = function (e, t, o) {\n          var a = this.config.datasetOrder || this.getDatasets(),\n              r = this.getChildren(\"mouseTracker\")[0];\n          a[t]._firePlotEvent(\"mouseout\", o, e), delete r._lastDatasetIndex, delete r._lastPointIndex;\n        }, t.prototype._mouseEvtHandler = function (e, t) {\n          var o,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u = this,\n              p = t.mouseTracker,\n              h = e.originalEvent,\n              d = u.getChildren(\"canvas\").length,\n              g = h && (0, a.getMouseCoordinate)(u.getFromEnv(\"chart-container\"), h, u),\n              f = g && g.chartX || 0,\n              m = g && g.chartY || 0,\n              v = !1,\n              b = p._lastDatasetIndex,\n              y = p._lastPointIndex;\n\n          for (i = 0; i < d; i++) {\n            for (l = (o = u.getDatasets()).length; l-- && !v;) {\n              (r = o[l]) && r.getState(\"visible\") && (n = r._getHoveredPlot && r._getHoveredPlot(f, m)) && n.hovered && (v = !0, n.datasetIndex = l, c = p.getMouseEvents(e, n.datasetIndex, n.pointIndex));\n            }\n          }\n\n          if ((!v || c && c.fireOut) && void 0 !== b && o[b] && o[b]._firePlotEvent && (c && !c.events.length ? p.mouseoutTimer = setTimeout(function () {\n            u.mouseoutHandler(e, b, y);\n          }, 20) : u.mouseoutHandler(e, b, y)), v) for ((s = c.events && c.events.length) && (p._lastDatasetIndex = n.datasetIndex, y = p._lastPointIndex = n.pointIndex), l = 0; l < s; l += 1) {\n            r && r._firePlotEvent && r._firePlotEvent(c.events[l], y, e, n.datasetIndex);\n          }\n        }, t.prototype._allocateSpace = function (e) {\n          var t,\n              o,\n              a = this.getChildren(\"canvas\"),\n              r = a && a[0].config,\n              n = this.config,\n              i = n.canvasHeight,\n              l = n.canvasWidth,\n              s = n.availableHeight,\n              c = n.availableWidth;\n          o = n.canvasLeft += e.left || 0, t = n.canvasTop += e.top || 0, l = n.canvasWidth = v(l - ((e.left || 0) + (e.right || 0)), 0), i = n.canvasHeight = v(i - ((e.top || 0) + (e.bottom || 0)), 0), n.availableHeight = v(s - ((e.top || 0) + (e.bottom || 0)), 0), n.availableWidth = v(c - ((e.left || 0) + (e.right || 0)), 0), n.canvasRight = o + l, n.canvasBottom = t + i, r && (r.canvasPaddingLeft = v(r.canvasPaddingLeft, e.paddingLeft || 0), r.canvasPaddingRight = v(r.canvasPaddingRight, e.paddingRight || 0), r.canvasPaddingTop = v(r.canvasPaddingTop, e.paddingTop || 0), r.canvasPaddingBottom = v(r.canvasPaddingBottom, e.paddingBottom || 0));\n        }, t.prototype._checkInvalidSpecificData = function () {\n          var e = this.getFromEnv(\"dataSource\").dataset,\n              t = e && e[0] && e[0].data;\n          if (!e || !t || !Array.isArray(t)) return !0;\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = A;\n    },\n    554: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o = e.getFromEnv(\"dataSource\"),\n            i = o.dataset,\n            c = o.trendset,\n            u = e.getFromEnv(\"chart-attrib\"),\n            p = e.getFromEnv(\"chartConfig\").showVolumeChart,\n            h = (0, a.pluck)((0, a.parseUnsafeString)(u.plotpriceas).toLowerCase(), \"candlestick\"),\n            d = e.getChildren(),\n            g = d.canvas[0].getChildren(\"vCanvas\")[0],\n            f = void 0,\n            m = void 0,\n            v = [\"candlestick\", \"candlestickbar\", \"candlestickline\", \"trendset\"];\n        i ? ((m = i.slice(0))[0] && m[0].data && m[0].data.sort(function (e, t) {\n          return e.x - t.x;\n        }), t = e.getDSdef(h), (0, a.datasetFactory)(g, t, \"dataset_\" + h, i.length, m), l(v, \"bar\" === h ? \"candlestickbar\" : \"line\" === h ? \"candlestickline\" : \"candlestick\"), p && (f = d.canvas[1].getChildren(\"vCanvas\")[0], (0, a.datasetFactory)(f, r[\"default\"], \"dataset_volume\", i.length, i)), c && ((0, a.datasetFactory)(g, n[\"default\"], \"dataset_trendset\", c.length, c), l(v, \"trendset\")), s(g, v)) : e.setChartMessage();\n      };\n      var a = o(118),\n          r = i(o(555)),\n          n = i(o(558));\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      var l = function l(e, t) {\n        var o = e.indexOf(t);\n        -1 !== o && e.splice(o, 1);\n      },\n          s = function s(e, t) {\n        var o = void 0;\n        e && e.iterateComponents(function (e) {\n          for (o = 0; o < t.length; o++) {\n            e.getName() === t[o] && e.remove();\n          }\n        });\n      };\n    },\n    555: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(331),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      },\n          i = o(118),\n          l = o(122),\n          s = o(556);\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var u = i.preDefStr.colors,\n          p = u.B90000,\n          h = u.FFFFFF,\n          d = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n\n          var t,\n              o,\n              a,\n              r,\n              n,\n              s,\n              c,\n              u,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C = this.config,\n              N = this.config.JSONData,\n              S = N.data || [],\n              E = this.getFromEnv(\"chart-attrib\"),\n              A = this.getFromEnv(\"chartConfig\"),\n              D = S.length,\n              T = this.getFromEnv(\"color-manager\"),\n              L = C.bearBorderColor = (0, l.getFirstColor)((0, i.pluck)(E.bearbordercolor, A.vplotbordercolor, p)),\n              _ = C.bearFillColor = (0, l.getFirstColor)((0, i.pluck)(E.bearfillcolor, p)),\n              P = C.bullBorderColor = (0, l.getFirstColor)((0, i.pluck)(E.bullbordercolor, A.vplotbordercolor, T.getColor(\"canvasBorderColor\"))),\n              O = C.bullFillColor = (0, l.getFirstColor)((0, i.pluck)(E.bullfillcolor, h)),\n              V = (0, i.pluckNumber)(A.showplotborder, 1) ? (0, i.pluckNumber)(E.vplotborderthickness, 1) : 0,\n              M = this.getFromEnv(\"number-formatter\"),\n              F = -Infinity,\n              I = +Infinity,\n              B = -Infinity,\n              R = +Infinity,\n              j = this.getFromEnv(\"number-formatter\");\n\n          for (this.setState(\"visible\", 1 === (0, i.pluckNumber)(N.visible, 1)), !0 === this.getState(\"visible\") ? this._conatinerHidden = !1 : this._containerHidden = !0, C.parentYAxis = 1, C.volumeToolText = (0, i.getValidValue)((0, i.parseUnsafeString)((0, i.pluck)(N.volumetooltext, E.volumetooltext, E.plottooltext))), C.name = (0, i.getValidValue)(N.seriesname), C.showTooltip = (0, i.pluck)(E.showtooltip, 1), C.showShadow = (0, i.pluckNumber)(E.showshadow, T.getColor(\"showShadow\")), k = (0, i.pluck)(E.maxcolwidth), C.maxColWidth = Math.abs((0, i.pluckNumber)(k, 50)) || 1, w = Math.max((0, i.pluckNumber)(E.plotspacepercent, 20) % 100, 0), C.plotSpacePercent = C.groupPadding = w / 200, C.plotborderthickness = V, b = this.components.data = this.components.data || (this.components.data = []), f = (0, i.extend2)((0, i.extend2)({}, E), {\n            sforcedecimals: (0, i.getFirstValue)(E.forcevdecimals, E.forcedecimals),\n            sforceyaxisvaluedecimals: (0, i.getFirstValue)(E.forcevyaxisvaluedecimals, E.forceyaxisvaluedecimals),\n            syaxisvaluedecimals: (0, i.getFirstValue)(E.vyaxisvaluedecimals, E.yaxisvaluedecimals),\n            sformatnumber: (0, i.getFirstValue)(E.vformatnumber, E.formatnumber),\n            sformatnumberscale: (0, i.getFirstValue)(E.vformatnumberscale, E.formatnumberscale, \"1\"),\n            sdefaultnumberscale: (0, i.getFirstValue)(E.vdefaultnumberscale, E.defaultnumberscale),\n            snumberscaleunit: (0, i.getFirstValue)(E.vnumberscaleunit, E.numberscaleunit),\n            vnumberscalevalue: (0, i.getFirstValue)(E.vnumberscalevalue, E.numberscalevalue),\n            sscalerecursively: (0, i.getFirstValue)(E.vscalerecursively, E.scalerecursively),\n            smaxscalerecursion: (0, i.getFirstValue)(E.vmaxscalerecursion, E.maxscalerecursion),\n            sscaleseparator: (0, i.getFirstValue)(E.vscaleseparator, E.scaleseparator),\n            snumberprefix: (0, i.getFirstValue)(E.vnumberprefix, E.numberprefix),\n            snumbersuffix: (0, i.getFirstValue)(E.vnumbersuffix, E.numbersuffix),\n            sdecimals: (0, i.getFirstValue)(E.vdecimals, E.decimals)\n          }), m = C.plotLineDashLen = (0, i.pluckNumber)(E.plotlinedashlen, 5), v = C.plotLineDashGap = (0, i.pluckNumber)(E.plotlinedashgap, 4), j.configure(f), r = 0; r < D; r += 1) {\n            y = S[r], (n = b[r]) || (n = b[r] = {}), !n.config && (n.config = {}), !n.graphics && (n.graphics = {}), x = n.config, y && !y.vline && (s = x.open = M.getCleanValue(y.open), c = x.close = M.getCleanValue(y.close), u = x.volume = M.getCleanValue(y.volume, !0), x.high = M.getCleanValue(y.high), x.low = M.getCleanValue(y.low), d = x.x = M.getCleanValue(y.x), F = Math.max(F, u), I = Math.min(I, u), B = Math.max(B, d), R = Math.min(R, d), x.borderColor = (0, l.getFirstColor)((0, i.pluck)(y.bordercolor, c < s ? L : P)), o = (0, i.pluckNumber)(y.alpha, 100), g = (0, i.pluckNumber)(A.vplotborderalpha, y.alpha, 100), t = (0, l.getFirstColor)((0, i.pluck)(y.color, c < s ? _ : O)), a = {\n              opacity: C.showShadow ? o / 100 : 0\n            }, x.color = t, x.alpha = o, x.setLink = y.link, x.borderWidth = V, x.borderAlpha = g, x.y = u, x.colorArr = [{\n              color: x.color,\n              alpha: x.alpha\n            }, {\n              color: x.borderColor,\n              alpha: x.borderAlpha\n            }], x.toolText = this._parseToolText(r), x.toolTipValue = \"\", x.setValue = x._y = x.y, x.plotBorderDashStyle = (0, i.pluckNumber)(y.dashed) ? (0, i.getDashStyle)(m, v) : \"none\", d = null !== d ? d : r + 1, x._x = d, x.shadow = a);\n          }\n\n          C.defaultPadding = {\n            left: 0,\n            right: 0\n          }, C.yMax = F, C.yMin = I, C.xMax = B, C.xMin = R, this.setState(\"dirty\", !0);\n        }, t.prototype._parseToolText = function (e) {\n          return s._parseToolText.call(this, e);\n        }, t.prototype.getPlotIndices = function (e) {\n          var t,\n              o,\n              a = Math.floor(e),\n              r = Math.ceil(e),\n              n = [],\n              i = this.config.JSONData && this.config.JSONData.data;\n\n          for (t = i.length; t--;) {\n            (o = i[t]).x >= a && o.x <= r && n.push(t);\n          }\n\n          return n;\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              i,\n              l = this.getFromEnv(\"xAxis\");\n\n          for (e += l.getTranslation(), o = l.getValue(e), a = (n = this.getPlotIndices(o)).length - 1; a > -1 && !(r = (i = n[a]) - o > 0 ? this._checkPointerOverColumn(i, e, t) || this._checkPointerOverColumn(i - 1, e, t) : this._checkPointerOverColumn(i + 1, e, t) || this._checkPointerOverColumn(i, e, t)); a--) {\n            ;\n          }\n\n          return r;\n        }, t.prototype.getDataLimits = function () {\n          var e = this.config;\n          return {\n            max: e.yMax,\n            min: e.yMin,\n            xMax: e.xMax,\n            xMin: e.xMin\n          };\n        }, t.prototype.calculateScrollRange = function () {\n          var e = this.config,\n              t = this.components.data && this.components.data.length;\n          e.scrollMinVal = 0, e.scrollMaxVal = t, e.scrollMinValForLabel = e.scrollMinVal, e.scrollMaxValForLabel = e.scrollMaxVal;\n        }, t.prototype.drawLabel = function () {}, t.prototype.getName = function () {\n          return \"volume\";\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = d;\n    },\n    556: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t._parseToolText = t._firePlotEvent = t.getPlotIndices = undefined;\n      var a = o(118),\n          r = o(122),\n          n = c(o(470)),\n          i = o(125),\n          l = c(o(557)),\n          s = o(331);\n\n      function c(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function u(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var p = a.preDefStr.colors,\n          h = p.B90000,\n          d = p.FFFFFF,\n          g = function g(e, t, o) {\n        var a,\n            r,\n            n,\n            i = this.getFromEnv(\"chart\"),\n            l = this.components.data[t],\n            s = this.config.currentToolTip,\n            c = l.graphics.element,\n            u = o.originalEvent,\n            p = i.getFromEnv(\"paper\").canvas.style,\n            h = this.getFromEnv(\"toolTipController\");\n        if (c) switch (a = (r = l.config).toolText, n = r.setLink, e) {\n          case \"mouseover\":\n            a && (s ? h.draw(u, a, s) : s = this.config.currentToolTip = h.draw(u, a)), i.plotEventHandler(c, o, \"DataPlotRollOver\"), n && (p.cursor = \"pointer\");\n            break;\n\n          case \"mouseout\":\n            h.hide(s), i.plotEventHandler(c, o, \"DataPlotRollOut\"), n && (p.cursor = \"default\");\n            break;\n\n          case \"click\":\n            i.plotEventHandler(c, o);\n            break;\n\n          case \"mousemove\":\n            a && (s ? h.draw(u, a, s) : s = this.config.currentToolTip = h.draw(u, a));\n        }\n      },\n          f = function f(e) {\n        var t,\n            o,\n            a = Math.floor(e),\n            r = Math.ceil(e),\n            n = [],\n            i = this.config.JSONData && this.config.JSONData.data;\n\n        for (t = i.length; t--;) {\n          (o = i[t]).x >= a && o.x <= r && n.push(t);\n        }\n\n        return n;\n      },\n          m = function m(e) {\n        var t,\n            o = this.config,\n            r = o.JSONData.data,\n            n = this.components.data,\n            i = this.getFromEnv(\"xAxis\"),\n            l = this.getFromEnv(\"chart-attrib\"),\n            s = \"line\" === o.plotType ? 1 : 0,\n            c = r[e],\n            u = n[e].config,\n            p = i.getLabel(u.x).label,\n            h = u.open,\n            d = u.close,\n            g = this.getFromEnv(\"yAxis\"),\n            f = u.high,\n            m = u.low,\n            v = u.volume,\n            b = void 0 !== v ? c.volumetooltext : void 0;\n        return o.showTooltip ? void 0 !== (t = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(b, c.tooltext, o.volumeToolText, o.toolText)))) ? t = (0, a.parseTooltext)(t, [3, 5, 6, 10, 54, 55, 56, 57, 58, 59, 60, 61, 81, 82], {\n          label: p,\n          yaxisName: (0, a.parseUnsafeString)(l.yaxisname),\n          xaxisName: (0, a.parseUnsafeString)(l.xaxisname),\n          openValue: c.open,\n          openDataValue: g.dataLabels(h),\n          closeValue: c.close,\n          closeDataValue: g.dataLabels(d),\n          highValue: c.high,\n          highDataValue: g.dataLabels(f),\n          lowValue: c.low,\n          lowDataValue: g.dataLabels(m),\n          volumeValue: c.volume,\n          volumeDataValue: g.dataLabels(v)\n        }, c, l) : (t = null === h || s ? \"\" : \"<b>Open:</b> \" + g.dataLabels(h) + \"<br />\", t += null !== d ? \"<b>Close:</b> \" + g.dataLabels(d) + \"<br />\" : \"\", t += null === f || s ? \"\" : \"<b>High:</b> \" + g.dataLabels(f) + \"<br />\", t += null === m || s ? \"\" : \"<b>Low:</b> \" + g.dataLabels(m) + \"<br />\", t += null !== v ? \"<b>Volume:</b> \" + g.dataLabels(v) : \"\") : t = \"\", t;\n      };\n\n      (0, i.addDep)({\n        name: \"candlestickAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var v = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return u(t, e), t.prototype.trimData = function (e) {\n          if (this.components || !this.components.data || !this.components.data.length) {\n            var t = this.components,\n                o = t && t.data,\n                a = o && o.length,\n                r = e.data,\n                n = Array.isArray(r) && r.filter(function (e) {\n              return e.high || e.open || e.close || e.low;\n            }).length || 0,\n                i = a - n;\n            i > 0 && this.removeData(n, i, !1);\n          }\n        }, t.prototype.removePlots = function () {\n          var e = this.components,\n              t = e && e.removeDataArr;\n          (0, s._removePlots)(t, this.__removeElem);\n        }, t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n          var t,\n              o,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E = this.config,\n              A = this.getFromEnv(\"chart\"),\n              D = A.getFromEnv(\"dataSource\"),\n              T = this.config.JSONData,\n              L = T.data || [],\n              _ = D.chart,\n              P = L.length,\n              O = this.getFromEnv(\"number-formatter\"),\n              V = this.getFromEnv(\"color-manager\"),\n              M = E.bearBorderColor = (0, r.getFirstColor)((0, a.pluck)(_.bearbordercolor, h)),\n              F = E.bearFillColor = (0, r.getFirstColor)((0, a.pluck)(_.bearfillcolor, h)),\n              I = E.bullBorderColor = (0, r.getFirstColor)((0, a.pluck)(_.bullbordercolor, V.getColor(\"canvasBorderColor\"))),\n              B = E.bullFillColor = (0, r.getFirstColor)((0, a.pluck)(_.bullfillcolor, d)),\n              R = E.linethickness = E.plotBorderThickness = (0, a.pluckNumber)(_.plotlinethickness, 1),\n              j = E.plotLineDashLen = (0, a.pluckNumber)(_.plotlinedashlen, 5),\n              G = E.plotLineDashGap = (0, a.pluckNumber)(_.plotlinedashgap, 4),\n              H = -Infinity,\n              W = +Infinity,\n              z = -Infinity,\n              U = +Infinity;\n\n          for (this.setState(\"visible\", 1 === (0, a.pluckNumber)(T.visible, 1)), this._conatinerHidden = !!this.getState(\"visible\"), E.defaultPadding = {\n            left: .5,\n            right: .5\n          }, E.parentYAxis = 0, E.toolText = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(T.tooltext, _.plottooltext))), E.name = (0, a.getValidValue)(T.seriesname), E.showTooltip = (0, a.pluck)(_.showtooltip, 1), E.showShadow = (0, a.pluckNumber)(_.showshadow, V.getColor(\"showShadow\")), E.showErrorValue = !0, E.errorBarWidthPercent = 0, !0, S = (0, a.pluck)(_.maxcolwidth), E.maxColWidth = Math.abs((0, a.pluckNumber)(S, 50)) || 1, N = Math.max((0, a.pluckNumber)(_.plotspacepercent, 20) % 100, 0), E.plotSpacePercent = E.groupPadding = N / 200, w = this.components.data = this.components.data || (this.components.data = []), E.valuePadding = (0, a.pluckNumber)(T.valuepadding, _.valuepadding, 2), E.plotBorderThickness = R, l = 0; l < P; l += 1) {\n            k = L[l], (s = w[l]) || (s = w[l] = {}), !s.config && (s.config = {}), !s.graphics && (s.graphics = {}), C = s.config, k && !k.vline && (C.setLink = (0, a.pluck)(k.link), c = C.open = O.getCleanValue(k.open), u = C.close = O.getCleanValue(k.close), p = C.high = O.getCleanValue(k.high), g = C.low = O.getCleanValue(k.low), null !== (C.volume = O.getCleanValue(k.volume, !0)) && (A.config.drawVolume = !0), v = C.x = O.getCleanValue(k.x), b = C.closeVal = Math.min(c, u), x = C.yVal = Math.max(c, u), f = Math.min(c, u, p, g), m = Math.max(c, u, p, g), o = (0, r.getFirstColor)((0, a.pluck)(k.bordercolor, u < c ? M : I)), n = (0, a.pluckNumber)(k.alpha, 100), t = (0, r.getFirstColor)((0, a.pluck)(k.color, u < c ? F : B)), C.plotBorderDashStyle = (0, a.pluckNumber)(k.dashed) ? (0, a.getDashStyle)(j, G) : \"none\", i = {\n              opacity: E.showShadow ? n / 100 : 0\n            }, C.color = t, C.alpha = n, C.setColor = C.color, C.setAlpha = C.alpha, C.anchorImageUrl = (0, a.pluck)(k.anchorimageurl, T.anchorimageurl, _.anchorimageurl), y = C.borderColor = o, C.borderAlpha = C.plotLineAlpha, C.colorArr = [{\n              color: C.color,\n              alpha: C.alpha\n            }, {\n              color: C.borderColor,\n              alpha: C.borderAlpha\n            }], C.showValue = 1, C.hoverEffects = {}, C.y = Math.abs(u - c), C.previousY = b, C.link = (0, a.pluck)(k.link), C.errorValueArr = [], p - x > 0 && (C.errorValue = !0, C.errorValueArr.push({\n              errorValue: x - p,\n              errorStartValue: x,\n              errorBarColor: y,\n              errorBarThickness: R,\n              opacity: 1\n            })), g - b < 0 && (C.errorValue = !0, C.errorValueArr.push({\n              errorValue: b - g,\n              errorStartValue: b,\n              errorBarColor: y,\n              errorBarThickness: R,\n              opacity: 1\n            })), C.setValue = x, null !== f && (H = Math.max(H, f), W = Math.min(W, f)), null !== m && (H = Math.max(H, m), W = Math.min(W, m)), null !== v && (z = Math.max(z, v), U = Math.min(U, v)), v = null !== v ? v : l + 1, C._x = v, C._y = x, C._b = b, C.high = Math.max(c, u, p, g), C.low = Math.min(c, u, p, g), C.shadow = i, C.toolText = this._parseToolText(l), C.toolTipValue = \"\", C.displayValue = (0, a.parseUnsafeString)((0, a.pluck)(k.displayvalue, k.valuetext, \"\")));\n          }\n\n          E.yMax = H, E.yMin = W, E.xMax = z, E.xMin = U, this.setState(\"dirty\", !0);\n        }, t.prototype._parseToolText = function (e) {\n          return m.call(this, e);\n        }, t.prototype.calculateScrollRange = function () {\n          var e = this.config,\n              t = this.components.data && this.components.data.length;\n          e.scrollMinVal = e.scrollMinValForLabel = 0, e.scrollMaxVal = e.scrollMaxValForLabel = t;\n        }, t.prototype.getPlotIndices = function (e) {\n          return f.call(this, e);\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o, a, r, n, i;\n\n          for (o = this.getFromEnv(\"xAxis\").getValue(e), a = (n = this.getPlotIndices(o)).length - 1; a > -1 && !(r = (i = n[a]) - o > 0 ? this._checkPointerOverPlot(i, e, t) || this._checkPointerOverPlot(i - 1, e, t) : this._checkPointerOverPlot(i + 1, e, t) || this._checkPointerOverPlot(i, e, t)); a--) {\n            ;\n          }\n\n          return r;\n        }, t.prototype._firePlotEvent = function (e, t, o) {\n          g.call(this, e, t, o);\n        }, t.prototype.getDataLimits = function () {\n          var e = this.config;\n          return {\n            max: e.yMax,\n            min: e.yMin,\n            xMax: e.xMax,\n            xMin: e.xMin\n          };\n        }, t.prototype.getName = function () {\n          return \"candlestick\";\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = v, t.getPlotIndices = f, t._firePlotEvent = g, t._parseToolText = m;\n    },\n    557: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.candlestick\": function initialDatasetCandlestick() {\n          return {\n            \"rect.appearing\": function rectAppearing(e) {\n              return [{\n                initialAttr: {\n                  y: e.attr.y + e.attr.height,\n                  height: 0\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"group.appearing\": function groupAppearing(e) {\n              return \"label-group\" === e.attr.name ? [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }] : [{\n                initialAttr: {\n                  opacity: 1\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }];\n            },\n            \"*\": null\n          };\n        },\n        \"initial.dataset.volume\": function initialDatasetVolume() {\n          return {\n            \"rect.appearing\": function rectAppearing(e) {\n              return [{\n                initialAttr: {\n                  y: e.attr.y + e.attr.height,\n                  height: 0\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"*\": null\n          };\n        }\n      };\n    },\n    558: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = s(o(346)),\n          r = o(118),\n          n = o(122),\n          i = o(125),\n          l = s(o(559));\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      (0, i.addDep)({\n        name: \"trendsetAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var u = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this), this.config.drawLine = 1;\n        }, t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n          var t,\n              o,\n              a,\n              i,\n              l,\n              s,\n              c = this.getFromEnv(\"chart-attrib\"),\n              u = this.getFromEnv(\"chartConfig\"),\n              p = this.config.JSONData,\n              h = this.index,\n              d = p.data || p.set || [],\n              g = this.config,\n              f = this.components.data,\n              m = -Infinity,\n              v = +Infinity,\n              b = -Infinity,\n              y = +Infinity,\n              x = this.getFromEnv(\"number-formatter\"),\n              w = (0, n.getFirstColor)((0, r.pluck)(p.color, c.trendsetcolor, \"666666\")),\n              k = (0, r.pluck)(p.alpha, c.trendsetalpha, \"100\"),\n              C = (0, r.pluckNumber)(p.thickness, c.trendsetthickness, 2),\n              N = Boolean((0, r.pluckNumber)(p.dashed, c.trendsetdashed, 0)),\n              S = (0, r.pluckNumber)(p.dashlen, c.trendsetdashlen, 4),\n              E = (0, r.pluckNumber)(p.dashgap, c.trendsetdashgap, 4);\n\n          for (g.includeInLegend = (0, r.pluckNumber)(p.includeinlegend, 1), g.lineColor = w, g.lineAlpha = k, g.connectNullData = (0, r.pluckNumber)(c.connectnulldata, 0), g.linethickness = C, g.lineDashStyle = N ? (0, r.getDashStyle)(S, E) : \"none\", g.name = (0, r.getValidValue)(p.name), g.includeInLegend = (0, r.pluckNumber)(p.includeinlegend, 1), g.defaultPadding = {\n            left: .5,\n            right: .5\n          }, f || (f = this.components.data = []), h = 0, s = d.length; h < s; h += 1) {\n            (t = d[h]) && !t.vline && (o = (i = (a = f[h] = f[h] || (f[h] = {})).config = a.config || (a.config = {}))._y = i.setValue = x.getCleanValue(t.value), i.setColor = g.lineColor, i.setAlpha = g.lineAlpha, l = x.getCleanValue(t.x), l = i._x = i.x = null !== l ? l : h + 1, m = Math.max(m, o), v = Math.min(v, o), y = Math.min(y, l), b = Math.max(b, l), i.anchorProps = this._parseAnchorProperties(h), i.hoverEffects = {}, a.graphics || (a.graphics = {}));\n          }\n\n          g.max = m, g.min = v, g.xMax = b, g.xMin = y, u.showLegend && this._addLegend(), this.setState(\"visible\", !0), this.setState(\"dirty\", !0);\n        }, t.prototype._addLegend = function () {\n          var e,\n              t = this.config.JSONData,\n              o = this.config,\n              a = this.getFromEnv(\"legend\"),\n              n = {\n            enabled: o.includeInLegend,\n            interactiveLegend: !1,\n            type: this.type,\n            drawLine: !0,\n            label: (0, r.getFirstValue)(t.name)\n          };\n          o.includeinlegend ? ((e = a.getItem(this.config.legendItemId)) ? e.configure({\n            style: a.config.itemStyle,\n            hiddenStyle: a.config.itemHiddenStyle,\n            datasetVisible: a.config.datasetVisible,\n            hoverStyle: a.config.itemHoverStyle\n          }) : (this.config.legendItemId = a.createItem(this), e = a.getItem(this.config.legendItemId)), e.configure(n), e.setStateCosmetics(\"default\", {\n            symbol: {\n              stroke: (0, r.toRaphaelColor)({\n                color: o.lineColor,\n                alpha: \"100\"\n              }),\n              rawFillColor: o.lineColor\n            }\n          })) : this.config.legendItemId && a.disposeItem(this.config.legendItemId);\n        }, t.prototype.getDataLimits = function () {\n          var e = this.config;\n          return {\n            max: e.max,\n            min: e.min,\n            xMax: e.xMax,\n            xMin: e.xMin\n          };\n        }, t.prototype.getType = function () {\n          return \"trendset\";\n        }, t.prototype.drawLabel = function () {}, t.prototype.getName = function () {\n          return \"trendset\";\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = u;\n    },\n    559: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(349),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"initial.trendset.trendset\": n[\"default\"][\"initial.dataset.line\"]\n      };\n    },\n    560: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o = e.getChildren(\"canvas\"),\n            a = o[0],\n            n = o[1],\n            l = e.config.showVolumeChart,\n            s = {\n          zoomable: !0,\n          pannable: !0\n        },\n            c = a.getChildren(\"axisRefVisualCartesian\")[0],\n            u = void 0,\n            p = void 0,\n            h = void 0,\n            d = void 0,\n            g = function g() {\n          return c.asyncDraw();\n        },\n            f = function f() {\n          return u.asyncDraw();\n        };\n\n        t = e._feedAxesRawData(), (0, r.componentFactory)(e, i[\"default\"], \"yAxis\", l ? 2 : 1, t.yAxisConfigure), (0, r.componentFactory)(e, i[\"default\"], \"xAxis\", 1, t.xAxisConfigure), h = e.getChildren(\"yAxis\")[0], p = e.getChildren(\"yAxis\")[1], h.setAxisConfig({\n          relativeAxis: p\n        }), p && p.setAxisConfig({\n          relativeAxis: h\n        }), d = e.getChildren(\"xAxis\")[0], h.setLinkedItem(\"canvas\", a), d.setLinkedItem(\"canvas\", a), c.setLinkedItem(h.getId(), h), c.setLinkedItem(d.getId(), d), c.addExtEventListener(\"visiblerangeset\", g, h), c.addExtEventListener(\"visiblerangeset\", g, d), a.attachAxis(d, !1, e.zoomX ? s : {}), a.attachAxis(h, !0, e.zoomY ? s : {}), l && (u = n.getChildren(\"axisRefVisualCartesian\")[0], n.attachAxis(d, !1, e.zoomX ? s : {}), p.setLinkedItem(\"canvas\", n), u.setLinkedItem(p.getId(), p), u.setLinkedItem(d.getId(), d), u.addExtEventListener(\"visiblerangeset\", f, p), u.addExtEventListener(\"visiblerangeset\", f, d), n.attachAxis(p, !0, e.zoomY ? s : {})), e._setCategories();\n      };\n      var a,\n          r = o(118),\n          n = o(292),\n          i = (a = n) && a.__esModule ? a : {\n        \"default\": a\n      };\n    },\n    561: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = o(118),\n          r = o(122),\n          n = u(o(331)),\n          i = o(470),\n          l = o(556),\n          s = o(125),\n          c = u(o(562));\n\n      function u(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function p(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var h = a.preDefStr.colors,\n          d = h.B90000,\n          g = h.FFFFFF,\n          f = a.preDefStr.ROUND,\n          m = a.preDefStr.visibleStr;\n      (0, s.addDep)({\n        name: \"candlestickbarAnimation\",\n        type: \"animationRule\",\n        extension: c[\"default\"]\n      });\n\n      var v = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return p(t, e), t.prototype.trimData = function (e) {\n          if (this.components || !this.components.data || !this.components.data.length) {\n            var t = this.components,\n                o = t && t.data,\n                a = o && o.length,\n                r = e.data,\n                n = Array.isArray(r) && r.filter(function (e) {\n              return e.high || e.open || e.close || e.low;\n            }).length || 0,\n                i = a - n;\n            i > 0 && this.removeData(n, i, !1);\n          }\n        }, t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n\n          var t,\n              o,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N = this.config,\n              S = this.getFromEnv(\"chart\").getFromEnv(\"dataSource\"),\n              E = this.config.JSONData,\n              A = E.data || [],\n              D = S.chart,\n              T = A.length,\n              L = this.getFromEnv(\"number-formatter\"),\n              _ = this.getFromEnv(\"color-manager\"),\n              P = N.bearBorderColor = (0, r.getFirstColor)((0, a.pluck)(D.bearbordercolor, d)),\n              O = N.bearFillColor = (0, r.getFirstColor)((0, a.pluck)(D.bearfillcolor, d)),\n              V = N.bullBorderColor = (0, r.getFirstColor)((0, a.pluck)(D.bullbordercolor, _.getColor(\"canvasBorderColor\"))),\n              M = N.bullFillColor = (0, r.getFirstColor)((0, a.pluck)(D.bullfillcolor, g)),\n              F = -Infinity,\n              I = +Infinity,\n              B = -Infinity,\n              R = +Infinity;\n\n          for (this.setState(\"visible\", 1 === (0, a.pluckNumber)(E.visible, 1)), this._conatinerHidden = !!this.getState(\"visible\"), N.defaultPadding = {\n            left: .5,\n            right: .5\n          }, N.linethickness = (0, a.pluckNumber)(D.plotlinethickness, 2), N.toolText = (0, a.getValidValue)((0, a.parseUnsafeString)((0, a.pluck)(E.tooltext, D.plottooltext))), N.name = (0, a.getValidValue)(E.seriesname), N.showTooltip = (0, a.pluck)(D.showtooltip, 1), N.showErrorValue = !0, N.errorBarWidthPercent = 0, !0, k = (0, a.pluck)(D.maxcolwidth), N.maxColWidth = Math.abs((0, a.pluckNumber)(k, 50)) || 1, N.enableAnimation = C = (0, a.pluckNumber)(D.animation, D.defaultanimation, 1), N.animation = !!C && {\n            duration: 1e3 * (0, a.pluckNumber)(D.animationduration, 1)\n          }, v = N.plotLineDashLen = (0, a.pluckNumber)(D.plotlinedashlen, 5), b = N.plotLineDashGap = (0, a.pluckNumber)(D.plotlinedashgap, 4), y = this.components.data = this.components.data || (this.components.data = []), N.valuePadding = (0, a.pluckNumber)(E.valuepadding, D.valuepadding, 2), N.showShadow = (0, a.pluckNumber)(D.showshadow, _.getColor(\"showShadow\")), i = 0; i < T; i++) {\n            x = A[i], (l = y[i]) || (l = y[i] = {}), !l.config && (l.config = {}), !l.graphics && (l.graphics = {}), w = l.config, x && !x.vline && (w.setLink = (0, a.pluck)(x.link), s = w.open = L.getCleanValue(x.open), c = w.close = L.getCleanValue(x.close), u = L.getCleanValue(x.high), p = L.getCleanValue(x.low), w.volume = L.getCleanValue(x.volume, !0), m = w.x = L.getCleanValue(x.x), w.high = Math.max(s, c, u, p), w.low = Math.min(s, c, u, p), w.yVal = Math.max(s, c), h = Math.min(s, c, u, p), f = Math.max(s, c, u, p), o = (0, r.getFirstColor)((0, a.pluck)(x.bordercolor, c < s ? P : V)), n = (0, a.pluckNumber)(x.alpha, 100), t = (0, r.getFirstColor)((0, a.pluck)(x.color, c < s ? O : M)), w.color = t, w.alpha = n, w.setColor = w.color, w.setAlpha = w.alpha, w.borderColor = o, w.borderAlpha = w.plotLineAlpha, w.colorArr = [{\n              color: w.color,\n              alpha: w.alpha\n            }, {\n              color: w.borderColor,\n              alpha: w.borderAlpha\n            }], w.showValue = 1, w.hoverEffects = {}, w.link = (0, a.pluck)(x.link), w.setValue = w.y, null !== h && (F = Math.max(F, h), I = Math.min(I, h)), null !== f && (F = Math.max(F, f), I = Math.min(I, f)), null !== m && (B = Math.max(B, m), R = Math.min(R, m)), w.dashStyle = (0, a.pluckNumber)(x.dashed) ? (0, a.getDashStyle)(v, b) : \"none\", w.shadow = {\n              opacity: N.showShadow ? n / 100 : 0\n            }, m = null !== m ? m : i + 1, w.toolText = this._parseToolText(i), w.toolTipValue = \"\", w._x = m, w.y = s, w.previousY = c);\n          }\n\n          N.yMax = F, N.yMin = I, N.xMax = B, N.xMin = R, this.setState(\"dirty\", !0);\n        }, t.prototype.drawPlots = function () {\n          var e,\n              t,\n              o,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              v,\n              b,\n              y,\n              x = this.getFromEnv(\"animationManager\"),\n              w = this.config,\n              k = this.components.data,\n              C = k.length,\n              N = this.getFromEnv(\"xAxis\"),\n              S = this.getFromEnv(\"yAxis\"),\n              E = function E(e) {\n            return function () {\n              this.shadow(e);\n            };\n          },\n              A = w.linethickness > 5 ? w.linethickness / 2 : 2.5,\n              D = this.getContainer(\"plotGroup\"),\n              T = this.getState(\"visible\");\n\n          for (x.setAnimation({\n            el: D,\n            attr: {\n              opacity: T ? 1 : 0\n            },\n            component: this\n          }), this.setColumnPosition(), t = this.getFromEnv(\"columnXShift\"), o = 0; o < C; o += 1) {\n            e = (r = k[o]).config, y = r.graphics, h = null, null === (l = e.y) ? h = y.element : (i = e._x, n = e.link, e.setLink = e.link, c = N.getPixel(i), s = e.previousY, p = S.getPixel(s), u = S.getPixel(l), d = S.getPixel(e.high), g = S.getPixel(e.low), v = t, r.errorBar = [], r.errorBar.push([{\n              _xPos: c - A,\n              _yPos: d,\n              _height: Math.abs(d - g),\n              _width: 2 * A\n            }, {\n              _xPos: c + v,\n              _yPos: u,\n              _height: 2 * A,\n              _width: Math.abs(v)\n            }, {\n              _xPos: c,\n              _yPos: p,\n              _height: 2 * A,\n              _width: Math.abs(v)\n            }]), b = [\"M\", c, g, \"L\", c, d, \"M\", c, u, \"L\", c + v, u, \"M\", c, p, \"L\", c - v, p], h = y.element, h = x.setAnimation({\n              el: h || \"path\",\n              container: D,\n              attr: {\n                path: b,\n                cursor: n ? \"pointer\" : \"\",\n                fill: (0, a.toRaphaelColor)(e.color),\n                stroke: (0, a.toRaphaelColor)(e.borderColor),\n                \"stroke-width\": w.linethickness,\n                \"stroke-dasharray\": e.dashStyle,\n                \"stroke-linecap\": f,\n                \"stroke-linejoin\": f,\n                \"shape-rendering\": \"crisp\",\n                visibility: m\n              },\n              label: \"path\",\n              component: this,\n              callback: E.call(h, e.shadow)\n            }), y.element = h);\n          }\n        }, t.prototype._parseToolText = function (e) {\n          return l._parseToolText.call(this, e);\n        }, t.prototype._firePlotEvent = function (e, t, o) {\n          l._firePlotEvent.call(this, e, t, o);\n        }, t.prototype._checkPointerOverColumn = function () {}, t.prototype._getHoveredPlot = function (e, t) {\n          var o, a, r, n, i;\n\n          for (o = this.getFromEnv(\"xAxis\").getValue(e), a = (n = l.getPlotIndices.call(this, o)).length - 1; a > -1 && !(r = (i = n[a]) - o > 0 ? this._checkPointerOverPlot(i, e, t) || this._checkPointerOverPlot(i - 1, e, t) : this._checkPointerOverPlot(i + 1, e, t) || this._checkPointerOverPlot(i, e, t)); a--) {\n            ;\n          }\n\n          return r;\n        }, t.prototype._checkPointerOverPlot = function (e, t, o) {\n          return i._checkPointerOverPlot.call(this, e, t, o);\n        }, t.prototype._checkPointerOverErrorBar = function (e, t, o) {\n          return i._checkPointerOverErrorBar.call(this, e, t, o);\n        }, t.prototype.drawLabel = function () {}, t.prototype.getDataLimits = function () {\n          var e = this.config;\n          return {\n            max: e.yMax,\n            min: e.yMin,\n            xMax: e.xMax,\n            xMin: e.xMin\n          };\n        }, t.prototype.getName = function () {\n          return \"candlestickbar\";\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = v;\n    },\n    562: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.candlestickbar\": function initialDatasetCandlestickbar() {\n          return {\n            \"path.appearing\": function pathAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 1,\n                  \"stroke-width\": 1\n                },\n                finalAttr: {\n                  opacity: 1\n                }\n              }];\n            },\n            \"*\": null\n          };\n        }\n      };\n    },\n    563: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(118),\n          n = o(122),\n          i = o(346),\n          l = (a = i) && a.__esModule ? a : {\n        \"default\": a\n      },\n          s = o(556);\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var u = r.preDefStr.colors,\n          p = u.B90000,\n          h = u.FFFFFF,\n          d = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n\n          var t,\n              o,\n              a,\n              i,\n              l,\n              s,\n              c,\n              u,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N = this.config,\n              S = this.config.JSONData,\n              E = S.data || [],\n              A = this.getFromEnv(\"chart-attrib\"),\n              D = E.length,\n              T = this.getFromEnv(\"number-formatter\"),\n              L = this.getFromEnv(\"color-manager\"),\n              _ = N.bearBorderColor = (0, n.getFirstColor)((0, r.pluck)(A.bearbordercolor, p)),\n              P = N.bearFillColor = (0, n.getFirstColor)((0, r.pluck)(A.bearfillcolor, p)),\n              O = N.bullBorderColor = (0, n.getFirstColor)((0, r.pluck)(A.bullbordercolor, L.getColor(\"canvasBorderColor\"))),\n              V = N.bullFillColor = (0, n.getFirstColor)((0, r.pluck)(A.bullfillcolor, h)),\n              M = N.linethickness = N.plotBorderThickness = (0, r.pluckNumber)(A.plotlinethickness, 2),\n              F = N.plotLineDashLen = (0, r.pluckNumber)(A.plotlinedashlen, 5),\n              I = N.plotLineDashGap = (0, r.pluckNumber)(A.plotlinedashgap, 4),\n              B = !!(0, r.pluckNumber)(A.drawanchors, 0),\n              R = (0, r.pluckNumber)(A.anchorstartangle, 90),\n              j = (0, r.pluckNumber)(A.anchorradius, this.anchorRadius, 3),\n              G = (0, n.getFirstColor)((0, r.pluck)(A.anchorbordercolor, O)),\n              H = (0, r.pluckNumber)(A.anchorborderthickness, this.anchorBorderThickness, 1),\n              W = (0, n.getFirstColor)((0, r.pluck)(A.anchorbgcolor, L.getColor(\"anchorBgColor\"))),\n              z = (0, r.pluck)(A.anchoralpha, \"0\"),\n              U = (0, r.pluck)(A.anchorbgalpha, z),\n              J = -Infinity,\n              K = +Infinity,\n              q = -Infinity,\n              Y = +Infinity;\n\n          for (this.setState(\"visible\", 1 === (0, r.pluckNumber)(S.visible, 1)), this._conatinerHidden = !!this.getState(\"visible\"), N.defaultPadding = {\n            left: .5,\n            right: .5\n          }, N.plotType = \"line\", N.parentYAxis = 0, N.toolText = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(S.tooltext, A.plottooltext))), N.name = (0, r.getValidValue)(S.seriesname), N.showTooltip = (0, r.pluck)(A.showtooltip, 1), k = (0, r.pluck)(A.maxcolwidth), N.maxColWidth = Math.abs((0, r.pluckNumber)(k, 50)) || 1, N.enableAnimation = C = (0, r.pluckNumber)(A.animation, A.defaultanimation, 1), N.animation = !!C && {\n            duration: 1e3 * (0, r.pluckNumber)(A.animationduration, 1)\n          }, N.lineAlpha = (0, r.pluck)(A.plotlinealpha, \"100\"), w = Math.max((0, r.pluckNumber)(A.plotspacepercent, 20) % 100, 0), N.plotSpacePercent = N.groupPadding = w / 200, b = this.components.data = this.components.data || (this.components.data = []), N.valuePadding = (0, r.pluckNumber)(S.valuepadding, A.valuepadding, 2), N.plotBorderThickness = M, N.showvalues = 1, N.showShadow = (0, r.pluckNumber)(A.showshadow, L.getColor(\"showShadow\")), l = 0; l < D; l += 1) {\n            y = E[l], (s = b[l]) || (s = b[l] = {}), !s.config && (s.config = {}), !s.graphics && (s.graphics = {}), x = s.config, y && !y.vline && (x.setLink = (0, r.pluck)(y.link), c = x.open = T.getCleanValue(y.open), u = x.close = T.getCleanValue(y.close), d = x.high = T.getCleanValue(y.high), g = x.low = T.getCleanValue(y.low), x.volume = T.getCleanValue(y.volume, !0), v = x.x = T.getCleanValue(y.x), x.closeVal = Math.min(c, u), x.yVal = Math.max(c, u), f = Math.min(c, u, d, g), m = Math.max(c, u, d, g), t = (0, n.getFirstColor)((0, r.pluck)(y.bordercolor, u < c ? _ : O)), o = (0, r.pluck)(y.alpha, N.lineAlpha), (0, n.getFirstColor)((0, r.pluck)(y.color, u < c ? P : V)), a = (0, r.pluckNumber)(y.dashed) ? (0, r.getDashStyle)(F, I) : \"none\", x.dashStyle = a, i = {\n              opacity: N.showShadow ? o / 100 : 0\n            }, x.color = t, x.alpha = o, x.setColor = x.color, x.setAlpha = x.alpha, x.anchorImageUrl = (0, r.pluck)(y.anchorimageurl, S.anchorimageurl, A.anchorimageurl), x.borderColor = t, x.borderAlpha = x.plotLineAlpha, x.colorArr = [{\n              color: x.color,\n              alpha: x.alpha\n            }, {\n              color: x.borderColor,\n              alpha: x.borderAlpha\n            }], x.anchorSides = (0, r.pluckNumber)(y.anchorsides, S.anchorsides, A.anchorsides), x.symbol = (0, n.mapSymbolName)(x.anchorSides).split(\"_\"), x.anchorProps = {\n              enabled: B,\n              bgColor: W,\n              symbol: x.symbol,\n              bgAlpha: U * z / 100 + \"\",\n              borderColor: G,\n              borderAlpha: z,\n              anchorAlpha: z,\n              borderThickness: H,\n              imageUrl: x.anchorImageUrl,\n              radius: j,\n              imageScale: (0, r.pluckNumber)(y.imagescale, S.imagescale, A.imagescale, 100),\n              imagePadding: (0, r.pluckNumber)(y.anchorimagepadding, S.anchorimagepadding, A.anchorimagepadding, 1),\n              imageAlpha: (0, r.pluckNumber)(S.anchorimagealpha, A.anchorimagealpha, 100),\n              startAngle: R\n            }, x.showValue = y.displayvalue ? 1 : 0, x.hoverEffects = {}, x.anchorSides = (0, r.pluckNumber)(y.anchorsides, S.anchorsides, A.anchorsides), x.symbol = (0, n.mapSymbolName)(x.anchorSides).split(\"_\"), x.hoverEffects = {}, x.y = u, x.link = (0, r.pluck)(y.link), x.toolText = this._parseToolText(l), x.toolTipValue = \"\", x.setValue = x._y = x.y, x.displayValue = (0, r.parseUnsafeString)((0, r.pluck)(y.displayvalue, y.valuetext, \"\")), null !== f && (J = Math.max(J, f), K = Math.min(K, f)), null !== m && (J = Math.max(J, m), K = Math.min(K, m)), null !== v && (q = Math.max(q, v), Y = Math.min(Y, v)), v = v || l + 1, x._x = x.x = v, x.high = Math.max(c, u, d, g), x.low = Math.min(c, u, d, g), x.shadow = i);\n          }\n\n          N.yMax = J, N.yMin = K, N.xMax = q, N.xMin = Y, this.setState(\"dirty\", !0);\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this), this.config.drawLine = 1;\n        }, t.prototype.trimData = function (e) {\n          if (this.components || !this.components.data || !this.components.data.length) {\n            var t = this.components,\n                o = t && t.data,\n                a = o && o.length,\n                r = e.data,\n                n = Array.isArray(r) && r.filter(function (e) {\n              return e.high || e.open || e.close || e.low;\n            }).length || 0,\n                i = a - n;\n            i > 0 && this.removeData(n, i, !1);\n          }\n        }, t.prototype.calculateScrollRange = function () {\n          var e = this.config,\n              t = this.components.data && this.components.data.length;\n          e.scrollMinVal = e.scrollMinValForLabel = 0, e.scrollMaxVal = e.scrollMaxValForLabel = t;\n        }, t.prototype.getDataLimits = function () {\n          var e = this.config;\n          return {\n            max: e.yMax,\n            min: e.yMin,\n            xMax: e.xMax,\n            xMin: e.xMin\n          };\n        }, t.prototype.getPlotIndices = function (e) {\n          var t,\n              o,\n              a = Math.floor(e),\n              r = Math.ceil(e),\n              n = [],\n              i = this.config.JSONData && this.config.JSONData.data;\n\n          for (t = i.length; t--;) {\n            (o = i[t]).x >= a && o.x <= r && n.push(t);\n          }\n\n          return n;\n        }, t.prototype._parseToolText = function (e) {\n          return s._parseToolText.call(this, e);\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s = this.getFromEnv(\"xAxis\"),\n              c = this.components.data,\n              u = c.length,\n              p = this.config,\n              h = p && p.radius || 0;\n          e += s.getTranslation();\n          var d = (r = (a = this.getPlotIndices(Math.floor(Math.max(s.getValue(e - h), 0))))[0]) > (n = (a = this.getPlotIndices(Math.ceil(Math.min(s.getValue(e + h), u - 1))))[a.length - 1]) ? [n, r] : [r, n];\n\n          for (r = d[0], l = n = d[1]; l >= r && (!(o = c[l]) || !(i = this.isWithinShape(o, l, e, t))); l--) {\n            ;\n          }\n\n          return i;\n        }, t.prototype.getName = function () {\n          return \"candlestickline\";\n        }, t;\n      }(l[\"default\"]);\n\n      t[\"default\"] = d;\n    },\n    564: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = s(o(404)),\n          r = s(o(565)),\n          n = s(o(569)),\n          i = o(118),\n          l = s(o(570));\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      i.setAttribDefs && (0, i.setAttribDefs)({\n        whiskerslimitswidthratio: {\n          type: i.attrTypeNum,\n          pAttr: \"whiskerslimitswidthratio\"\n        },\n        outliersupperrangeratio: {\n          type: i.attrTypeNum,\n          pAttr: \"outliersupperrangeratio\"\n        },\n        outlierslowerrangeratio: {\n          type: i.attrTypeNum,\n          pAttr: \"outlierslowerrangeratio\"\n        },\n        showalloutliers: {\n          type: i.attrTypeNum,\n          pAttr: \"showalloutliers\"\n        },\n        showmean: {\n          type: i.attrTypeNum,\n          pAttr: \"showmean\"\n        },\n        showsd: {\n          type: i.attrTypeNum,\n          pAttr: \"showsd\"\n        },\n        showmd: {\n          type: i.attrTypeNum,\n          pAttr: \"showmd\"\n        },\n        showqd: {\n          type: i.attrTypeNum,\n          pAttr: \"showqd\"\n        },\n        showminvalues: {\n          type: i.attrTypeNum,\n          pAttr: \"showminvalues\"\n        },\n        showmaxvalues: {\n          type: i.attrTypeNum,\n          pAttr: \"showmaxvalues\"\n        },\n        showq1values: {\n          type: i.attrTypeNum,\n          pAttr: \"showq1values\"\n        },\n        showq3values: {\n          type: i.attrTypeNum,\n          pAttr: \"showq3values\"\n        },\n        showmedianvalues: {\n          type: i.attrTypeNum,\n          pAttr: \"showmedianvalues\"\n        }\n      });\n\n      var u = i.preDefStr.POLYGON,\n          p = i.preDefStr.colors.c000000,\n          h = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this)),\n              a = o;\n\n          return a.maxColWidth = +Infinity, a.useErrorAnimation = 1, a.avoidCrispError = 0, a.plotSpacePercent = 20, a.useplotgradientcolor = 1, a.fireGroupEvent = !0, o.registerFactory(\"dataset\", l[\"default\"], [\"vCanvas\"]), o;\n        }\n\n        return c(t, e), t.getName = function () {\n          return \"BoxAndWhisker2D\";\n        }, t.prototype.getName = function () {\n          return \"BoxAndWhisker2D\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.decimals = 2, t.friendlyName = \"Box and Whisker iapi\", t.defaultDatasetType = \"boxandwhisker2d\", t.showplotborder = 1, t.plotborderdashlen = 5, t.plotborderdashgap = 4, t.plotfillalpha = i.HUNDREDSTRING, t.useroundedges = 0, t.plotborderthickness = 1, t.showvalues = 1, t.valuepadding = 2, t.decimals = 2, t.showtooltip = 1, t.maxcolwidth = 50, t.rotatevalues = 0, t.use3dlighting = 1, t.whiskerslimitswidthratio = 40, t.outliersupperrangeratio = 0, t.outlierslowerrangeratio = 0, t.showalloutliers = 0, t.showmean = 0, t.showsd = 0, t.showmd = 0, t.showqd = 0, t.showminvalues = 1, t.showmaxvalues = 1, t.showq1values = 0, t.showq3values = 0, t.showmedianvalues = 1, t.tooltipsepchar = \": \", t.anchorborderthickness = 1, t.anchorimageurl = void 0, t.anchorimagepadding = 1, t.anchorsides = 1, t.anchoralpha = void 0, t.anchorbgalpha = i.HUNDREDSTRING, t.anchorimagealpha = i.HUNDREDSTRING, t.anchorimagescale = 100, t.anchorstartangle = 90, t.anchorshadow = 0, t.anchorbgcolor = void 0, t.anchorbordercolor = void 0, t.anchorradius = 3, t.linedashlen = 5, t.linedashgap = 4, t.linedashed = void 0, t.linealpha = i.HUNDREDSTRING, t.linethickness = 2, t.drawfullareaborder = 1, t.connectnulldata = 0;\n        }, t.prototype._getLineJSONdata = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              l,\n              s,\n              c,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C = this.getChildren(\"BoxAndWhiskerStatisticalCalc\")[0],\n              N = this.getFromEnv(\"dataSource\"),\n              S = N.chart,\n              E = N.dataset,\n              A = E.length,\n              D = [],\n              T = [],\n              L = [],\n              _ = function _(e) {\n            y = Number(e);\n            var t = (0, i.extent)(C.values);\n            v = t[0], b = t[1], (y < v || y > b) && m.push({\n              value: y,\n              index: x,\n              anchorbgcolor: r.outliericoncolor,\n              anchorradius: r.outliericonradius,\n              anchoralpha: r.outliericonalpha,\n              anchorbgalpha: r.outliericonalpha,\n              anchorsides: r.outliericonsides,\n              dip: r.outliericonshape\n            });\n          };\n\n          for (k = 0; k < A; k++) {\n            for (t = E[k], c = T[k] = {}, l = L[k] = {\n              showMean: {\n                seriesname: \"Mean\",\n                showvalues: 0,\n                anchorbgcolor: (0, i.pluck)(t.meaniconcolor, S.meaniconcolor, p),\n                anchorbordercolor: p,\n                anchorradius: (0, i.pluckNumber)(t.meaniconradius, S.meaniconradius, 5),\n                anchoralpha: (0, i.pluck)(t.alpha, t.meaniconalpha, S.meaniconalpha),\n                linethickness: (0, i.pluck)(t.linethickness, S.linethickness, 1),\n                anchorsides: (0, i.pluck)(t.meaniconsides, S.meaniconsides, 3),\n                showline: !(0, i.pluckNumber)(t.drawmeanconnector, S.drawmeanconnector),\n                dip: (0, i.pluck)(t.meaniconshape, S.meaniconshape, u),\n                color: (0, i.pluck)(t.meaniconcolor, S.meaniconcolor, p),\n                data: []\n              },\n              showSD: {\n                seriesname: \"SD\",\n                showvalues: 0,\n                anchorbgcolor: (0, i.pluck)(t.sdiconcolor, S.sdiconcolor, p),\n                anchorbordercolor: p,\n                anchorradius: (0, i.pluckNumber)(t.sdiconradius, S.sdiconradius, 5),\n                anchoralpha: (0, i.pluck)(t.alpha, t.sdiconalpha, S.sdiconalpha),\n                anchorbgalpha: (0, i.pluck)(t.sdiconalpha, S.sdiconalpha, 100),\n                linethickness: (0, i.pluck)(t.linethickness, S.linethickness, 1),\n                anchorsides: (0, i.pluck)(t.sdiconsides, S.sdiconsides, 3),\n                showline: !(0, i.pluckNumber)(t.drawsdconnector, S.drawsdconnector),\n                dip: (0, i.pluck)(t.sdiconshape, S.sdiconshape, u),\n                color: (0, i.pluck)(t.sdiconcolor, S.sdiconcolor, p),\n                data: []\n              },\n              showQD: {\n                seriesname: \"QD\",\n                showvalues: 0,\n                anchorbgcolor: (0, i.pluck)(t.qdiconcolor, S.qdiconcolor, p),\n                anchorbordercolor: p,\n                anchorradius: (0, i.pluckNumber)(t.qdiconradius, S.qdiconradius, 5),\n                anchoralpha: (0, i.pluck)(t.alpha, t.qdiconalpha, S.qdiconalpha),\n                anchorbgalpha: (0, i.pluck)(t.qdiconalpha, S.qdiconalpha, 100),\n                linethickness: (0, i.pluck)(t.linethickness, S.linethickness, 1),\n                anchorsides: (0, i.pluck)(t.qdiconsides, S.qdiconsides, 3),\n                showline: !(0, i.pluckNumber)(t.drawqdconnector, S.drawqdconnector),\n                dip: (0, i.pluck)(t.qdiconshape, S.qdiconshape, u),\n                color: (0, i.pluck)(t.qdiconcolor, S.qdiconcolor, p),\n                data: []\n              },\n              showMD: {\n                seriesname: \"MD\",\n                showvalues: 0,\n                anchorbgcolor: (0, i.pluck)(t.mdiconcolor, S.mdiconcolor, p),\n                anchorbordercolor: p,\n                anchorradius: (0, i.pluckNumber)(t.mdiconradius, S.mdiconradius, 5),\n                anchoralpha: (0, i.pluck)(t.alpha, t.mdiconalpha, S.mdiconalpha),\n                anchorbgalpha: (0, i.pluck)(t.mdiconalpha, S.mdiconalpha, 100),\n                linethickness: (0, i.pluck)(t.linethickness, S.linethickness, 1),\n                anchorsides: (0, i.pluck)(t.mdiconsides, S.mdiconsides, 3),\n                showline: !(0, i.pluckNumber)(t.drawmdconnector, S.drawmdconnector),\n                dip: (0, i.pluck)(t.mdiconshape, S.mdiconshape, u),\n                color: (0, i.pluck)(t.mdiconcolor, S.mdiconcolor, p),\n                data: []\n              },\n              outliers: {\n                seriesname: \"Outliers\",\n                showvalues: 0,\n                anchorbgcolor: (0, i.pluck)(t.outliericoncolor, S.outliericoncolor, p),\n                anchorbordercolor: p,\n                anchorradius: (0, i.pluckNumber)(t.outliericonradius, S.outliericonradius, 5),\n                anchoralpha: (0, i.pluck)(t.alpha, t.outliericonalpha, S.outliericonalpha),\n                includeinlegend: t.seriesname ? 1 : 0,\n                anchorbgalpha: (0, i.pluck)(t.outliericonalpha, S.outliericonalpha, 100),\n                linethickness: (0, i.pluck)(t.linethickness, S.linethickness, 1),\n                anchorsides: (0, i.pluck)(t.outliericonsides, S.outliericonsides, 3),\n                showline: !(0, i.pluckNumber)(t.drawoutliersconnector, S.drawoutliersconnector),\n                color: (0, i.pluck)(t.outliericoncolor, S.outliericoncolor, p),\n                dip: (0, i.pluck)(t.outliericonshape, S.outliericonshape, u),\n                data: []\n              }\n            }, e = (0, i.pluckNumber)(t.showmean, S.showmean, 0), h = (0, i.pluckNumber)(t.showsd, S.showsd, 0), d = (0, i.pluckNumber)(t.showqd, S.showqd, 0), g = (0, i.pluckNumber)(t.showmd, S.showmd, 0), a = (o = t.data) && o.length || 0, x = 0; x < a; x++) {\n              r = o[x], C.setArray(r.value), C.getQuartiles(), f = r.outliers, e = c.showMean = c.showMean || (0, i.pluckNumber)(r.showmean, e), h = c.showSD = c.showSD || (0, i.pluckNumber)(r.showsd, h), d = c.showQD = c.showQD || (0, i.pluckNumber)(r.showqd, d), g = c.showMD = c.showMD || (0, i.pluckNumber)(r.showmd, g), l.showMean.data.push({\n                value: e && C.getMean(),\n                anchorbgcolor: r.meaniconcolor,\n                anchorradius: r.meaniconradius,\n                anchoralpha: r.meaniconalpha,\n                anchorbgalpha: r.meaniconalpha,\n                anchorsides: r.meaniconsides,\n                dip: r.meaniconshape\n              }), l.showSD.data.push({\n                value: h && C.getSD(),\n                anchorbgcolor: r.sdiconcolor,\n                anchorradius: r.sdiconradius,\n                anchoralpha: r.sdiconalpha,\n                anchorbgalpha: r.sdiconalpha,\n                anchorsides: r.sdiconsides,\n                dip: r.sdiconshape\n              }), l.showQD.data.push({\n                value: d && C.getQD(),\n                anchorbgcolor: r.qdiconcolor,\n                anchorradius: r.qdiconradius,\n                anchoralpha: r.qdiconalpha,\n                anchorbgalpha: r.qdiconalpha,\n                anchorsides: r.qdiconsides,\n                dip: r.qdiconshape\n              }), l.showMD.data.push({\n                value: g && C.getMD(),\n                anchorbgcolor: r.mdiconcolor,\n                anchorradius: r.mdiconradius,\n                anchoralpha: r.mdiconalpha,\n                anchorbgalpha: r.mdiconalpha,\n                anchorsides: r.mdiconsides,\n                dip: r.mdiconshape\n              }), f && (m = l.outliers.data, f.split(i.COMMA).forEach(_), c.outliers = !0);\n            }\n          }\n\n          for (s = T.length, w = 0; w < s; w++) {\n            for (k in c = T[w], n = D[w] = [], c) {\n              c[k] && n.push(L[w][k]);\n            }\n          }\n\n          return D;\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t.prototype.getDSGroupdef = function () {\n          return n[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = h;\n    },\n    565: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = c(o(331)),\n          r = c(o(566)),\n          n = o(118),\n          i = o(122),\n          l = o(125),\n          s = c(o(568));\n\n      function c(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function u(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var p = n.preDefStr.colors.c000000,\n          h = n.preDefStr.LABEL,\n          d = n.preDefStr.UNDERSCORE,\n          g = n.preDefStr.POINTER,\n          f = n.preDefStr.BLANK,\n          m = n.preDefStr.ROUND,\n          v = n.preDefStr.GROUPID,\n          b = n.preDefStr.POSITION_START,\n          y = n.preDefStr.POSITION_BOTTOM,\n          x = n.preDefStr.POSITION_TOP,\n          w = n.preDefStr.showHoverEffectStr,\n          k = n.preDefStr.EVENTARGS,\n          C = n.preDefStr.POSITION_END,\n          N = \"M\",\n          S = \"H\",\n          E = \"V\",\n          A = n.preDefStr.pStr,\n          D = n.preDefStr.sStr,\n          T = function T(e, t, o) {\n        return o.getFromEnv(\"animationManager\").setAnimation({\n          el: \"group\",\n          attr: e,\n          container: t,\n          component: o,\n          label: \"group\"\n        });\n      },\n          L = function L() {\n        return function () {\n          this.hide();\n        };\n      };\n\n      (0, l.addDep)({\n        name: \"boxandwhisker2dAnimation\",\n        type: \"animationRule\",\n        extension: s[\"default\"]\n      });\n\n      var _ = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return u(t, e), t.prototype.createContainer = function () {\n          var e,\n              t,\n              o = this.type,\n              a = this.groupName,\n              r = this.getLinkedParent(),\n              n = a || this.dsGroup || o;\n          !r.getChildContainer(n + \"VcanvasGroup\") && (n = \"default\"), e = r.getChildContainer(n + \"VcanvasGroup\"), t = r.getChildContainer(n + \"ShadowVcanvasGroup\"), !this.getContainer(\"shadowGroup\") && this.addContainer(\"shadowGroup\", T({\n            name: \"shadow-group\"\n          }, t, this)), !this.getContainer(\"commonElemsGroup\") && this.addContainer(\"lowerBoxGroup\", T({\n            name: \"lower-box-group\"\n          }, e, this)), !this.getContainer(\"commonElemsGroup\") && this.addContainer(\"upperBoxGroup\", T({\n            name: \"upper-box-group\"\n          }, e, this)), !this.getContainer(\"commonElemsGroup\") && this.addContainer(\"upperWhiskerGroup\", T({\n            name: \"upper-whisker-group\"\n          }, e, this)), !this.getContainer(\"commonElemsGroup\") && this.addContainer(\"lowerWhiskerGroup\", T({\n            name: \"lower-whisker-group\"\n          }, e, this)), !this.getContainer(\"commonElemsGroup\") && this.addContainer(\"medianGroup\", T({\n            name: \"median-group\"\n          }, e, this)), !this.getContainer(\"labelGroup\") && this.addContainer(\"labelGroup\", T({\n            name: \"label-group\",\n            \"class\": \"fusioncharts-datalabels\"\n          }, r.getChildContainer(\"vcanvasLabelGroup\"), this));\n        }, t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n\n          var t,\n              o,\n              a,\n              r,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H,\n              W,\n              z,\n              U,\n              J,\n              K,\n              q,\n              Y,\n              X,\n              Q,\n              Z,\n              $,\n              ee,\n              te,\n              oe,\n              ae,\n              re,\n              ne,\n              ie,\n              le,\n              se,\n              ce,\n              ue,\n              pe,\n              he,\n              de,\n              ge,\n              fe,\n              me,\n              ve,\n              be,\n              ye,\n              xe,\n              we,\n              ke,\n              Ce = this.config,\n              Ne = this.config.JSONData,\n              Se = Ne.data,\n              Ee = Se && Se.length,\n              Ae = this.getFromEnv(\"chartConfig\"),\n              De = this.getFromEnv(\"xAxis\"),\n              Te = De.getTicksLen(),\n              Le = Math.min(Te, Ee),\n              _e = this.getFromEnv(\"chart-attrib\"),\n              Pe = this.getFromEnv(\"color-manager\"),\n              Oe = Ce.index,\n              Ve = Ce.plotColor = Pe.getPlotColor(Oe),\n              Me = (0, n.pluckNumber)(Ne.dashed, _e.plotborderdashed),\n              Fe = Ae.useplotgradientcolor,\n              Ie = Ae.yaxisname,\n              Be = Ae.xaxisname,\n              Re = (0, n.parseUnsafeString)((0, n.pluck)(_e.tooltipsepchar, \": \")),\n              je = this.components.data,\n              Ge = this.getFromEnv(\"number-formatter\"),\n              He = -Infinity,\n              We = +Infinity,\n              ze = this.getFromEnv(\"BoxAndWhiskerStatisticalCalc\");\n\n          for (this.setState(\"visible\", !(1 !== (0, n.pluckNumber)(this.config.JSONData.visible, !Number(this.config.JSONData.initiallyhidden), 1))), (0, n.parseConfiguration)(Ne, Ce, Ae, {\n            data: !0\n          }), Ce.defaultPadding = {\n            left: .5,\n            right: .5\n          }, Ce.seriesname = (0, n.parseUnsafeString)(Ne.seriesname), Ce.includeInLegend = (0, n.pluckNumber)(Ne.includeinlegend, Ce.seriesname ? 1 : 0), Ce.legendSymbolColor = Ce.plotColor, t = Ce.showplotborder, p = Ce.plotborderdashlen, h = Ce.plotborderdashgap, v = Ce.plotfillalpha, g = Ce.useroundedges, b = Ce.ratio, d = Ce.plotborderthickness, be = Ce.showvalues = (0, n.pluckNumber)(Ne.showvalues, _e.showvalues, 1), o = Ce.showtooltip, Ce.rotatevalues && (Ce.rotatevalues = 270), ye = Ce.showalloutliers, Ce.plotfillAngle = m = (0, n.pluckNumber)(360 - _e.plotfillangle, 90), Ce.plotColor = Ve = (0, n.pluck)(Ne.color, Ve), Ce.plotRadius = (0, n.pluckNumber)(_e.useroundedges, g ? 1 : 0), Ce.plotgradientcolor = y = (0, n.getDefinedColor)(_e.plotgradientcolor, Pe.getColor(\"plotGradientColor\")), !Fe && (y = n.BLANKSTRING), Ce.plotBorderAlpha = x = t ? (0, n.pluck)(_e.plotborderalpha, v, n.HUNDREDSTRING) : 0, Ce.plotBorderColor = w = (0, n.pluck)(_e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), Ce.plotBorderDashStyle = k = Me ? (0, n.getDashStyle)(p, h, d) : \"none\", Ce.showShadow = g ? (0, n.pluckNumber)(_e.showshadow, 1) : (0, n.pluckNumber)(_e.showshadow, Pe.getColor(\"showShadow\")), Ce.showHoverEffect = f = (0, n.pluckNumber)(_e.plothovereffect, _e.showhovereffect, void 0), Ce.parentYAxis = Q = (0, n.pluck)(Ne.parentyaxis && Ne.parentyaxis.toLowerCase(), A) === D ? 1 : 0, Ce.dataSeparator = n.COMMASTRING, Ce.textDirection = \"1\" === _e.hasrtltext ? \"rtl\" : n.BLANKSTRING, Ce.showMeanLegend = Ce.showSDLegend = Ce.showMDLegend = Ce.showQDLegend = Ce.showOutliersLegend = 0, !this.components.data && (this.components.data = []), je = this.components.data, Ce.upperBoxColor = de = (0, n.pluck)(Ne.upperboxcolor, _e.upperboxcolor, Pe.getPlotColor(2 * Oe)), ge = Ce.upperBoxAlpha = (0, n.pluck)(Ne.upperboxalpha, _e.upperboxalpha, v, n.HUNDREDSTRING), Ce.lowerBoxColor = fe = (0, n.pluck)(Ne.lowerboxcolor, _e.lowerboxcolor, Pe.getPlotColor(2 * Oe + 1)), me = Ce.lowerBoxAlpha = (0, n.pluck)(Ne.lowerboxalpha, _e.lowerboxalpha, v, n.HUNDREDSTRING), te = 0; te < Le; te++) {\n            C = Se && Se[te], E = (S = je[te]) && S.config, S || (S = je[te] = {\n              graphics: {}\n            }), S.config || (E = je[te].config = {}), C.value ? (C.value && (ze.setArray(C.value), ae = (oe = ze.getQuartiles()).q1, re = oe.q3, ne = ze.getMinMax(), E.min = ie = ne.min, E.max = le = ne.max, se = ze.getMedian(), E.mean = ce = ze.getMean(), E.md = ue = ze.getMD(), E.sd = pe = ze.getSD(), E.qd = he = ze.getQD()), E.upperQuartile = {\n              value: re,\n              color: (0, i.convertColor)((0, n.pluck)(C.upperquartilecolor, Ne.upperquartilecolor, _e.upperquartilecolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), (0, n.pluckNumber)(C.upperquartilealpha, Ne.upperquartilealpha, _e.upperquartilealpha, _e.plotborderalpha, 100)),\n              borderWidth: (0, n.pluckNumber)(C.upperquartilethickness, Ne.upperquartilethickness, _e.upperquartilethickness, _e.plotborderthickness, g ? 0 : 1),\n              displayValue: Ge.dataLabels(re)\n            }, E.lowerQuartile = {\n              value: ae,\n              color: (0, i.convertColor)((0, n.pluck)(C.lowerquartilecolor, Ne.lowerquartilecolor, _e.lowerquartilecolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), (0, n.pluckNumber)(C.lowerquartilealpha, Ne.lowerquartilealpha, _e.lowerquartilealpha, _e.plotborderalpha, 100)),\n              borderWidth: (0, n.pluckNumber)(C.lowerquartilethickness, Ne.lowerquartilethickness, _e.lowerquartilethickness, _e.plotborderthickness, g ? 0 : 1),\n              displayValue: Ge.dataLabels(ae)\n            }, E.upperBoxBorder = {\n              color: (0, i.convertColor)((0, n.pluck)(C.upperboxbordercolor, Ne.upperboxbordercolor, _e.upperboxbordercolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), (0, n.pluckNumber)(C.upperboxborderalpha, Ne.upperboxborderalpha, _e.upperboxborderalpha, _e.plotborderalpha, 100)),\n              borderWidth: (0, n.pluckNumber)(C.upperboxborderthickness, Ne.upperboxborderthickness, _e.upperboxborderthickness, !g && _e.plotborderthickness, g ? 0 : 1)\n            }, E.lowerBoxBorder = {\n              color: (0, i.convertColor)((0, n.pluck)(C.lowerboxbordercolor, Ne.lowerboxbordercolor, _e.lowerboxbordercolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), (0, n.pluckNumber)(C.lowerboxborderalpha, Ne.lowerboxborderalpha, _e.lowerboxborderalpha, _e.plotborderalpha, 100)),\n              borderWidth: (0, n.pluckNumber)(C.lowerboxborderthickness, Ne.lowerboxborderthickness, _e.lowerboxborderthickness, !g && _e.plotborderthickness, g ? 0 : 1)\n            }, E.median = {\n              value: se,\n              color: (0, i.convertColor)((0, n.pluck)(C.mediancolor, Ne.mediancolor, _e.mediancolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), (0, n.pluckNumber)(C.medianalpha, Ne.medianalpha, _e.medianalpha, _e.plotborderalpha, 100)),\n              borderWidth: (0, n.pluckNumber)(C.medianthickness, Ne.medianthickness, _e.medianthickness, _e.plotborderthickness, 1),\n              displayValue: Ge.dataLabels(se)\n            }, Ce.upperBoxColor = de = (0, n.pluck)(C.upperboxcolor, Ne.upperboxcolor, _e.upperboxcolor, Pe.getPlotColor(2 * Oe)), ge = Ce.upperBoxAlpha = (0, n.pluck)(C.upperboxalpha, Ne.upperboxalpha, _e.upperboxalpha, v, n.HUNDREDSTRING), Ce.lowerBoxColor = fe = (0, n.pluck)(C.lowerboxcolor, Ne.lowerboxcolor, _e.lowerboxcolor, Pe.getPlotColor(2 * Oe + 1)), me = Ce.lowerBoxAlpha = (0, n.pluck)(C.lowerboxalpha, Ne.lowerboxalpha, _e.lowerboxalpha, v, n.HUNDREDSTRING), E.upperColorArr = (0, i.getColumnColor)(de, ge, void 0, void 0, g, w, x.toString(), 0, !1), E.lowerColorArr = (0, i.getColumnColor)(fe, me, void 0, void 0, g, w, x.toString(), 0, !1), E.showValue = (0, n.pluckNumber)(C.showvalue, be), E.showMinValues = E.showValue ? (0, n.pluckNumber)(C.showminvalues, Ce.showminvalues) : 0, E.showMaxValues = E.showValue ? (0, n.pluckNumber)(C.showmaxvalues, Ce.showmaxvalues) : 0, E.showQ1Values = E.showValue ? (0, n.pluckNumber)(C.showq1values, Ce.showq1values) : 0, E.showQ3Values = E.showValue ? (0, n.pluckNumber)(C.showq3values, Ce.showq3values) : 0, E.showMedianValues = E.showValue ? (0, n.pluckNumber)(C.showmedianvalues, Ce.showmedianvalues) : 0, E.upperWhiskerAlpha = ve = (0, i.getFirstAlpha)((0, n.pluck)(C.upperwhiskeralpha, Ne.upperwhiskeralpha, _e.upperwhiskeralpha, _e.plotborderalpha, 100)), E.upperWhiskerColor = (0, i.convertColor)((0, i.getFirstColor)((0, n.pluck)(C.upperwhiskercolor, Ne.upperwhiskercolor, _e.upperwhiskercolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\"))), ve), E.upperWhiskerThickness = (0, n.pluckNumber)(C.upperwhiskerthickness, Ne.upperwhiskerthickness, _e.upperwhiskerthickness, _e.plotborderthickness, 1), E.upperWhiskerShadowOpacity = Ce.showShadow ? ve / 250 : 0, E.lowerWhiskerAlpha = we = (0, i.getFirstAlpha)((0, n.pluck)(C.lowerwhiskeralpha, Ne.lowerwhiskeralpha, _e.lowerwhiskeralpha, _e.plotborderalpha, 100)), E.lowerWhiskerColor = (0, i.convertColor)((0, i.getFirstColor)((0, n.pluck)(C.lowerwhiskercolor, Ne.lowerwhiskercolor, _e.lowerwhiskercolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\"))), we), E.lowerWhiskerThickness = (0, n.pluckNumber)(C.lowerwhiskerthickness, Ne.lowerwhiskerthickness, _e.lowerwhiskerthickness, _e.plotborderthickness, 1), E.lowerWhiskerShadowOpacity = Ce.showShadow ? we / 250 : 0, E.setValue = N = Ge.getCleanValue(C.value), E.setLink = (0, n.pluck)(C.link), E.toolTipValue = Y = Ge.dataLabels(N, Q), E.setDisplayValue = X = (0, n.parseUnsafeString)(C.displayvalue), E.displayValue = (0, n.pluck)(X, Y), Z = (0, n.pluckNumber)(C.dashed), $ = (0, n.pluckNumber)(C.dashlen, p), ee = h = (0, n.pluckNumber)(C.dashgap, h), He = Math.max(He, le), We = Math.min(We, ie), E.plotBorderDashStyle = 1 === Z ? (0, n.getDashStyle)($, ee, d) : 0 === Z ? \"none\" : k, Ve = (0, n.pluck)(C.color, Ce.plotColor), v = (0, n.pluck)(C.alpha, Ce.plotfillalpha), N < 0 && !g && (c = m, m = 360 - m), E.colorArr = (0, i.getColumnColor)(Ve + n.COMMA + y, v, b, m, g, w, x.toString(), 0, !1), E.label = T = (0, n.getValidValue)((0, n.parseUnsafeString)(De.getLabel((0, n.pluckNumber)(te)).label)), 0 !== f && (L = (0, n.pluck)(C.upperboxhovercolor, Ne.upperboxhovercolor, _e.upperboxhovercolor, de), _ = (0, n.pluck)(C.upperboxhoveralpha, Ne.upperboxhoveralpha, _e.upperboxhoveralpha, ge), P = (0, n.pluck)(C.upperboxborderhovercolor, Ne.upperboxborderhovercolor, _e.upperboxborderhovercolor, C.upperboxbordercolor, Ne.upperboxbordercolor, _e.upperboxbordercolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), O = (0, n.pluck)(C.upperboxborderhoveralpha, Ne.upperboxborderhoveralpha, _e.upperboxborderhoveralpha, C.upperboxborderalpha, Ne.upperboxborderalpha, _e.upperboxborderalpha, _e.plotborderalpha, 100), V = g ? 0 : (0, n.pluck)(C.upperboxborderhoverthickness, Ne.upperboxborderhoverthickness, _e.upperboxborderhoverthickness, E.upperBoxBorder.borderWidth), M = (0, n.pluck)(C.lowerboxhovercolor, Ne.lowerboxhovercolor, _e.lowerboxhovercolor, fe), F = (0, n.pluck)(C.lowerboxhoveralpha, Ne.lowerboxhoveralpha, _e.lowerboxhoveralpha, me), I = (0, n.pluck)(C.lowerboxborderhovercolor, Ne.lowerboxborderhovercolor, _e.lowerboxborderhovercolor, C.lowerboxbordercolor, Ne.lowerboxbordercolor, _e.lowerboxbordercolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), B = (0, n.pluck)(C.lowerboxborderhoveralpha, Ne.lowerboxborderhoveralpha, _e.lowerboxborderhoveralpha, C.lowerboxborderalpha, Ne.lowerboxborderalpha, _e.lowerboxborderalpha, _e.plotborderalpha, 100), R = g ? 0 : (0, n.pluck)(C.lowerboxborderhoverthickness, Ne.lowerboxborderhoverthickness, _e.lowerboxborderhoverthickness, E.lowerBoxBorder.borderWidth), j = (0, n.pluck)(C.upperquartilehovercolor, Ne.upperquartilehovercolor, _e.upperquartilehovercolor, C.upperquartilecolor, Ne.upperquartilecolor, _e.upperquartilecolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), G = (0, n.pluck)(C.upperquartilehoveralpha, Ne.upperquartilehoveralpha, _e.upperquartilehoveralpha, C.upperquartilealpha, Ne.upperquartilealpha, _e.upperquartilealpha, _e.plotborderalpha, 100), H = (0, n.pluck)(C.upperquartilehoverthickness, Ne.upperquartilehoverthickness, _e.upperquartilehoverthickness, E.upperQuartile.borderWidth), W = (0, n.pluck)(C.lowerquartilehovercolor, Ne.lowerquartilehovercolor, _e.lowerquartilehovercolor, C.lowerquartilecolor, Ne.lowerquartilecolor, _e.lowerquartilecolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), z = (0, n.pluck)(C.lowerquartilehoveralpha, Ne.lowerquartilehoveralpha, _e.lowerquartilehoveralpha, C.lowerquartilealpha, Ne.lowerquartilealpha, _e.lowerquartilealpha, _e.plotborderalpha, 100), U = (0, n.pluck)(C.lowerquartilehoverthickness, Ne.lowerquartilehoverthickness, _e.lowerquartilehoverthickness, E.lowerQuartile.borderWidth), J = (0, n.pluck)(C.medianhovercolor, Ne.medianhovercolor, _e.medianhovercolor, C.mediancolor, Ne.mediancolor, _e.mediancolor, _e.plotbordercolor, Pe.getColor(\"plotBorderColor\")), K = (0, n.pluck)(C.medianhoveralpha, Ne.medianhoveralpha, _e.medianhoveralpha, C.medianalpha, Ne.medianalpha, _e.medianalpha, _e.plotborderalpha, 100), q = (0, n.pluck)(C.medianhoverthickness, Ne.medianhoverthickness, _e.medianhoverthickness, E.median.borderWidth), 1 === f && (de === L && (L = (0, i.getLightColor)(L, 70)), fe === M && (M = (0, i.getLightColor)(M, 70))), E.upperBoxHoverColorArr = (0, i.getColumnColor)(L, _, void 0, void 0, g, w, x.toString(), 0, !1), E.lowerBoxHoverColorArr = (0, i.getColumnColor)(M, F, void 0, void 0, g, w, x.toString(), 0, !1), E.setUpperBoxRolloutAttr = {\n              fill: (0, n.toRaphaelColor)(E.upperColorArr[0])\n            }, E.setUpperBoxRolloverAttr = {\n              fill: (0, n.toRaphaelColor)(E.upperBoxHoverColorArr[0])\n            }, E.setLowerBoxRolloutAttr = {\n              fill: (0, n.toRaphaelColor)(E.lowerColorArr[0])\n            }, E.setLowerBoxRolloverAttr = {\n              fill: (0, n.toRaphaelColor)(E.lowerBoxHoverColorArr[0])\n            }, E.setUpperBoxBorderRolloverAttr = {\n              stroke: (0, i.convertColor)(P, O),\n              \"stroke-width\": V\n            }, E.setUpperBoxBorderRolloutAttr = {\n              stroke: E.upperBoxBorder.color,\n              \"stroke-width\": E.upperBoxBorder.borderWidth\n            }, E.setLowerBoxBorderRolloverAttr = {\n              stroke: (0, i.convertColor)(I, B),\n              \"stroke-width\": R\n            }, E.setLowerBoxBorderRolloutAttr = {\n              stroke: E.lowerBoxBorder.color,\n              \"stroke-width\": E.lowerBoxBorder.borderWidth\n            }, E.setUpperQuartileRolloverAttr = {\n              stroke: (0, i.convertColor)(j, G),\n              \"stroke-width\": H\n            }, E.setUpperQuartileRolloutAttr = {\n              stroke: E.upperQuartile.color,\n              \"stroke-width\": E.upperQuartile.borderWidth\n            }, E.setLowerQuartileRolloverAttr = {\n              stroke: (0, i.convertColor)(W, z),\n              \"stroke-width\": U\n            }, E.setLowerQuartileRolloutAttr = {\n              stroke: E.lowerQuartile.color,\n              \"stroke-width\": E.lowerQuartile.borderWidth\n            }, E.setMedianRolloverAttr = {\n              stroke: (0, i.convertColor)(J, K),\n              \"stroke-width\": q\n            }, E.setMedianRolloutAttr = {\n              stroke: E.median.color,\n              \"stroke-width\": E.median.borderWidth\n            }), a = E.toolTipValue, l = (0, n.getValidValue)((0, n.parseUnsafeString)((0, n.pluck)(C.tooltext, Ne.plottooltext, _e.plottooltext))), o ? null === a ? u = !1 : void 0 !== l ? (s = [1, 2, 3, 4, 5, 6, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80], r = {\n              maxValue: le,\n              maxDataValue: Ge.dataLabels(le),\n              minValue: ie,\n              minDataValue: Ge.dataLabels(ie),\n              Q1: Ge.dataLabels(ae),\n              unformattedQ1: ae,\n              Q3: Ge.dataLabels(re),\n              unformattedQ3: re,\n              median: Ge.dataLabels(se),\n              unformattedMedian: se,\n              SD: Ge.dataLabels(pe),\n              unformattedsd: pe,\n              QD: Ge.dataLabels(he),\n              unformattedQD: he,\n              MD: Ge.dataLabels(ue),\n              unformattedMD: ue,\n              mean: Ge.dataLabels(ce),\n              unformattedMean: ce,\n              label: T,\n              yaxisName: Ie,\n              xaxisName: Be,\n              formattedValue: a,\n              value: T\n            }, u = (0, n.parseTooltext)(l, s, r, C, _e, Ne)) : u = \"<b>Maximum\" + Re + \"</b>\" + Ge.dataLabels(le) + \"<br /><b>Q3\" + Re + \"</b>\" + Ge.dataLabels(re) + \"<br /><b>Median\" + Re + \"</b>\" + Ge.dataLabels(se) + \"<br /><b>Q1\" + Re + \"</b>\" + Ge.dataLabels(ae) + \"<br /><b>Minimum\" + Re + \"</b>\" + Ge.dataLabels(ie) : u = !1, E.toolText = u, E.setTooltext = u, c && (m = c)) : E.setValue = void 0;\n          }\n\n          ye ? (ke = this._getOutLiersLimit(), He = Math.max(He, ke.max), We = Math.min(We, ke.min)) : (xe = He - We, He += Ce.outliersupperrangeratio * xe, We -= Ce.outlierslowerrangeratio * xe), Ce.maxValue = He, Ce.minValue = We, this.setState(\"dirty\", !0), this._createSubDS(), Ae.showLegend && this._addLegend();\n        }, t.prototype._createSubDS = function () {\n          var e = this.config.index,\n              t = this.getFromEnv(\"lineJSON\")[e],\n              o = t.length;\n          (0, n.datasetFactory)(this, r[\"default\"], \"dataset\", o, t, function (e, t) {\n            for (var o = []; t;) {\n              o.unshift(e + Number(\".\" + t)), t--;\n            }\n\n            return o;\n          }(e, o)), o || this.iterateComponents(function (e) {\n            \"line\" === e.getName() && e.remove();\n          });\n        }, t.prototype._getOutLiersLimit = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n = this.config.index,\n              i = this.getFromEnv(\"lineJSON\")[n],\n              l = i.length,\n              s = -Infinity,\n              c = +Infinity;\n\n          for (r = 0; r < l; r++) {\n            if (\"Outliers\" === (e = i[r]).seriesname) {\n              for (t = (a = e.data).length, o = 0; o < t; o++) {\n                s = Math.max(a[o].value, s), c = Math.min(a[o].value, c);\n              }\n\n              return {\n                max: s,\n                min: c\n              };\n            }\n          }\n\n          return {\n            max: s,\n            min: c\n          };\n        }, t.prototype.parsePlotAttributes = function (e, t) {\n          var o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              v,\n              w,\n              k,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H,\n              W,\n              z,\n              U,\n              J,\n              K,\n              q,\n              Y,\n              X,\n              Q,\n              Z,\n              $,\n              ee,\n              te,\n              oe,\n              ae,\n              re,\n              ne,\n              ie,\n              le,\n              se,\n              ce,\n              ue,\n              pe,\n              he = this.config.JSONData,\n              de = this.config,\n              ge = de.index,\n              fe = t,\n              me = this.getState(\"visible\"),\n              ve = this.getFromEnv(\"chart\"),\n              be = this.getFromEnv(\"chartConfig\"),\n              ye = this.getFromEnv(\"xAxis\"),\n              xe = this.getFromEnv(\"yAxis\"),\n              we = this.components.data,\n              ke = be.dataLabelStyle,\n              Ce = de.rotatevalues,\n              Ne = de.valuepadding,\n              Se = this.getFromEnv(\"number-formatter\"),\n              Ee = Ce ? n.POSITION_LEFT : n.POSITION_MIDDLE,\n              Ae = this.getFromEnv(\"smartLabel\"),\n              De = +Infinity;\n\n          r = this.getFromEnv(\"columnXShift\"), a = this.getFromEnv(\"columnWidth\"), s = (c = e && e.config) && c.setValue, void 0 !== e && void 0 !== s && null !== s && (I = e.graphics, l = c.setLink, e.graphics || (we[fe].graphics = {}), I.label || (we[fe].graphics.label = []), o = ye.getPixel(fe) + r, h = ((p = (u = c.upperQuartile || {}) && u.value) || 0 === p) && xe.getPixel(p), w = ((v = (d = c.lowerQuartile || {}) && d.value) || 0 === v) && xe.getPixel(v), T = (D = ((A = (k = c.median) && k.value) || 0 === A) && xe.getPixel(A)) - h, L = w - D, _ = c.upperBoxBorder || {}, P = c.lowerBoxBorder || {}, i = c.toolText, c.eventArgs = {\n            index: fe,\n            link: l,\n            maximum: c.max,\n            minimum: c.min,\n            median: A,\n            q3: u.value,\n            q1: d.value,\n            maxDisplayValue: c.showMaxValues ? Se.dataLabels(c.max) : n.BLANKSTRING,\n            minDisplayValue: c.showMinValues ? Se.dataLabels(c.min) : n.BLANKSTRING,\n            medianDisplayValue: c.showMedianValues ? Se.dataLabels(A) : n.BLANKSTRING,\n            q1DisplayValue: c.showQ1Values ? Se.dataLabels(d.value) : n.BLANKSTRING,\n            q3DisplayValue: c.showQ3Values ? Se.dataLabels(u.value) : n.BLANKSTRING,\n            categoryLabel: c.label,\n            toolText: i,\n            datasetIndex: ge,\n            datasetName: he.seriesname,\n            visible: me\n          }, O = Math.round(o) + _.borderWidth % 2 * .5, V = Math.round(o + a) + _.borderWidth % 2 * .5, M = Math.round(h) + u.borderWidth % 2 * .5, a = V - O, F = {\n            upperBox: {\n              fill: (0, n.toRaphaelColor)(c.upperColorArr[0]),\n              \"stroke-width\": 0,\n              \"stroke-dasharray\": \"none\",\n              cursor: l ? g : n.BLANKSTRING,\n              visibility: me\n            },\n            lowerBox: {\n              fill: (0, n.toRaphaelColor)(c.lowerColorArr[0]),\n              \"stroke-width\": 0,\n              \"stroke-dasharray\": \"none\",\n              cursor: l ? g : f,\n              visibility: me\n            },\n            upperBoxBorder: {\n              stroke: _.color,\n              \"stroke-width\": _.borderWidth,\n              \"stroke-linecap\": m,\n              dashstyle: _.dashStyle,\n              visibility: me\n            },\n            lowerBoxBorder: {\n              stroke: P.color,\n              \"stroke-width\": P.borderWidth,\n              dashstyle: P.dashStyle,\n              \"stroke-linecap\": m,\n              visibility: me\n            },\n            upperQuartile: {\n              stroke: (0, n.toRaphaelColor)(u.color),\n              \"stroke-width\": u.borderWidth,\n              \"stroke-dasharray\": u.dashSyle,\n              \"stroke-linecap\": m,\n              cursor: l ? g : f,\n              visibility: me\n            },\n            lowerQuartile: {\n              stroke: (0, n.toRaphaelColor)(d.color),\n              \"stroke-width\": d.borderWidth,\n              \"stroke-dasharray\": d.dashSyle,\n              cursor: l ? g : n.BLANKSTRING,\n              \"stroke-linecap\": m,\n              visibility: me\n            },\n            median: {\n              stroke: (0, n.toRaphaelColor)(k.color),\n              \"stroke-width\": k.borderWidth,\n              \"stroke-dasharray\": k.dashSyle,\n              cursor: l ? g : n.BLANKSTRING,\n              \"stroke-linecap\": m,\n              visibility: me\n            }\n          }, se = M, ee = Object.assign({\n            x: O,\n            y: M,\n            width: Math.max(a, 0),\n            height: Math.max(Math.min(De, T), 0),\n            r: 0\n          }, F.upperBox), $ = Object.assign({\n            path: [N, O, M, E, M + T, N, V, M, E, M + T]\n          }, F.upperBoxBorder), te = Object.assign({\n            path: [N, O, M, S, O + a]\n          }, F.upperQuartile), B = M, R = a * (de.whiskerslimitswidthratio / 100) / 2, H = j = xe.getPixel(c.max), G = O, H = Math.round(j) + c.upperWhiskerThickness % 2 / 2, O = Math.round(O + a / 2) + c.upperWhiskerThickness % 2 / 2, oe = {\n            path: W = [N, O, B, E, Math.min(H, se), N, O - R, Math.min(H, se), S, O + R],\n            \"stroke-width\": c.upperWhiskerThickness,\n            cursor: l ? g : n.BLANKSTRING,\n            \"stroke-linecap\": m,\n            stroke: c.upperWhiskerColor\n          }, Ae.useEllipsesOnOverflow(ve.config.useEllipsesWhenOverflow), Ae.setStyle(ke), z = Ae.getOriSize(Se.dataLabels(c.max)), U = Ce ? z.width : z.height, (K = j - .5 * c.upperWhiskerThickness - Ne - U * (Ce ? .5 : 1)) - (Ce ? U / 2 : 0) < be.canvasTop && (K = be.canvasTop + (Ce ? U / 2 : 0)), ae = {\n            text: Se.dataLabels(c.max),\n            x: G + a / 2,\n            title: u.originalText || n.BLANKSTRING,\n            y: K,\n            \"text-anchor\": Ce ? n.POSITION_MIDDLE : Ee,\n            \"vertical-align\": Ce ? n.POSITION_MIDDLE : x,\n            visibility: n.visibleStr,\n            direction: de.textDirection,\n            fill: ke.color,\n            transform: (0, n.getSuggestiveRotation)(Ce, G + a / 2, K),\n            \"text-bound\": [ke.backgroundColor, ke.borderColor, ke.borderThickness, ke.borderPadding, ke.borderRadius, ke.borderDash]\n          }, O = Math.round(o) + P.borderWidth % 2 * .5, V = Math.round(o + a) + P.borderWidth % 2 * .5, M = Math.round(D + L) + d.borderWidth % 2 * .5, pe = (ce = D) + (ue = Math.max(Math.min(De, M - D), 0)), Y = Object.assign({\n            x: O,\n            y: ce,\n            width: Math.max(a, 0),\n            height: ue,\n            r: 0\n          }, F.lowerBox), q = Object.assign({\n            path: [N, O, D, E, D + L, N, V, D, E, D + L]\n          }, F.lowerBoxBorder), M = Math.round(D + L) + d.borderWidth % 2 * .5, X = Object.assign({\n            path: [N, O, M, S, O + a]\n          }, F.lowerQuartile), B = M, R = a * (de.whiskerslimitswidthratio / 100) / 2, H = j = xe.getPixel(c.min), G = O, H = Math.round(j) + c.lowerWhiskerThickness % 2 / 2, G = Math.round(G + a / 2) + c.lowerWhiskerThickness % 2 / 2, W = [N, G, B, E, Math.max(H, pe), N, G - R, Math.max(H, pe), S, G + R], Ae.setStyle(ke), z = Ae.getOriSize(Se.dataLabels(c.min)), U = Ce ? z.width : z.height, (J = j + .5 * c.lowerWhiskerThickness + Ne) + U > be.canvasBottom && (J = be.canvasBottom - U), re = {\n            text: Se.dataLabels(c.min),\n            x: G,\n            title: u.originalText || n.BLANKSTRING,\n            y: J,\n            \"text-anchor\": Ce ? C : Ee,\n            \"vertical-align\": Ce ? n.POSITION_MIDDLE : x,\n            visibility: n.visibleStr,\n            direction: de.textDirection,\n            fill: ke.color,\n            transform: (0, n.getSuggestiveRotation)(Ce, G, J),\n            \"text-bound\": [ke.backgroundColor, ke.borderColor, ke.borderThickness, ke.borderPadding, ke.borderRadius, ke.borderDash]\n          }, Q = {\n            path: W,\n            \"stroke-width\": c.lowerWhiskerThickness,\n            cursor: l ? g : n.BLANKSTRING,\n            \"stroke-linecap\": m,\n            stroke: c.lowerWhiskerColor\n          }, M = Math.round(D) + k.borderWidth % 2 * .5, Z = Object.assign({\n            path: [N, O, M, S, O + a]\n          }, F.median), Ee = Ce ? n.POSITION_LEFT : n.POSITION_MIDDLE, ne = {\n            text: u.displayValue,\n            x: o + a / 2,\n            title: u.originalText || n.BLANKSTRING,\n            y: h - Ne,\n            \"text-anchor\": Ce ? b : Ee,\n            \"vertical-align\": Ce ? n.POSITION_MIDDLE : y,\n            visibility: n.visibleStr,\n            direction: de.textDirection,\n            fill: ke.color,\n            transform: (0, n.getSuggestiveRotation)(Ce, o + a / 2, h - Ne),\n            \"text-bound\": [ke.backgroundColor, ke.borderColor, ke.borderThickness, ke.borderPadding, ke.borderRadius, ke.borderDash]\n          }, le = {\n            text: k.displayValue,\n            x: O + a / 2,\n            y: D - Ne,\n            title: k.originalText || n.BLANKSTRING,\n            \"text-anchor\": Ce ? b : Ee,\n            \"vertical-align\": Ce ? n.POSITION_MIDDLE : y,\n            visibility: n.visibleStr,\n            direction: de.textDirection,\n            fill: ke.color,\n            transform: (0, n.getSuggestiveRotation)(Ce, O + a / 2, D - Ne),\n            \"text-bound\": [ke.backgroundColor, ke.borderColor, ke.borderThickness, ke.borderPadding, ke.borderRadius, ke.borderDash]\n          }, ie = {\n            text: d.displayValue,\n            x: o + a / 2,\n            y: w + Ne,\n            title: d.originalText || n.BLANKSTRING,\n            \"text-anchor\": Ce ? b : Ee,\n            \"vertical-align\": Ce ? n.POSITION_MIDDLE : x,\n            visibility: n.visibleStr,\n            direction: de.textDirection,\n            fill: ke.color,\n            transform: (0, n.getSuggestiveRotation)(Ce, o + a / 2, w + Ne),\n            \"text-bound\": [ke.backgroundColor, ke.borderColor, ke.borderThickness, ke.borderPadding, ke.borderRadius, ke.borderDash]\n          }, c.props = {\n            lowerBoxBorderEle: {\n              attr: q\n            },\n            lowerBoxElem: {\n              attr: Y\n            },\n            lowerQuartileEle: {\n              attr: X\n            },\n            lowerWhiskerEle: {\n              attr: Q\n            },\n            midLineElem: {\n              attr: Z\n            },\n            upperBoxElem: {\n              attr: ee\n            },\n            upperBoxBorderEle: {\n              attr: $\n            },\n            upperQuartileEle: {\n              attr: te\n            },\n            upperWhiskerEle: {\n              attr: oe\n            },\n            upperQuartileMaxLabel: {\n              attr: ae\n            },\n            upperQuartileMinLabel: {\n              attr: re\n            },\n            medianLabel: {\n              attr: le\n            },\n            upperQuartileLabel: {\n              attr: ne\n            },\n            lowerQuartileLabel: {\n              attr: ie\n            }\n          });\n        }, t.prototype.allocatePosition = function () {\n          var e,\n              t,\n              o,\n              a = this.config.JSONData.data,\n              r = a && a.length,\n              n = this.getFromEnv(\"xAxis\").getTicksLen(),\n              i = this.components.data;\n\n          for (o = Math.min(n, r), this.setColumnPosition(), t = 0; t < o; t++) {\n            e = i[t], this.parsePlotAttributes(e, t);\n          }\n        }, t.prototype.drawPlots = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              g,\n              m,\n              b,\n              y,\n              x,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H,\n              W,\n              z,\n              U,\n              J,\n              K,\n              q,\n              Y,\n              X,\n              Q,\n              Z,\n              $,\n              ee,\n              te,\n              oe = this,\n              ae = oe.config.JSONData,\n              re = oe.config,\n              ne = re.index,\n              ie = ae.data,\n              le = ie && ie.length,\n              se = oe.getState(\"visible\"),\n              ce = oe.getFromEnv(\"chart\"),\n              ue = oe.getFromEnv(\"xAxis\").getTicksLen(),\n              pe = re.showtooltip,\n              he = oe.getFromEnv(\"toolTipController\"),\n              de = oe.components.data,\n              ge = re.showShadow,\n              fe = oe.getContainer(\"upperBoxGroup\").toBack(),\n              me = oe.getContainer(\"lowerBoxGroup\"),\n              ve = oe.getContainer(\"medianGroup\"),\n              be = oe.getContainer(\"upperWhiskerGroup\"),\n              ye = oe.getContainer(\"lowerWhiskerGroup\"),\n              xe = oe.getContainer(\"labelGroup\"),\n              we = oe.getContainer(\"shadowGroup\"),\n              ke = oe.getFromEnv(\"smartLabel\"),\n              Ce = (oe.components.removeDataArr || []).length,\n              Ne = re.showHoverEffect,\n              Se = oe.getFromEnv(\"animationManager\"),\n              Ee = function Ee(e) {\n            return function (t) {\n              ce.plotEventHandler(e, t);\n            };\n          },\n              Ae = function Ae(e, t) {\n            return function (o) {\n              var a;\n              if (0 !== t.data(w)) for (a in e) {\n                a !== h && (Se.setAnimation({\n                  el: e[a],\n                  doNotRemove: !0,\n                  attr: t.data(\"setRolloverAttr\")[a],\n                  component: oe\n                }), ce.plotEventHandler(t, o, \"DataPlotRollOver\"));\n              }\n            };\n          },\n              De = function De(e, t) {\n            return function (o) {\n              var a;\n              if (0 !== t.data(w)) for (a in e) {\n                a !== h && (Se.setAnimation({\n                  el: e[a],\n                  doNotRemove: !0,\n                  attr: t.data(\"setRolloutAttr\")[a],\n                  component: oe\n                }), ce.plotEventHandler(t, o, \"DataPlotRollOut\"));\n              }\n            };\n          };\n\n          for (s = function s(e) {\n            return function () {\n              this.show(), this.shadow(e);\n            };\n          }, oe.setColumnPosition(), se ? (fe.show(), me.show(), be.show(), ye.show(), ve.show(), we.show(), xe.show(), oe._conatinerHidden = !1) : (xe.hide(), be.hide(), fe.hide(), ye.hide(), me.hide(), ve.hide(), we.hide()), e = Math.min(ue, le), t = 0; t < e; t++) {\n            if (r = (i = (a = de[t]) && a.config) && i.setValue, H = !1, W = !1, z = !1, U = !1, J = !1, K = !1, q = !1, Y = !1, X = !1, void 0 !== a && void 0 !== r && null !== r) V = a.graphics, a.graphics || (de[t].graphics = {}), V.label || (de[t].graphics.label = []), l = i.upperQuartile || {}, c = i.lowerQuartile || {}, u = i.median, o = i.toolText, M = ne + d + t, g = a.graphics.upperBoxElem, p = Se.setAnimation({\n              el: g || \"rect\",\n              attr: i.props.upperBoxElem.attr,\n              label: \"upperBox\",\n              container: fe,\n              component: oe\n            }), g || (a.graphics.upperBoxElem = p, H = !0), p.shadow({\n              opacity: ge ? re.upperBoxAlpha / 100 : 0\n            }, we), b = a.graphics.upperBoxBorderEle, m = Se.setAnimation({\n              el: b || \"path\",\n              attr: i.props.upperBoxBorderEle.attr,\n              container: fe,\n              label: \"path\",\n              component: oe\n            }), b || (a.graphics.upperBoxBorderEle = m, z = !0), x = a.graphics.upperQuartileEle, y = Se.setAnimation({\n              el: x || \"path\",\n              attr: i.props.upperQuartileEle.attr,\n              label: \"path\",\n              container: fe,\n              component: oe\n            }), x || (a.graphics.upperQuartileEle = y, J = !0), I = a.graphics.upperWhiskerEle, F = Se.setAnimation({\n              el: I || \"path\",\n              attr: i.props.upperWhiskerEle.attr,\n              label: \"path\",\n              container: be,\n              component: oe\n            }), s({\n              opacity: i.upperWhiskerShadowOpacity\n            }), I || (a.graphics.upperWhiskerEle = F, Y = !0), ke.useEllipsesOnOverflow(ce.config.useEllipsesWhenOverflow), i.showMaxValues ? ((O = V.label[3]) && O.show(), P = Se.setAnimation({\n              el: O || \"text\",\n              attr: i.props.upperQuartileMaxLabel.attr,\n              component: oe,\n              label: \"text\",\n              container: xe\n            }), O || (V.label[3] = P), V.label[3].data(v, M)) : V.label[3] && Se.setAnimation({\n              el: V.label[3],\n              component: oe,\n              attr: {\n                \"text-bound\": []\n              },\n              callback: L.call(V.label[3])\n            }), N = a.graphics.lowerBoxElem, C = Se.setAnimation({\n              el: N || \"rect\",\n              attr: i.props.lowerBoxElem.attr,\n              label: \"lowerBox\",\n              container: me,\n              component: oe\n            }), N || (a.graphics.lowerBoxElem = C, W = !0), C.shadow({\n              opacity: ge ? re.lowerBoxAlpha / 100 : 0\n            }, we), E = a.graphics.lowerBoxBorderEle, S = Se.setAnimation({\n              el: E || \"path\",\n              attr: i.props.lowerBoxBorderEle.attr,\n              component: oe,\n              label: \"path\",\n              container: me\n            }), E || (a.graphics.lowerBoxBorderEle = S, U = !0), D = a.graphics.lowerQuartileEle, A = Se.setAnimation({\n              el: D || \"path\",\n              attr: i.props.lowerQuartileEle.attr,\n              component: oe,\n              label: \"path\",\n              container: me\n            }), D || (a.graphics.lowerQuartileEle = A, K = !0), B = a.graphics.lowerWhiskerEle, i.showMinValues ? ((O = V.label[4]) && O.show(), P = Se.setAnimation({\n              el: O || \"text\",\n              attr: i.props.upperQuartileMinLabel.attr,\n              label: \"text\",\n              container: xe,\n              component: oe\n            }), O || (V.label[4] = P), V.label[4].data(v, M)) : V.label[4] && Se.setAnimation({\n              el: V.label[4],\n              component: oe,\n              attr: {\n                \"text-bound\": []\n              },\n              callback: L.call(V.label[4])\n            }), R = a.graphics.lowerWhiskerEle, B = Se.setAnimation({\n              el: R || \"path\",\n              attr: i.props.lowerWhiskerEle.attr,\n              label: \"path\",\n              container: ye,\n              component: oe,\n              callback: s({\n                opacity: i.lowerWhiskerShadowOpacity\n              })\n            }), R || (a.graphics.lowerWhiskerEle = B, X = !0), _ = a.graphics.midLineElem, T = Se.setAnimation({\n              el: _ || \"path\",\n              component: oe,\n              label: \"midline\",\n              container: ve,\n              attr: i.props.midLineElem.attr\n            }), _ || (a.graphics.midLineElem = T, q = !0), Q = {\n              upperBoxElem: i.setUpperBoxRolloverAttr,\n              lowerBoxElem: i.setLowerBoxRolloverAttr,\n              upperBoxBorderEle: i.setUpperBoxBorderRolloverAttr,\n              lowerBoxBorderEle: i.setLowerBoxBorderRolloverAttr,\n              upperQuartileEle: i.setUpperQuartileRolloverAttr,\n              lowerQuartileEle: i.setLowerQuartileRolloverAttr,\n              midLineElem: i.setMedianRolloverAttr\n            }, Z = {\n              upperBoxElem: i.setUpperBoxRolloutAttr,\n              lowerBoxElem: i.setLowerBoxRolloutAttr,\n              upperBoxBorderEle: i.setUpperBoxBorderRolloutAttr,\n              lowerBoxBorderEle: i.setLowerBoxBorderRolloutAttr,\n              upperQuartileEle: i.setUpperQuartileRolloutAttr,\n              lowerQuartileEle: i.setLowerQuartileRolloutAttr,\n              midLineElem: i.setMedianRolloutAttr\n            }, p.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), H && (p.on(\"click\", Ee(p)), p.on(\"mouseover\", Ae(a.graphics, p)), p.on(\"mouseout\", De(a.graphics, p))), C.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), W && (C.on(\"click\", Ee(C)), C.on(\"mouseover\", Ae(a.graphics, C)), C.on(\"mouseout\", De(a.graphics, C))), m.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), z && (m.on(\"click\", Ee(m)), m.on(\"mouseover\", Ae(a.graphics, m)), m.on(\"mouseout\", De(a.graphics, m))), S.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), U && (S.on(\"click\", Ee(S)), S.on(\"mouseover\", Ae(a.graphics, S)), S.on(\"mouseout\", De(a.graphics, S))), y.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), J && (y.on(\"click\", Ee(y)), y.on(\"mouseover\", Ae(a.graphics, y)), y.on(\"mouseout\", De(a.graphics, y))), A.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), K && (A.on(\"click\", Ee(A)), A.on(\"mouseover\", Ae(a.graphics, A)), A.on(\"mouseout\", De(a.graphics, A))), T.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), q && (T.on(\"click\", Ee(T)), T.on(\"mouseover\", Ae(a.graphics, T)), T.on(\"mouseout\", De(a.graphics, T))), F.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), Y && (F.on(\"click\", Ee(F)), F.on(\"mouseover\", Ae(a.graphics, F)), F.on(\"mouseout\", De(a.graphics, F))), B.data(v, M).data(k, i.eventArgs).data(w, Ne).data(\"setRolloverAttr\", Q).data(\"setRolloutAttr\", Z), X && (B.on(\"click\", Ee(B)), B.on(\"mouseover\", Ae(a.graphics, B)), B.on(\"mouseout\", De(a.graphics, B))), (0, n.defined)(l.displayValue) && l.displayValue !== f && i.showQ3Values ? ((O = V.label[0]) && O.show(), P = Se.setAnimation({\n              el: O || \"text\",\n              attr: i.props.upperQuartileLabel.attr,\n              component: oe,\n              label: \"text\",\n              container: xe\n            }), O || (V.label[0] = P), V.label[0].data(v, M)) : V.label[0] && Se.setAnimation({\n              el: V.label[0],\n              component: oe,\n              attr: {\n                \"text-bound\": []\n              },\n              callback: L.call(V.label[0])\n            }), (0, n.defined)(u.displayValue) && u.displayValue !== f && i.showMedianValues ? ((O = V.label[1]) && O.show(), P = Se.setAnimation({\n              el: O || \"text\",\n              attr: i.props.medianLabel.attr,\n              component: oe,\n              label: \"text\",\n              container: xe\n            }), O || (V.label[1] = P), V.label[1].data(v, M)) : V.label[1] && Se.setAnimation({\n              el: V.label[1],\n              component: oe,\n              attr: {\n                \"text-bound\": []\n              },\n              callback: L.call(V.label[1])\n            }), (0, n.defined)(c.displayValue) && c.displayValue !== f && i.showQ1Values ? (O = V.label[2], P = Se.setAnimation({\n              el: O || \"text\",\n              component: oe,\n              attr: i.props.lowerQuartileLabel.attr,\n              container: xe\n            }), O || (V.label[2] = P, P.show()), V.label[2].data(v, M)) : V.label[2] && Se.setAnimation({\n              el: V.label[2],\n              component: oe,\n              attr: {\n                \"text-bound\": []\n              },\n              callback: L.call(V.label[2])\n            }), pe ? (he.enableToolTip(p, o), he.enableToolTip(C, o), he.enableToolTip(m, o), he.enableToolTip(S, o), he.enableToolTip(y, o), he.enableToolTip(A, o), he.enableToolTip(T, o), he.enableToolTip(F, o), he.enableToolTip(B, o)) : (he.enableToolTip(p, !1), he.enableToolTip(C, !1), he.enableToolTip(m, !1), he.enableToolTip(S, !1), he.enableToolTip(y, !1), he.enableToolTip(A, !1), he.enableToolTip(T, !1), he.enableToolTip(F, !1), he.enableToolTip(B, !1));else for (j in G = a.graphics) {\n              if (G[j] instanceof Array) for ($ = 0, te = (ee = G[j]).length; $ < te; $++) {\n                ee[$] && ee[$].hide();\n              } else G[j].hide();\n            }\n          }\n\n          !1 !== oe.getState(\"visible\") || !1 !== oe._conatinerHidden && void 0 !== oe._conatinerHidden || (fe.hide(), me.hide(), be.hide(), ye.hide(), ve.hide(), we.hide(), xe && xe.hide(), oe._conatinerHidden = !0), Ce && oe.removePlots();\n        }, t.prototype.removePlots = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i = this.components.removeDataArr,\n              l = this.getFromEnv(\"animationManager\"),\n              s = i.length;\n\n          for (a = 0; a < s; a++) {\n            if (e = i[0], i.splice(0, 1), e && e.graphics) for (t in o = e.graphics) {\n              if (t !== h) o[t].shadow({\n                opacity: 0\n              }), o[t].hide();else for (r = o[t].length, n = 0; n < r; n++) {\n                o[t][n] && (o[t][n].shadow({\n                  opacity: 0\n                }), l.setAnimation({\n                  el: o[t][n],\n                  component: this,\n                  attr: {\n                    \"text-bound\": []\n                  },\n                  callback: L.call(o[t][n])\n                }));\n              }\n            }\n          }\n        }, t.prototype.removeData = function (e, t, o) {\n          var a = this.components,\n              r = a.data,\n              n = a.removeDataArr || (a.removeDataArr = []);\n          t = t || 1, (e = e || 0) + t === r.length ? this.endPosition = !0 : 0 !== e && void 0 !== e || (this.endPosition = !1), a.removeDataArr = n = n.concat(r.splice(e, t)), o && this.asyncDraw();\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.showplotborder = void 0, t.plotborderdashlen = void 0, t.plotborderdashgap = void 0, t.plotfillalpha = void 0, t.useroundedges = void 0, t.ratio = void 0, t.plotborderthickness = void 0, t.showvalues = void 0, t.valuepadding = void 0, t.showtooltip = void 0, t.maxcolwidth = void 0, t.rotatevalues = void 0, t.use3dlighting = void 0, t.whiskerslimitswidthratio = void 0, t.outliersupperrangeratio = void 0, t.outlierslowerrangeratio = void 0, t.showalloutliers = void 0, t.showmean = void 0, t.showsd = void 0, t.showmd = void 0, t.showqd = void 0, t.showminvalues = void 0, t.showmaxvalues = void 0, t.showq1values = void 0, t.showq3values = void 0, t.showmedianvalues = void 0;\n        }, t.prototype.getDataLimits = function () {\n          var e = this.config,\n              t = this.getState(\"removed\");\n          return {\n            max: t ? -Infinity : e.maxValue,\n            min: t ? +Infinity : e.minValue\n          };\n        }, t.prototype._addLegend = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.config,\n              i = this.getFromEnv(\"legend\"),\n              l = r.upperBoxColor,\n              s = r.lowerBoxColor;\n          e = p, t = {\n            FCcolor: {\n              color: l + n.COMMA + s,\n              angle: 90,\n              ratio: \"50, 0\",\n              alpha: \"100, 100\"\n            }\n          }, o = {\n            label: (0, n.getFirstValue)(this.config.JSONData.seriesname),\n            index: this.getJSONIndex(),\n            mainDS: !0\n          }, r.includeInLegend ? ((a = i.getItem(this.config.legendItemId)) || (this.config.legendItemId = i.createItem(this), a = i.getItem(this.config.legendItemId), this.addExtEventListener(\"click\", function () {\n            a.itemClickFn();\n          }, a)), a.configure(o), a.setStateCosmetics(\"default\", {\n            symbol: {\n              fill: (0, n.toRaphaelColor)(t),\n              rawFillColor: r.upperBoxColor,\n              stroke: (0, n.toRaphaelColor)(e)\n            },\n            background: {\n              legendBackgroundColor: (0, n.toRaphaelColor)(l),\n              alpha: 20\n            }\n          }), this.getState(\"visible\") ? a.removeLegendState(\"hidden\") : a.setLegendState(\"hidden\")) : this.config.legendItemId && i.disposeItem(this.config.legendItemId), this._mapChildren(function (e) {\n            e.addToEnv(\"legendBackgroundColor\", l), e && e._addLegend(!0);\n          });\n        }, t.prototype.legendInteractivity = function () {\n          var e,\n              t,\n              o = this.getChildren(\"dataset\");\n\n          for (e = this.getState(\"visible\") ? \"hide\" : \"show\", t = 0; t < (o && o.length); t++) {\n            o[t][e]();\n          }\n\n          this[e]();\n        }, t.prototype.drawLabel = function () {\n          return this;\n        }, t.prototype.getName = function () {\n          return \"boxandwhisker2D\";\n        }, t.prototype.childChanged = function () {\n          return this;\n        }, t.prototype.show = function () {\n          e.prototype.show.call(this);\n        }, t.prototype.hide = function () {\n          e.prototype.hide.call(this);\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = _;\n    },\n    566: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = l(o(346)),\n          r = o(118),\n          n = o(125),\n          i = l(o(567));\n\n      function l(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function s(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var c = r.preDefStr.POLYGON,\n          u = r.preDefStr.SPOKE,\n          p = function p(e, t, o) {\n        return o.getFromEnv(\"animationManager\").setAnimation({\n          el: \"group\",\n          attr: e,\n          container: t,\n          component: o,\n          label: \"group\"\n        });\n      };\n\n      (0, n.addDep)({\n        name: \"boxandwhiskerlineAnimation\",\n        type: \"animationRule\",\n        extension: i[\"default\"]\n      });\n\n      var h = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return s(t, e), t.prototype.getName = function () {\n          return \"boxandwhiskerline\";\n        }, t.prototype.createCoordinates = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n = this.components.data,\n              i = this.getFromEnv(\"yAxis\"),\n              l = this.getFromEnv(\"xAxis\"),\n              s = n.length,\n              c = this.components.data,\n              u = this.getFromEnv(\"columnXShift\"),\n              p = this.getFromEnv(\"columnWidth\");\n\n          for (o = 0; o < s; o++) {\n            t = (e = c[o]) && e.config, void 0 !== e && (a = l.getPixel(t._x), r = i.getPixel(t._y), t._Px = a + u + p / 2, t._Py = r);\n          }\n        }, t.prototype.getAllPlots = function (e, t) {\n          var o,\n              a = this.components.data,\n              r = [],\n              n = void 0;\n\n          for (n = 0, o = a.length; n < o; n++) {\n            (a[n].config._x >= e || a[n].config._x <= t) && r.push(a[n]);\n          }\n\n          return r;\n        }, t.prototype.calculateScrollRange = function () {\n          var e = this.config,\n              t = this.components.data;\n          e.scrollMinVal = 0, e.scrollMaxVal = t.length, e.scrollMinValForLabel = e.scrollMinVal, e.scrollMaxValForLabel = e.scrollMaxVal;\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s = this.getFromEnv(\"xAxis\"),\n              c = this.components.data.length,\n              u = this.config,\n              p = u && u.radius || 0;\n\n          for (e += s.getTranslation(), a = Math.floor(Math.max(s.getValue(e - p), 0)), r = Math.ceil(Math.min(s.getValue(e + p), c - 1)), i = (l = this.getAllPlots(a, r)).length; i >= 0 && (!(o = l[i]) || !(n = this.isWithinShape(o, i, e, t))); i--) {\n            ;\n          }\n\n          return n;\n        }, t.prototype._addLegend = function (e) {\n          if (e) {\n            var t,\n                o,\n                a = this.getFromEnv(\"chart\"),\n                n = this.config,\n                i = a.getChildren(\"legend\")[0],\n                l = (0, r.pluckNumber)(n.drawanchors, 1);\n            n.includeinlegend ? (o = {\n              anchorSide: l ? n.anchorsides : 0,\n              label: (0, r.getFirstValue)(n.JSONData.seriesname),\n              customLegendIcon: !1,\n              spoke: \"spoke\" === n.dip ? 1 : 0,\n              drawLine: !n.showline,\n              index: this.getJSONIndex()\n            }, (t = i.getItem(this.config.legendItemId)) || (this.config.legendItemId = i.createItem(this), t = i.getItem(this.config.legendItemId), this.addExtEventListener(\"click\", function () {\n              t.itemClickFn();\n            }, t)), t.configure(o), t.setStateCosmetics(\"default\", {\n              symbol: {\n                fill: (0, r.toRaphaelColor)({\n                  color: n.anchorbgcolor,\n                  alpha: n.anchorbgalpha\n                }),\n                rawFillColor: n.anchorbgcolor,\n                stroke: (0, r.toRaphaelColor)({\n                  color: n.anchorbordercolor,\n                  alpha: \"100\"\n                })\n              },\n              background: {\n                legendBackgroundColor: (0, r.toRaphaelColor)(this.getFromEnv(\"legendBackgroundColor\")),\n                alpha: 20\n              }\n            }), this.getState(\"visible\") ? t.removeLegendState(\"hidden\") : t.setLegendState(\"hidden\")) : this.config.legendItemId && i.disposeItem(this.config.legendItemId);\n          }\n        }, t.prototype.configureAttributes = function (t) {\n          e.prototype.configureAttributes.call(this, t);\n          var o = this.config.JSONData,\n              a = this.config;\n          this.setState(\"visible\", this.getLinkedParent().getState(\"visible\")), a.skipCommonElements = o.showline, a.dip = o.dip;\n        }, t.prototype.createContainer = function () {\n          var e,\n              t,\n              o = this.getType(),\n              a = this.groupName,\n              r = this.getLinkedParent().getLinkedParent(),\n              n = a || this.dsGroup || o;\n          !r.getChildContainer(n + \"VcanvasGroup\") && (n = \"default\"), e = r.getChildContainer(\"manager-defaultVcanvasGroup-lines\"), t = r.getChildContainer(n + \"ShadowVcanvasGroup\"), !this.getContainer(\"shadowGroup\") && this.addContainer(\"shadowGroup\", p({\n            name: \"shadow-group\"\n          }, t, this)), !this.getContainer(\"commonElemsGroup\") && this.addContainer(\"commonElemsGroup\", p({\n            name: \"common-elems-group\"\n          }, e, this)), !this.getContainer(\"plotGroup\") && this.addContainer(\"plotGroup\", p({\n            name: \"common-elems-group\"\n          }, e, this)), !this.getContainer(\"labelGroup\") && this.addContainer(\"labelGroup\", p({\n            name: \"label-group\",\n            \"class\": \"fusioncharts-datalabels\",\n            opacity: 1\n          }, r.getChildContainer(\"vcanvasLabelGroup\"), this));\n        }, t.prototype._setConfigure = function (t, o) {\n          e.prototype._setConfigure.call(this, t, o);\n\n          var a,\n              n,\n              i,\n              l,\n              s,\n              p = this.getFromEnv(\"chartConfig\"),\n              h = this.config.JSONData,\n              d = t || h.data || [],\n              g = d.length,\n              f = this.components.data;\n\n          for (l = 0; l < g; l++) {\n            t ? (a = t && t.data[l] || {}, n = void 0 !== o ? f[o + l] : f[f.length - g + l]) : (n = f[l], a = d && d[l] || {}), i = n && n.config, s = (0, r.pluck)(a.dip, h.dip), i.dip = s === c ? 0 : s === u ? 1 : 0, i.toolText = i.finalTooltext = \"<b>\" + h.seriesname + p.tooltipsepchar + \"</b>\" + i.displayValue;\n          }\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = h;\n    },\n    567: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.boxandwhiskerline\": function initialDatasetBoxandwhiskerline() {\n          return {\n            \"line.appearing\": [{\n              initialAttr: {\n                opacity: 0\n              },\n              finalAttr: {\n                opacity: 1\n              },\n              slot: \"plot\",\n              startEnd: {\n                start: .5,\n                end: 1\n              }\n            }],\n            \"anchor.appearing\": [{\n              initialAttr: {\n                opacity: 0\n              },\n              finalAttr: {\n                opacity: 1\n              },\n              slot: \"plot\",\n              startEnd: {\n                start: .5,\n                end: 1\n              }\n            }]\n          };\n        }\n      };\n    },\n    568: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.boxandwhisker2D\": function initialDatasetBoxandwhisker2D() {\n          return {\n            \"upperBox.appearing\": function upperBoxAppearing(e) {\n              return [{\n                initialAttr: {\n                  x: e.attr.x,\n                  y: e.attr.y + e.attr.height,\n                  height: 0,\n                  width: e.attr.width\n                },\n                slot: \"plot\",\n                startEnd: {\n                  start: 0,\n                  end: .5\n                }\n              }];\n            },\n            \"lowerBox.appearing\": function lowerBoxAppearing(e) {\n              return [{\n                initialAttr: {\n                  x: e.attr.x,\n                  y: e.attr.y,\n                  height: 0,\n                  width: e.attr.width\n                },\n                slot: \"plot\",\n                startEnd: {\n                  start: 0,\n                  end: .5\n                }\n              }];\n            },\n            \"path.appearing\": [{\n              initialAttr: {\n                opacity: 0\n              },\n              finalAttr: {\n                opacity: 1\n              },\n              slot: \"plot\",\n              startEnd: {\n                start: .5,\n                end: 1\n              }\n            }],\n            \"midline.appearing\": [{\n              initialAttr: {\n                opacity: 0\n              },\n              finalAttr: {\n                opacity: 1\n              },\n              slot: \"plot\",\n              startEnd: {\n                start: 0,\n                end: .2\n              }\n            }],\n            \"group.appearing\": function groupAppearing(e) {\n              return \"label-group\" === e.attr.name ? [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }] : [{\n                initialAttr: {\n                  opacity: 1\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }];\n            },\n            \"*\": null\n          };\n        }\n      };\n    },\n    569: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(402);\n\n      function n(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var i = \"manager-defaultVcanvasGroup-lines\",\n          l = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return n(t, e), t.prototype.createContainer = function () {\n          e.prototype.createContainer.call(this);\n          var t = this.getFromEnv(\"animationManager\"),\n              o = this.getLinkedParent().getChildContainer(\"defaultVcanvasGroup\");\n          !this.getChildContainer(i) && this.addChildContainer(i, t.setAnimation({\n            el: \"group\",\n            component: this,\n            attr: {\n              name: i\n            },\n            container: o\n          }));\n        }, t;\n      }(((a = r) && a.__esModule ? a : {\n        \"default\": a\n      })[\"default\"]);\n\n      t[\"default\"] = l;\n    },\n    570: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t,\n            o,\n            a,\n            n = e.getFromEnv(\"dataSource\").dataset,\n            l = void 0,\n            s = l = e.getChildren().canvas[0].getChildren(\"vCanvas\")[0],\n            c = e.config.defaultDatasetType || \"\";\n        n || e.setChartMessage(), t = e.getDSGroupdef(), (0, r.componentFactory)(l, t, \"datasetGroup_\" + c), (a = l.getChildren(\"datasetGroup_\" + c)) && (s = a[0]), o = e.getDSdef(), (0, r.componentFactory)(e, i[\"default\"], \"BoxAndWhiskerStatisticalCalc\"), l.getChildren(\"datasetGroup_\" + c)[0].addToEnv(\"BoxAndWhiskerStatisticalCalc\", e.getChildren(\"BoxAndWhiskerStatisticalCalc\")[0]), s.addToEnv(\"lineJSON\", e._getLineJSONdata()), (0, r.datasetFactory)(s, o, \"dataset\", n.length, n);\n      };\n      var a,\n          r = o(118),\n          n = o(571),\n          i = (a = n) && a.__esModule ? a : {\n        \"default\": a\n      };\n    },\n    571: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(131),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      },\n          i = o(118);\n\n      function l(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var s = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return l(t, e), t.prototype.setArray = function (e) {\n          var t,\n              o,\n              a = this.getFromEnv(\"number-formatter\"),\n              r = i.COMMASTRING,\n              n = 0;\n\n          for (!e && (e = i.BLANK), o = e.replace(/\\s/g, i.BLANK).split(r), t = this.dataLength = o && o.length; t--;) {\n            n += o[t] = a.getCleanValue(o[t]);\n          }\n\n          o && o.sort(function (e, t) {\n            return e - t;\n          }), this.values = o, this.mean = n / this.dataLength, this.getFrequencies();\n        }, t.prototype.getQuartiles = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              l = this.values,\n              s = this.dataLength,\n              c = s % 2;\n\n          switch (i.BLANKSTRING) {\n            case \"tukey\":\n              c ? (e = (s + 3) / 4, o = (3 * s + 1) / 4) : (e = (s + 2) / 4, o = (3 * s + 2) / 4);\n              break;\n\n            case \"mooremccabe\":\n              c ? o = 3 * (e = (s + 1) / 4) : (e = (s + 2) / 4, o = (3 * s + 2) / 4);\n              break;\n\n            case \"freundperles\":\n              e = (s + 3) / 4, o = (3 * s + 1) / 4;\n              break;\n\n            case \"mendenhallsincich\":\n              e = Math.round((s + 1) / 4), o = Math.round(3 * e);\n              break;\n\n            default:\n              o = 3 * (e = (s + 1) / 4);\n          }\n\n          return e -= 1, o -= 1, t = Math.floor(e), a = Math.floor(o), r = e - t ? l[t] + (l[Math.ceil(e)] - l[t]) * (e - t) : l[e], n = o - a ? l[a] + (l[Math.ceil(o)] - l[a]) * (o - a) : l[o], this.quartiles = {\n            q1: r,\n            q3: n\n          };\n        }, t.prototype.getMinMax = function () {\n          var e = this.values;\n          return {\n            min: e[0],\n            max: e[this.dataLength - 1]\n          };\n        }, t.prototype.getMean = function () {\n          return this.mean;\n        }, t.prototype.getMD = function () {\n          for (var e, t = this.mean, o = this.frequencies, a = o.length, r = 0; a--;) {\n            r += (e = o[a]).frequency * Math.abs(e.value - t);\n          }\n\n          return r / this.dataLength;\n        }, t.prototype.getSD = function () {\n          for (var e = this.mean, t = this.values, o = this.dataLength, a = o, r = 0; o--;) {\n            r += Math.pow(t[o] - e, 2);\n          }\n\n          return Math.sqrt(r / (a - 1));\n        }, t.prototype.getQD = function () {\n          return .5 * (this.quartiles.q3 - this.quartiles.q1);\n        }, t.prototype.getFrequencies = function () {\n          var e,\n              t,\n              o,\n              a = [],\n              r = this.dataLength,\n              n = this.values,\n              l = 0;\n\n          for (o = 0; o < r; o += 1) {\n            l += e = n[o], (0, i.defined)(a[o]) ? a[o].frequency += 1 : ((t = {}).value = e, t.frequency = 1, a[o] = t);\n          }\n\n          this.sum = l, this.frequencies = a;\n        }, t.prototype.getMedian = function () {\n          var e = this.dataLength,\n              t = .5 * e,\n              o = this.values;\n          return e % 2 == 0 ? (o[t] + o[t - 1]) / 2 : o[Math.floor(t)];\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = s;\n    },\n    572: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = h(o(354)),\n          r = h(o(573)),\n          n = h(o(575)),\n          i = h(o(576)),\n          l = h(o(356)),\n          s = h(o(577)),\n          c = h(o(582)),\n          u = o(118),\n          p = o(122);\n\n      function h(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function d(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var g = u.preDefStr.defaultFontStr,\n          f = u.preDefStr.divLineAlpha3DStr,\n          m = u.preDefStr.divLineAlphaStr,\n          v = u.preDefStr.altVGridColorStr,\n          b = u.preDefStr.altVGridAlphaStr,\n          y = u.preDefStr.altHGridColorStr,\n          x = u.preDefStr.altHGridAlphaStr,\n          w = u.preDefStr.colors.c000000,\n          k = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.tooltipsepchar = \" = \", o.hasGradientLegend = !0, o.registerFactory(\"axis\", i[\"default\"], [\"canvas\"]), o.registerFactory(\"legend\", c[\"default\"], [\"canvas\"]), o.registerFactory(\"colormanager-decider\", s[\"default\"], [\"legend\"]), o.registerFactory(\"dataset\", l[\"default\"], [\"colormanager-decider\", \"vCanvas\"]), o;\n        }\n\n        return d(t, e), t.getName = function () {\n          return \"HeatMap\";\n        }, t.prototype.getName = function () {\n          return \"HeatMap\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.isSingleSeries = !0, t.friendlyName = \"Heatmap Chart\", t.hasLegend = !0, t.defaultDatasetType = \"heatmap\", t.enablemousetracking = !0;\n        }, t.prototype._checkInvalidSpecificData = function () {\n          var e = this.getFromEnv(\"dataSource\"),\n              t = e.dataset,\n              o = e.colorrange;\n          if (!t || !o || !o.color && !Number(o.gradient)) return !0;\n        }, t.prototype.parseChartAttr = function (t) {\n          e.prototype.parseChartAttr.call(this, t), this.config.drawTrendRegion = 0;\n        }, t.prototype.configureAttributes = function (e) {\n          var t,\n              o,\n              a = this.config,\n              r = this.getFromEnv(\"dataSource\"),\n              n = this.config.skipConfigureIteration = {},\n              i = e.dataset,\n              l = [];\n\n          if (t = r.rows && r.rows.row.filter(function (e) {\n            return \"\" !== e.id && e.id !== undefined;\n          }), o = r.columns && r.columns.column.filter(function (e) {\n            return \"\" !== e.id && e.id !== undefined;\n          }), !t || !o) {\n            for (var s = 0; s < i.length; s++) {\n              for (var c = 0; c < i[s].data.length; c++) {\n                l.push(i[s].data[c]);\n              }\n            }\n\n            t || (t = l.map(function (e) {\n              return e.rowid;\n            }).filter(function (e, t, o) {\n              return o.indexOf(e) === t;\n            })), o || (o = l.map(function (e) {\n              return e.columnid;\n            }).filter(function (e, t, o) {\n              return o.indexOf(e) === t;\n            }));\n          }\n\n          this.parseChartAttr(e), this.addToEnv(\"chartColorRange\", e.colorrange || {}), this.createComponent(e), this._feedAxesRawData(), n.axis = !0, this.addToEnv(\"totalRows\", t.length), this.addToEnv(\"totalColumns\", o.length), this._createToolBox(), n.toolbar = !0, this.configureChildren(), this.asyncDraw(), this.getFromEnv(\"toolTipController\").setStyle({\n            bgColor: (0, p.convertColor)(a.tooltipbgcolor || \"FFF\", a.tooltipbgalpha || 100),\n            rawBgColor: (a.tooltipbgcolor || \"FFF\").replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            fontColor: (a.tooltipcolor || a.basefontcolor || \"545454\").replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            borderColor: (0, p.convertColor)(a.tooltipbordercolor || \"666\", a.tooltipborderalpha || 100),\n            rawBorderColor: (a.tooltipbordercolor || \"666\").replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            bgAlpha: (0, u.pluckNumber)(a.tooltipbgalpha, 100),\n            borderThickness: (0, u.pluckNumber)(a.tooltipborderthickness, 1),\n            showToolTipShadow: (0, u.pluckNumber)(a.showtooltipshadow || 0),\n            borderRadius: (0, u.pluckNumber)(a.tooltipborderradius, 0),\n            \"font-size\": a.basefontsize || 10,\n            \"font-family\": a.basefont || this.getFromEnv(\"style\").inCanfontFamily,\n            padding: (0, u.pluckNumber)(a.tooltippadding || 3),\n            borderAlpha: (0, u.pluckNumber)(a.tooltipborderalpha, 100)\n          });\n        }, t.prototype._postSpaceManagement = function () {\n          var e = this.config,\n              t = this.getChildren(\"xAxis\")[0],\n              o = this.getFromEnv(\"legend\"),\n              a = e.xDepth;\n          this.setAxisDimention(), t && t.shiftLabels(-a, 0), o && o.postSpaceManager();\n        }, t.prototype.setAxisDimention = function () {\n          var e = this.getChildren(\"xAxis\") && this.getChildren(\"xAxis\")[0],\n              t = this.getChildren(\"yAxis\") && this.getChildren(\"yAxis\")[0],\n              o = this.getFromEnv(\"chartConfig\"),\n              a = o.placeAxisLabelsOnTop,\n              r = this.getChildren(\"canvas\")[0],\n              n = r.config,\n              i = r.getEffectiveDimensions(),\n              l = i.left,\n              s = i.top,\n              c = i.width,\n              u = i.height,\n              p = i.paddingLeft,\n              h = i.paddingRight,\n              d = n && n.canvasBorderWidth,\n              g = n && n.canvasPadding;\n          e && e.setAxisConfig({\n            canvasPaddingLeft: Math.max(p, g),\n            canvasPaddingRight: Math.max(h, g)\n          }), e && e.setAxisDimention({\n            x: l,\n            y: a ? s + (o.shift || 0) - d : s + u + (o.shift || 0) + d,\n            opposite: a ? s + u + d : s - d,\n            axisLength: c\n          }), t && t.setAxisDimention({\n            x: l - d,\n            y: s,\n            opposite: l + c + d,\n            axisLength: u\n          });\n        }, t.prototype._feedAxesRawData = function () {\n          var e,\n              t,\n              o = this.getFromEnv(\"color-manager\"),\n              a = this.getFromEnv(\"dataSource\"),\n              r = a.chart,\n              n = this.config.is3D,\n              i = n ? u.chartPaletteStr.chart3D : u.chartPaletteStr.chart2D;\n          return e = {\n            mapTickValuesById: !0,\n            isVertical: !1,\n            isReverse: !1,\n            isOpposit: !!this.config.placeAxisLabelsOnTop,\n            outCanfontFamily: (0, u.pluck)(r.outcnvbasefont, r.basefont, g),\n            outCanfontSize: (0, u.pluckFontSize)(r.outcnvbasefontsize, r.basefontsize, 10),\n            outCancolor: (0, u.pluck)(r.outcnvbasefontcolor, r.basefontcolor, o.getColor(i.baseFontColor)).replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: r.xaxisnamepadding,\n            axisValuePadding: r.labelpadding,\n            axisNameFont: r.xaxisnamefont,\n            axisNameFontSize: r.xaxisnamefontsize,\n            axisNameFontColor: r.xaxisnamefontcolor,\n            axisNameFontBold: r.xaxisnamefontbold,\n            axisNameFontItalic: r.xaxisnamefontitalic,\n            axisNameBgColor: r.xaxisnamebgcolor,\n            axisNameBorderColor: r.xaxisnamebordercolor,\n            axisNameAlpha: r.xaxisnamealpha,\n            axisNameFontAlpha: r.xaxisnamefontalpha,\n            axisNameBgAlpha: r.xaxisnamebgalpha,\n            axisNameBorderAlpha: r.xaxisnameborderalpha,\n            axisNameBorderPadding: r.xaxisnameborderpadding,\n            axisNameBorderRadius: r.xaxisnameborderradius,\n            axisNameBorderThickness: r.xaxisnameborderthickness,\n            axisNameBorderDashed: r.xaxisnameborderdashed,\n            axisNameBorderDashLen: r.xaxisnameborderdashlen,\n            axisNameBorderDashGap: r.xaxisnameborderdashgap,\n            useEllipsesWhenOverflow: r.useellipseswhenoverflow,\n            divLineColor: (0, u.pluck)(r.vdivlinecolor, r.divlinecolor, o.getColor(i.divLineColor)),\n            divLineAlpha: (0, u.pluck)(r.vdivlinealpha, r.divlinealpha, n ? o.getColor(f) : o.getColor(m)),\n            divLineThickness: (0, u.pluckNumber)(r.vdivlinethickness, r.divlinethickness, 1),\n            divLineIsDashed: Boolean((0, u.pluckNumber)(r.vdivlinedashed, r.vdivlineisdashed, r.divlinedashed, r.divlineisdashed, 0)),\n            divLineDashLen: (0, u.pluckNumber)(r.vdivlinedashlen, r.divlinedashlen, 4),\n            divLineDashGap: (0, u.pluckNumber)(r.vdivlinedashgap, r.divlinedashgap, 2),\n            showAlternateGridColor: (0, u.pluckNumber)(r.showalternatevgridcolor, 0),\n            alternateGridColor: (0, u.pluck)(r.alternatevgridcolor, o.getColor(v)),\n            alternateGridAlpha: (0, u.pluck)(r.alternatevgridalpha, o.getColor(b)),\n            numDivLines: r.numvdivlines,\n            labelFont: r.labelfont,\n            labelFontSize: r.labelfontsize,\n            labelFontColor: r.labelfontcolor,\n            labelFontAlpha: r.labelalpha,\n            labelFontBold: r.labelfontbold,\n            labelFontItalic: r.labelfontitalic,\n            axisName: r.xaxisname,\n            axisMinValue: r.xaxisminvalue,\n            axisMaxValue: r.xaxismaxvalue,\n            setAdaptiveMin: r.setadaptivexmin,\n            adjustDiv: r.adjustvdiv,\n            labelDisplay: r.labeldisplay,\n            showLabels: (0, u.pluckNumber)(r.showxaxislabels, r.showlabels),\n            rotateLabels: r.rotatexaxislabels,\n            slantLabel: (0, u.pluckNumber)(r.slantlabels, r.slantlabel),\n            labelStep: (0, u.pluckNumber)(r.labelstep, r.xaxisvaluesstep),\n            showAxisValues: (0, u.pluckNumber)(r.showxaxisvalues, r.showxaxisvalue),\n            maxLabelHeight: r.maxlabelheight,\n            showZeroPlane: r.showvzeroplane,\n            zeroPlaneColor: r.vzeroplanecolor,\n            zeroPlaneThickness: r.vzeroplanethickness,\n            zeroPlaneAlpha: r.vzeroplanealpha,\n            showZeroPlaneValue: r.showvzeroplanevalue,\n            trendlineColor: r.trendlinecolor,\n            trendlineToolText: r.trendlinetooltext,\n            trendlineThickness: r.trendlinethickness,\n            trendlineAlpha: r.trendlinealpha,\n            showTrendlinesOnTop: r.showtrendlinesontop,\n            showAxisLine: (0, u.pluckNumber)(r.showxaxisline, r.showaxislines, r.drawAxisLines, 0),\n            axisLineThickness: (0, u.pluckNumber)(r.xaxislinethickness, r.axislinethickness, 1),\n            axisLineAlpha: (0, u.pluckNumber)(r.xaxislinealpha, r.axislinealpha, 100),\n            axisLineColor: (0, u.pluck)(r.xaxislinecolor, r.axislinecolor, w)\n          }, t = {\n            mapTickValuesById: !0,\n            isVertical: !0,\n            isReverse: !1,\n            isOpposit: !1,\n            outCanfontFamily: (0, u.pluck)(r.outcnvbasefont, r.basefont, g),\n            outCanfontSize: (0, u.pluckFontSize)(r.outcnvbasefontsize, r.basefontsize, 10),\n            outCancolor: (0, u.pluck)(r.outcnvbasefontcolor, r.basefontcolor, o.getColor(i.baseFontColor)).replace(/^#?([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: r.yaxisnamepadding,\n            axisValuePadding: r.yaxisvaluespadding,\n            axisNameFont: r.yaxisnamefont,\n            axisNameFontSize: r.yaxisnamefontsize,\n            axisNameFontColor: r.yaxisnamefontcolor,\n            axisNameFontBold: r.yaxisnamefontbold,\n            axisNameFontItalic: r.yaxisnamefontitalic,\n            axisNameBgColor: r.yaxisnamebgcolor,\n            axisNameBorderColor: r.yaxisnamebordercolor,\n            axisNameAlpha: r.yaxisnamealpha,\n            axisNameFontAlpha: r.yaxisnamefontalpha,\n            axisNameBgAlpha: r.yaxisnamebgalpha,\n            axisNameBorderAlpha: r.yaxisnameborderalpha,\n            axisNameBorderPadding: r.yaxisnameborderpadding,\n            axisNameBorderRadius: r.yaxisnameborderradius,\n            axisNameBorderThickness: r.yaxisnameborderthickness,\n            axisNameBorderDashed: r.yaxisnameborderdashed,\n            axisNameBorderDashLen: r.yaxisnameborderdashlen,\n            axisNameBorderDashGap: r.yaxisnameborderdashgap,\n            axisNameWidth: r.yaxisnamewidth,\n            useEllipsesWhenOverflow: r.useellipseswhenoverflow,\n            rotateAxisName: (0, u.pluckNumber)(r.rotateyaxisname, 1),\n            axisName: r.yaxisname,\n            showAlternateGridColor: (0, u.pluckNumber)(r.showalternatehgridcolor, 1),\n            alternateGridColor: (0, u.pluck)(r.alternatehgridcolor, o.getColor(y)),\n            alternateGridAlpha: (0, u.pluck)(r.alternatehgridalpha, o.getColor(x)),\n            numDivLines: r.numdivlines,\n            axisMinValue: r.yaxisminvalue,\n            axisMaxValue: r.yaxismaxvalue,\n            setAdaptiveMin: r.setadaptiveymin,\n            adjustDiv: r.adjustdiv,\n            labelStep: r.yaxisvaluesstep,\n            showLabels: (0, u.pluckNumber)(r.showyaxislabels, r.showlabels),\n            maxLabelWidthPercent: r.maxlabelwidthpercent,\n            showAxisValues: (0, u.pluckNumber)(r.showyaxisvalues, r.showyaxisvalue),\n            divLineColor: (0, u.pluck)(r.hdivlinecolor, o.getColor(i.divLineColor)),\n            divLineAlpha: (0, u.pluck)(r.hdivlinealpha, o.getColor(m)),\n            divLineThickness: (0, u.pluckNumber)(r.hdivlinethickness, 1),\n            divLineIsDashed: Boolean((0, u.pluckNumber)(r.hdivlinedashed, r.hdivlineisdashed, 0)),\n            divLineDashLen: (0, u.pluckNumber)(r.hdivlinedashlen, 4),\n            divLineDashGap: (0, u.pluckNumber)(r.hdivlinedashgap, 2),\n            showZeroPlane: r.showzeroplane,\n            zeroPlaneColor: r.zeroplanecolor,\n            zeroPlaneThickness: r.zeroplanethickness,\n            zeroPlaneAlpha: r.zeroplanealpha,\n            showZeroPlaneValue: r.showzeroplanevalue,\n            trendlineColor: r.trendlinecolor,\n            trendlineToolText: r.trendlinetooltext,\n            trendlineThickness: r.trendlinethickness,\n            trendlineAlpha: r.trendlinealpha,\n            showTrendlinesOnTop: r.showtrendlinesontop,\n            showAxisLine: (0, u.pluckNumber)(r.showyaxisline, r.showaxislines, r.drawAxisLines, 0),\n            axisLineThickness: (0, u.pluckNumber)(r.yaxislinethickness, r.axislinethickness, 1),\n            axisLineAlpha: (0, u.pluckNumber)(r.yaxislinealpha, r.axislinealpha, 100),\n            axisLineColor: (0, u.pluck)(r.yaxislinecolor, r.axislinecolor, w)\n          }, e.vtrendlines = a.vtrendlines, t.trendlines = a.trendlines, {\n            yAxisConf: [t],\n            xAxisConf: [e]\n          };\n        }, t.prototype._setCategories = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l,\n              s,\n              c,\n              p = this.getFromEnv(\"dataSource\"),\n              h = this.getChildren(\"xAxis\"),\n              d = this.getChildren(\"yAxis\"),\n              g = [],\n              f = [];\n          if (!p.columns || !p.rows) for (p.columns = {}, p.columns.column = n = [], p.rows = {}, p.rows.row = i = [], o = 0; o < (p.dataset && p.dataset.length); o++) {\n            for (e = p.dataset && p.dataset[o].data && p.dataset[o].data.length, t = 0; t < e; t++) {\n              for (l = !0, s = !0, c = 0; c < n.length; c++) {\n                p.dataset[o].data[t].columnid == n[c].id && (l = !1);\n              }\n\n              for (l && (a = {\n                id: p.dataset[o].data[t].columnid,\n                label: p.dataset[o].data[t].columnid\n              }, p.columns.column.push(a)), c = 0; c < i.length; c++) {\n                p.dataset[o].data[t].rowid == i[c].id && (s = !1);\n              }\n\n              s && (r = {\n                id: p.dataset[o].data[t].rowid,\n                label: p.dataset[o].data[t].rowid\n              }, p.rows.row.push(r));\n            }\n          }\n\n          for (n = p.columns.column, i = p.rows.row, t = 0; t < (n && n.length); t++) {\n            n[t].label = (0, u.pluck)(n[t].label, n[t].name, n[t].id), void 0 !== n[t].label && g.push(n[t]);\n          }\n\n          for (p.columns.column = g, t = 0; t < (i && i.length); t++) {\n            i[t].label = (0, u.pluck)(i[t].label, i[t].name, i[t].id), void 0 !== i[t].label && f.push(i[t]);\n          }\n\n          p.rows.row = f, p.columns && h[0].setTickValues(p.columns.column), p.rows && d[0].setTickValues(p.rows.row), h[0].setAxisConfig({\n            categoryNumDivLines: this.getFromEnv(\"totalColumns\") - 1,\n            categoryDivLinesFromZero: 0,\n            showAlternateGridColor: 0\n          }), d[0].setAxisConfig({\n            categoryNumDivLines: this.getFromEnv(\"totalRows\") - 1,\n            categoryDivLinesFromZero: 0,\n            showAlternateGridColor: 0\n          });\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t.prototype.getDSGroupdef = function () {\n          return n[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = k;\n    },\n    573: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = c(o(131)),\n          r = o(118),\n          n = o(122),\n          i = o(125),\n          l = c(o(574)),\n          s = o(129);\n\n      function c(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function u(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var p = r.preDefStr.pStr,\n          h = r.preDefStr.sStr,\n          d = r.preDefStr.miterStr,\n          g = r.preDefStr.hiddenStr,\n          f = r.preDefStr.showHoverEffectStr,\n          m = r.preDefStr.POSITION_START,\n          v = r.preDefStr.POSITION_TOP,\n          b = r.preDefStr.POSITION_END,\n          y = r.preDefStr.POSITION_BOTTOM,\n          x = r.preDefStr.DEFAULT,\n          w = function w(e) {\n        return void 0 !== e && null !== e;\n      },\n          k = function k(e, t, o) {\n        return o.getFromEnv(\"animationManager\").setAnimation({\n          el: \"group\",\n          attr: e,\n          container: t,\n          component: o,\n          label: \"group\"\n        });\n      },\n          C = \"rgba(192,192,192,\" + (r.isIE ? .002 : 1e-6) + \")\",\n          N = r.hasTouch ? r.TOUCH_THRESHOLD_PIXELS : r.CLICK_THRESHOLD_PIXELS,\n          S = Math.max,\n          E = Math.min,\n          A = Math.abs;\n\n      (0, i.addDep)({\n        name: \"heatmapAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var D = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.components = {}, o.graphics = {}, o.dataSetArray = [], o;\n        }\n\n        return u(t, e), t.prototype.getType = function () {\n          return \"dataset\";\n        }, t.prototype.getName = function () {\n          return \"heatMap\";\n        }, t.prototype.configureAttributes = function (e) {\n          if (!e) return !1;\n          this.trimData(e), this.config.JSONData = e;\n\n          var t,\n              o,\n              a,\n              i,\n              l,\n              s,\n              c,\n              u,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k = this.getFromEnv(\"chart\"),\n              C = this.getFromEnv(\"chartConfig\").style,\n              N = this.config,\n              S = N.JSONData,\n              E = S.data,\n              A = E && E.length,\n              D = this.getFromEnv(\"chart-attrib\"),\n              T = this.getFromEnv(\"color-manager\"),\n              L = this.index || this.positionIndex,\n              _ = N.plotColor = T.getPlotColor(L),\n              P = (0, r.pluckNumber)(S.dashed, D.plotborderdashed),\n              O = this.components.data,\n              V = this.components.plotGrid = [],\n              M = this.getFromEnv(\"number-formatter\"),\n              F = k.isBar,\n              I = k.config.is3D,\n              B = -Infinity,\n              R = +Infinity,\n              j = this.getFromEnv(\"totalRows\"),\n              G = this.getFromEnv(\"totalColumns\");\n\n          for (m = 0; m < j; m++) {\n            for (V.push([]), v = 0; v < G; v++) {\n              V[m].push([]);\n            }\n          }\n\n          for (this.setState(\"visible\", 1 === (0, r.pluckNumber)(this.getState(\"visible\"), this.config.JSONData.visible, !Number(this.config.JSONData.initiallyhidden), 1)), t = N.showplotborder = (0, r.pluckNumber)(D.showplotborder, I ? 0 : 1), N.plotDashLen = o = (0, r.pluckNumber)(D.plotborderdashlen, 5), N.plotDashGap = a = (0, r.pluckNumber)(D.plotborderdashgap, 4), N.plotfillAngle = (0, r.pluckNumber)(360 - D.plotfillangle, F ? 180 : 90), N.plotFillAlpha = l = (0, r.pluck)(S.alpha, D.plotfillalpha, \"100\"), N.plotColor = _ = (0, r.pluck)(S.color, _), N.isRoundEdges = i = (0, r.pluckNumber)(D.useroundedges, 0), N.plotRadius = (0, r.pluckNumber)(D.useRoundEdges, N.isRoundEdges ? 1 : 0), N.plotFillRatio = (0, r.pluck)(S.ratio, D.plotfillratio), N.plotgradientcolor = (0, r.getDefinedColor)(D.plotgradientcolor, T.getColor(\"plotGradientColor\")), N.plotBorderAlpha = t ? (0, r.pluck)(D.plotborderalpha, l, \"100\") : 0, N.plotBorderColor = (0, r.pluck)(D.plotbordercolor, I ? \"FFFFFF\" : T.getColor(\"plotBorderColor\")), N.plotBorderThickness = (0, r.pluckNumber)(D.plotborderthickness, 1), N.plotBorderDashStyle = P ? (0, r.getDashStyle)(o, a) : \"none\", N.showValues = (0, r.pluckNumber)(S.showvalues, D.showvalues, 1), N.valuePadding = (0, r.pluckNumber)(D.valuepadding, 2), N.enableAnimation = g = (0, r.pluckNumber)(D.animation, D.defaultanimation, 1), N.animation = !!g && {\n            duration: 1e3 * (0, r.pluckNumber)(D.animationduration, 1)\n          }, N.transposeAnimation = (0, r.pluckNumber)(D.transposeanimation, g), N.transposeAnimDuration = 1e3 * (0, r.pluckNumber)(D.transposeanimduration, .2), N.showShadow = i || I ? (0, r.pluckNumber)(D.showshadow, 1) : (0, r.pluckNumber)(D.showshadow, T.getColor(\"showShadow\")), N.showHoverEffect = (0, r.pluckNumber)(D.plothovereffect, D.showhovereffect, void 0), N.showTooltip = (0, r.pluckNumber)(D.showtooltip, 1), N.definedGroupPadding = Math.max((0, r.pluckNumber)(D.plotspacepercent), 0), N.plotSpacePercent = Math.max((0, r.pluckNumber)(D.plotspacepercent, 20) % 100, 0), N.maxColWidth = (0, r.pluckNumber)(F ? D.maxbarheight : D.maxcolwidth, 50), N.plotPaddingPercent = (0, r.pluckNumber)(D.plotpaddingpercent), N.rotateValues = (0, r.pluckNumber)(D.rotatevalues) ? 270 : 0, N.placeValuesInside = (0, r.pluckNumber)(D.placevaluesinside, 0), N.defaultPadding = {\n            left: .5,\n            right: .5,\n            top: .5,\n            bottom: .5\n          }, b = C.inCanfontFamily, w = C.inCanfontSize, y = parseInt(w, 10 || 10), x = C.inCancolor, \"normal\", \"normal\", N.tlLabelStyle = {\n            fontFamily: (0, r.pluck)(D.tlfont, b),\n            fontSize: (0, r.pluckNumber)(D.tlfontsize, y) + \"px\",\n            color: (0, n.convertColor)((0, r.pluck)(D.tlfontcolor, x), 100),\n            fontWeight: \"normal\",\n            fontStyle: \"normal\"\n          }, (0, r.setLineHeight)(N.tlLabelStyle), N.trLabelStyle = {\n            fontFamily: (0, r.pluck)(D.trfont, b),\n            fontSize: (0, r.pluckNumber)(D.trfontsize, y) + \"px\",\n            color: (0, n.convertColor)((0, r.pluck)(D.trfontcolor, x), 100),\n            fontWeight: \"normal\",\n            fontStyle: \"normal\"\n          }, N.brLabelStyle = {\n            fontFamily: (0, r.pluck)(D.brfont, b),\n            fontSize: (0, r.pluckNumber)(D.brfontsize, y) + \"px\",\n            color: (0, n.convertColor)((0, r.pluck)(D.brfontcolor, x), 100),\n            fontWeight: \"normal\",\n            fontStyle: \"normal\"\n          }, N.blLabelStyle = {\n            fontFamily: (0, r.pluck)(D.blfont, b),\n            fontSize: (0, r.pluckNumber)(D.blfontsize, y) + \"px\",\n            color: (0, n.convertColor)((0, r.pluck)(D.blfontcolor, x), 100),\n            fontWeight: \"normal\",\n            fontStyle: \"normal\"\n          }, N.use3DLighting = (0, r.pluckNumber)(D.use3dlighting, 1), N.parentYAxis = (0, r.pluck)(S.parentyaxis && S.parentyaxis.toLowerCase(), p) === h ? 1 : 0, O || (O = this.components.data = []), f = 0; f < A; f++) {\n            s = E && E[f], d = (u = O[f]) && u.config, u || (u = O[f] = {\n              graphics: {}\n            }), u.config || (d = O[f].config = {}), d.setValue = c = M.getCleanValue(s.value), B = Math.max(B, c), R = Math.min(R, c);\n          }\n\n          N.maxValue = B, N.minValue = R, this._setConfigure(), this.setState(\"dirty\", !0);\n        }, t.prototype._setConfigure = function () {\n          var e,\n              t,\n              o,\n              a,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x,\n              w,\n              k,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H,\n              W = this,\n              z = W.getFromEnv(\"chart\"),\n              U = W.config,\n              J = W.config.JSONData,\n              K = J.data,\n              q = K && K.length,\n              Y = W.getFromEnv(\"chart-attrib\"),\n              X = W.getFromEnv(\"color-manager\"),\n              Q = W.index || W.positionIndex,\n              Z = U.showplotborder,\n              $ = U.plotColor = X.getPlotColor(Q),\n              ee = (0, r.pluckNumber)(Y.showtooltip, 1),\n              te = (0, r.parseUnsafeString)(Y.yaxisname),\n              oe = (0, r.parseUnsafeString)(Y.xaxisname),\n              ae = (0, r.parseUnsafeString)((0, r.pluck)(Y.tooltipsepchar, \": \")),\n              re = (0, r.pluckNumber)(Y.useplotgradientcolor, 1),\n              ne = U.plotDashLen,\n              ie = U.plotDashGap,\n              le = U.plotBorderThickness,\n              se = U.isRoundEdges,\n              ce = U.showHoverEffect,\n              ue = U.plotfillAngle,\n              pe = U.plotFillAlpha,\n              he = U.plotFillRatio,\n              de = U.plotBorderAlpha,\n              ge = U.plotBorderColor,\n              fe = W.getFromEnv(\"chartColorRange\"),\n              me = W.getFromEnv(\"xAxis\"),\n              ve = W.getFromEnv(\"yAxis\"),\n              be = U.mapByPercent = (0, r.pluckNumber)(fe.mapbypercent, 0),\n              ye = U.mapByCategory = (0, r.pluckNumber)(Y.mapbycategory, 0),\n              xe = fe && (0, r.pluckNumber)(fe.gradient),\n              we = W.components.data,\n              ke = W.getFromEnv(\"number-formatter\"),\n              Ce = z.isBar,\n              Ne = z.config.is3D,\n              Se = U.parentYAxis,\n              Ee = U.maxValue,\n              Ae = U.minValue,\n              De = (0, r.getValidValue)(Y.tltype, r.BLANK),\n              Te = (0, r.getValidValue)(Y.trtype, r.BLANK),\n              Le = (0, r.getValidValue)(Y.bltype, r.BLANK),\n              _e = (0, r.getValidValue)(Y.brtype, r.BLANK),\n              Pe = r.BLANK,\n              Oe = r.BLANK,\n              Ve = r.BLANK,\n              Me = r.BLANK,\n              Fe = z.getFromEnv(\"colorManager\");\n\n          if (D = Ee - Ae, U.eventAttached || (W.addExtEventListener(\"legendUpdate\", function (e, t) {\n            if (\"legend\" === t.component) t.legendItem.hasState(\"hidden\") ? W.show(t.legendItem, e) : W.hide(t.legendItem, e);else for (I = t.maxMinArray, B = I.length, A = 0; A < B; A++) {\n              W.updatePlot(I[A].min, I[A].max);\n            }\n          }, Fe), U.eventAttached = !0), (!xe || ye) && (U.colorMap = [], fe.color)) for (A = 0; A < fe.color.length; A++) {\n            U.colorMap[A] = {\n              config: fe.color[A],\n              dataSet: W\n            }, U.colorMap[A].config.visible = !0;\n          }\n\n          for (A = 0; A < q; A++) {\n            l = K && K[A], s = (u = (c = we[A]) && c.config).setValue, u.showValue = (0, r.pluckNumber)(l.showvalue, U.showValues), u.setLink = (0, r.pluck)(l.link), u.toolTipValue = R = ke.dataLabels(s, Se), u.setDisplayValue = E = (0, r.parseUnsafeString)(l.displayvalue), u.displayValue = (0, r.pluck)(E, R), j = (0, r.pluckNumber)(l.dashed), G = (0, r.pluckNumber)(l.dashlen, ne), H = ie = (0, r.pluckNumber)(l.dashgap, ie), u.plotBorderDashStyle = 1 === j ? (0, r.getDashStyle)(G, H) : 0 === j ? \"none\" : U.plotBorderDashStyle, u.percentValue = be ? V = l.value && Math.round((l.value - Ae) / D * 1e4) / 100 : void 0, u.value = F = ye ? l.colorrangelabel || l.categoryid : be ? V : u.setValue, T = Fe.getColor(F), c.legendItemIndex = T.seriesIndex, u.legendItemId = T.legendItemId, T && !T.code && (T.code = \"ffffff\"), u.plotFillAlpha = pe = (0, r.pluckNumber)(l.alpha, T && T.oriAlpha, U.plotFillAlpha), $ = (0, r.pluck)(l.color, T && T.code), s < 0 && !se && (ue = Ce ? 180 - ue : 360 - ue), u.colorArr = (0, n.getColumnColor)($ + \",\" + U.plotgradientcolor, pe.toString(), he, ue, se, ge, de.toString(), Ce ? 1 : 0, !!Ne), T && T.outOfRange ? (u.visible = !1, u.displayValue = r.BLANKSTRING) : (u.visible = !0, u.color = (0, n.convertColor)($, u.plotFillAlpha), 0 !== ce && (d = (0, r.pluck)(l.hovercolor, J.hovercolor, Y.plotfillhovercolor, Y.columnhovercolor, $), g = (0, r.pluck)(l.hoveralpha, J.hoveralpha, Y.plotfillhoveralpha, Y.columnhoveralpha, \"25\"), !(0, r.pluck)(l.hovergradientcolor, J.hovergradientcolor, Y.plothovergradientcolor, !re && r.BLANKSTRING) && r.BLANKSTRING, f = (0, r.pluck)(l.hoverratio, J.hoverratio, Y.plothoverratio, he), m = (0, r.pluckNumber)(360 - l.hoverangle, 360 - J.hoverangle, 360 - Y.plothoverangle, ue), v = (0, r.pluck)(l.borderhovercolor, J.borderhovercolor, Y.plotborderhovercolor, ge), b = (0, r.pluck)(l.borderhoveralpha, J.borderhoveralpha, Y.plotborderhoveralpha, de, pe), y = (0, r.pluckNumber)(l.borderhoverthickness, J.borderhoverthickness, Y.plotborderhoverthickness, le), x = (0, r.pluckNumber)(l.borderhoverdashed, J.borderhoverdashed, Y.plotborderhoverdashed), w = (0, r.pluckNumber)(l.borderhoverdashgap, J.borderhoverdashgap, Y.plotborderhoverdashgap, ne), k = (0, r.pluckNumber)(l.borderhoverdashlen, J.borderhoverdashlen, Y.plotborderhoverdashlen, ie), N = x ? (0, r.getDashStyle)(k, w) : U.plotBorderDashStyle, 1 == ce && d === $ && (d = (0, n.getLightColor)(d, 70)), S = (0, n.getColumnColor)(d, g, f, m, se, v, b.toString(), Ce ? 1 : 0, !!Ne), u.setRolloutAttr = {\n              fill: (0, r.toRaphaelColor)(u.color),\n              stroke: Z && (0, r.toRaphaelColor)(u.colorArr[1]) || C,\n              \"stroke-width\": le,\n              \"stroke-dasharray\": []\n            }, u.setRolloverAttr = {\n              fill: (0, r.toRaphaelColor)(S[0]),\n              stroke: Z && (0, r.toRaphaelColor)(S[1]) || C,\n              \"stroke-width\": y,\n              \"stroke-dasharray\": N\n            }), be && (V = ke.percentValue(V)), u.setValue = s = ke.getCleanValue(l.value), u.toolTipValue = ke.dataLabels(s, Se), e = u.toolTipValue, o = (0, r.getValidValue)((0, r.parseUnsafeString)((0, r.pluck)(l.tooltext, J.plottooltext, Y.plottooltext))), u.tlLabel = L = (0, r.parseUnsafeString)((0, r.pluck)(l.tllabel, l.ltlabel)), u.trLabel = _ = (0, r.parseUnsafeString)((0, r.pluck)(l.trlabel, l.rtlabel)), u.blLabel = P = (0, r.parseUnsafeString)((0, r.pluck)(l.bllabel, l.lblabel)), u.brLabel = O = (0, r.parseUnsafeString)((0, r.pluck)(l.brlabel, l.rblabel)), E = (0, r.getValidValue)((0, r.parseUnsafeString)(l.displayvalue)), M = ye ? E : (0, r.pluck)(l.displayvalue, e), u.displayValue = (0, r.pluck)(E, V, u.toolTipValue), De !== r.BLANK && (Pe = \"<b>\" + De + ae + \"</b>\"), Te !== r.BLANK && (Oe = \"<b>\" + Te + ae + \"</b>\"), Le !== r.BLANK && (Ve = \"<b>\" + Le + ae + \"</b>\"), _e !== r.BLANK && (Me = \"<b>\" + _e + ae + \"</b>\"), p = me.getCategoryFromId(K[A].columnid.toLowerCase()), h = ve.getCategoryFromId(K[A].rowid.toLowerCase()), ee ? (null === e ? i = !1 : void 0 !== o ? (a = [1, 2, 5, 6, 7, 14, 93, 94, 95, 96, 97, 98, 112, 113, 114, 115, 116, 117], t = {\n              formattedValue: e,\n              value: l.value,\n              yaxisName: te,\n              xaxisName: oe,\n              displayValue: E,\n              percentValue: be ? V : r.BLANK,\n              tlLabel: L,\n              trLabel: _,\n              blLabel: P,\n              brLabel: O,\n              rowLabel: h.tickObj && h.tickObj.label,\n              columnLabel: p.tickObj && p.tickObj.label,\n              percentDataValue: be ? V : r.BLANK,\n              trtype: Te,\n              tltype: De,\n              brType: _e,\n              blType: Le,\n              colorRangeLabel: u.colorRangeLabel\n            }, i = (0, r.parseTooltext)(o, a, t, l, Y, t)) : i = (be ? \"<b>Value\" + ae + \"</b>\" + e + \"<br /><b>Percentage\" + ae + \"</b>\" + V : M) + (L !== r.BLANK ? \"<br />\" + (Pe + L) : r.BLANK) + (_ !== r.BLANK ? \"<br />\" + Oe + _ : r.BLANK) + (P !== r.BLANK ? \"<br />\" + Ve + P : r.BLANK) + (O !== r.BLANK ? \"<br />\" + Me + O : r.BLANK), u.toolText = i, u.setTooltext = i) : u.toolText = !1);\n          }\n        }, t.prototype.hide = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              n,\n              i = this.components.data,\n              l = this.getFromEnv(\"chart\"),\n              s = this.getFromEnv(\"animationManager\"),\n              c = l.getChildren(\"colorRange\")[0];\n\n          for (r = e.config.datasetObj.code, t = 0, o = i.length; t < o; t++) {\n            Object.keys(i[t]).length && (n = c.getColorObj(i[t].config.value).code, a = i[t].config, r === n && (i[t].graphics.element && s.setAnimation({\n              el: i[t].graphics.element,\n              attr: {\n                \"fill-opacity\": 0,\n                \"stroke-width\": 0\n              },\n              component: this\n            }), i[t].graphics.hotElement && i[t].graphics.hotElement.hide(), i[t].graphics.valEle && i[t].graphics.valEle.hide(), i[t].graphics.tlLabel && i[t].graphics.tlLabel.hide(), i[t].graphics.trLabel && i[t].graphics.trLabel.hide(), i[t].graphics.blLabel && i[t].graphics.blLabel.hide(), i[t].graphics.brLabel && i[t].graphics.brLabel.hide(), a.visible = !1, i[t].visible = !1));\n          }\n\n          e.setLegendState(\"hidden\");\n        }, t.prototype.show = function (e) {\n          var t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l = this.components.data,\n              s = this.config,\n              c = this.getFromEnv(\"chart\"),\n              u = this.getFromEnv(\"animationManager\"),\n              p = c.getChildren(\"colorRange\")[0];\n\n          for (i = e.config.datasetObj.code, r = 0, n = l.length; r < n; r++) {\n            Object.keys(l[r]).length && (o = (t = l[r].config).plotFillAlpha / 100, i === (!(a = p.getColorObj(l[r].config.value)).outOfRange && a.code) && (l[r].graphics.element && u.setAnimation({\n              el: l[r].graphics.element,\n              attr: {\n                visibility: \"visible\"\n              },\n              component: this\n            }), l[r].graphics.element && u.setAnimation({\n              el: l[r].graphics.element,\n              component: this,\n              attr: {\n                \"fill-opacity\": o,\n                \"stroke-width\": s.plotBorderThickness\n              }\n            }), l[r].graphics.hotElement && l[r].graphics.hotElement.show(), l[r].graphics.valEle && l[r].graphics.valEle.show(), l[r].graphics.tlLabel && l[r].graphics.tlLabel.show(), l[r].graphics.trLabel && l[r].graphics.trLabel.show(), l[r].graphics.blLabel && l[r].graphics.blLabel.show(), l[r].graphics.brLabel && l[r].graphics.brLabel.show(), t.visible = !0, l[r].visible = !0));\n          }\n\n          e && e.removeLegendState(\"hidden\");\n        }, t.prototype.updatePlot = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n = arguments[0],\n              i = arguments[1],\n              l = this.config,\n              s = this.getFromEnv(\"animationManager\"),\n              c = this.components.data;\n\n          for (o = 0, a = c.length; o < a; o++) {\n            Object.keys(c[o]).length && (t = (e = c[o].config).plotFillAlpha / 100, (r = c[o].config.value) < n || r > i ? e.visible && (c[o].graphics.element && s.setAnimation({\n              el: c[o].graphics.element,\n              attr: {\n                \"fill-opacity\": 0,\n                \"stroke-width\": 0\n              },\n              component: this\n            }), c[o].graphics.hotElement && c[o].graphics.hotElement.hide(), c[o].graphics.valEle && c[o].graphics.valEle.hide(), c[o].graphics.tlLabel && c[o].graphics.tlLabel.hide(), c[o].graphics.trLabel && c[o].graphics.trLabel.hide(), c[o].graphics.blLabel && c[o].graphics.blLabel.hide(), c[o].graphics.brLabel && c[o].graphics.brLabel.hide(), e.visible = !1, c[o].visible = !1) : e.visible || (c[o].graphics.element && s.setAnimation({\n              el: c[o].graphics.element,\n              attr: {\n                \"fill-opacity\": t,\n                \"stroke-width\": l.plotBorderThickness\n              },\n              callback: function callback() {\n                this.show();\n              },\n              component: this\n            }), c[o].graphics.hotElement && c[o].graphics.hotElement.show(), c[o].graphics.valEle && c[o].graphics.valEle.show(), c[o].graphics.tlLabel && c[o].graphics.tlLabel.show(), c[o].graphics.trLabel && c[o].graphics.trLabel.show(), c[o].graphics.blLabel && c[o].graphics.blLabel.show(), c[o].graphics.brLabel && c[o].graphics.brLabel.show(), e.visible = !0, c[o].visible = !0));\n          }\n        }, t.prototype._checkPointObj = function (e, t, o, a) {\n          var r,\n              n,\n              i,\n              l,\n              s,\n              c = this.components.plotGrid,\n              u = this.getFromEnv(\"chartConfig\"),\n              p = u.viewPortConfig,\n              h = p.x,\n              d = p.scaleX,\n              g = u.plotborderthickness,\n              f = u.showplotborder;\n          if (r = c[t] && c[t][e], n = (n = (g = f ? g : 0) / 2) % 2 == 0 ? n + 1 : Math.round(n), r && r.config && r.config.visible && (i = o - (r._xPos - h * d) + n, l = a - r._yPos + n, s = i >= 0 && i <= r._width + g && l >= 0 && l <= r._height + g)) return {\n            pointIndex: r._index,\n            hovered: s,\n            pointObj: r\n          };\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              i = this.getFromEnv(\"chartConfig\"),\n              l = this.getFromEnv(\"xAxis\"),\n              s = this.getFromEnv(\"yAxis\"),\n              c = i.canvasHeight / this.getFromEnv(\"totalRows\");\n          return e += l.getTranslation(), t += s.getTranslation(), a = s.getValue(t + c / 2), n = Math.floor(a), o = l.getValue(e), (r = Math.round(o)) - o > 0 ? a - n > .5 ? this._checkPointObj(r, n, e, t) || this._checkPointObj(r - 1, n, e, t) : this._checkPointObj(r, n - 1, e, t) || this._checkPointObj(r, n, e, t) : a - n > .5 ? this._checkPointObj(r + 1, n, e, t) || this._checkPointObj(r, n, e, t) : this._checkPointObj(r, n - 1, e, t) || this._checkPointObj(r + 1, n, e, t) || this._checkPointObj(r, n, e, t);\n        }, t.prototype.parsePlotAttributes = function (e, t) {\n          var o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              f,\n              m,\n              v,\n              b,\n              y,\n              x = this.config.JSONData,\n              w = this.config,\n              k = x.data,\n              S = t,\n              E = this.getState(\"visible\"),\n              A = this.getFromEnv(\"chart\"),\n              D = this.getFromEnv(\"xAxis\"),\n              T = this.getFromEnv(\"yAxis\"),\n              L = this.getFromEnv(\"chartConfig\"),\n              _ = L.showtooltip,\n              P = this.components.data,\n              O = T.getAxisBase(),\n              V = (T.yBasePos = T.getPixel(O), w.plotBorderThickness),\n              M = w.plotRadius,\n              F = A.getFromEnv(\"legend\") && A.getFromEnv(\"legend\").config.isActive,\n              I = this.components.plotGrid;\n          e && Object.keys(e).length && (m = L.canvasWidth / this.getFromEnv(\"totalColumns\"), l = L.canvasHeight / this.getFromEnv(\"totalRows\"), y = e.trackerConfig = {}, u = (h = e && e.config).setValue, v = D.getCategoryFromId(k[S].columnid.toLowerCase()), b = T.getCategoryFromId(k[S].rowid.toLowerCase()), 0 !== v.index && !v.index || 0 !== b.index && !b.index || (w.mapByCategory || null !== u) && (c = h.setLink, f = h.colorArr, e.graphics || (P[S].graphics = {}), p = h.displayValue, a = D.getPixel(v.index) - m / 2, n = T.getPixel(b.index) - l / 2, i = m, (s = h.toolText) && (h.finalTooltext = s), y.eventArgs = {\n            index: S,\n            link: c,\n            value: h.percentValue || u,\n            displayValue: p,\n            columnId: v.tickObj.id,\n            rowId: b.tickObj.id,\n            tlLabel: h.tlLabel,\n            trLabel: h.trLabel,\n            blLabel: h.blLabel,\n            brLabel: h.brLabel,\n            toolText: s || \"\",\n            id: r.BLANKSTRING,\n            datasetIndex: F ? e.datasetIndex : void 0,\n            datasetName: F ? e.datasetName : void 0,\n            visible: E\n          }, o = {\n            x: a,\n            y: n,\n            width: i,\n            height: l || 1,\n            r: M,\n            fill: h.color,\n            stroke: (0, r.toRaphaelColor)(f[1]),\n            \"stroke-width\": V,\n            \"stroke-dasharray\": void 0,\n            \"fill-opacity\": h.plotFillAlpha / 100,\n            \"stroke-linejoin\": d,\n            visibility: h.visible ? \"visible\" : g,\n            cursor: c ? \"pointer\" : r.BLANKSTRING\n          }, e._xPos = a, e._yPos = n, e._height = l, e._width = i, e._index = S, I[b.index][v.index] = e, e.graphics.element ? ((o = {\n            x: a,\n            y: n,\n            width: i,\n            height: l || 1\n          }).fill = h.color, o.stroke = (0, r.toRaphaelColor)(f[1]), o[\"fill-opacity\"] = h.visible ? h.plotFillAlpha / 100 : 0, o[\"stroke-width\"] = h.visible ? V : 0, o[\"stroke-dasharray\"] = void 0, o[\"stroke-linejoin\"] = d, o.visibility = h.visible ? \"visible\" : g, o.cursor = c ? \"pointer\" : r.BLANKSTRING) : (o[\"fill-opacity\"] = h.plotFillAlpha / 100, o[\"stroke-width\"] = V), (c || _) && (l < N && (n -= (N - l) / 2, l = N), y.attr = {\n            x: a,\n            y: n,\n            width: i,\n            height: l,\n            r: M,\n            cursor: c ? \"pointer\" : r.BLANKSTRING,\n            stroke: C,\n            \"stroke-width\": V,\n            fill: C,\n            visibility: h.visible ? \"visible\" : g\n          }), h.props = {\n            element: {\n              attr: o\n            }\n          }));\n        }, t.prototype.allocatePosition = function () {\n          var e,\n              t,\n              o,\n              a = this.config.JSONData.data,\n              r = this.components.data;\n\n          for (e = a && a.length, t = 0; t < e; t++) {\n            o = r[t], this.parsePlotAttributes(o, t);\n          }\n        }, t.prototype.drawPlots = function () {\n          var e,\n              t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              c,\n              u,\n              p,\n              h,\n              d = this.config.JSONData,\n              g = this.config,\n              m = d.data,\n              v = this.getFromEnv(\"animationManager\"),\n              b = this.getState(\"visible\"),\n              y = this.getFromEnv(\"xAxis\"),\n              x = this.getFromEnv(\"yAxis\"),\n              w = this.getFromEnv(\"chartConfig\"),\n              k = this.components.data,\n              C = g.showShadow,\n              N = this.getContainer(\"plotGroup\"),\n              S = this.getContainer(\"shadowGroup\"),\n              E = [],\n              A = (this.components.removeDataArr || []).length,\n              D = g.showHoverEffect;\n\n          for (e = m && m.length, t = 0; t < e; t++) {\n            h = (o = k[t]).trackerConfig, i = o && o.config, o.graphics && (l = o.graphics.element ? b ? \"updating\" : \"hiding\" : \"appearing\", n = i.setValue, c = y.getCategoryFromId(m[t].columnid.toLowerCase()), u = x.getCategoryFromId(m[t].rowid.toLowerCase()), 0 !== c.index && !c.index || 0 !== u.index && !u.index ? o.graphics.element = o.graphics.element && v.setAnimation({\n              el: o.graphics.element,\n              component: this\n            }) : (c.tickObj && u.tickObj && i.value !== r.BLANKSTRING || !o.graphics || (o.graphics.element = o.graphics.element && v.setAnimation({\n              el: o.graphics.element,\n              component: this\n            })), g.mapByCategory || null !== n || !o.graphics ? (p = c.index.toString() + u.index.toString(), E.push(p), o.graphics.element ? (a = o.graphics.element, i.elemCreated = !1, v.setAnimation({\n              el: a,\n              state: l,\n              attr: i.props.element.attr,\n              component: this\n            })) : (a = o.graphics.element = v.setAnimation({\n              el: \"rect\",\n              component: this,\n              attr: i.props.element.attr,\n              label: \"rect\",\n              container: N\n            }), i.elemCreated = !0), a.shadow({\n              opacity: C\n            }, S).data(\"BBox\", void 0), w.enablemousetracking && a.data(\"eventArgs\", h.eventArgs).data(f, D).data(\"setRolloverAttr\", i.setRolloverAttr || {}).data(\"setRolloutAttr\", i.setRolloutAttr || {})) : (o.graphics.element && o.graphics.element.hide(), o.graphics.hotElement && o.graphics.hotElement.hide())));\n          }\n\n          this.drawn ? this.drawLabel() : this.addJob(\"labelJob\", this.drawLabel.bind(this), s.priorityList.label), this.drawn = !0, A && this.removeDataElems();\n        }, t.prototype.drawLabel = function () {\n          var e,\n              t,\n              o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              f,\n              x,\n              C,\n              N,\n              S,\n              E,\n              A,\n              D,\n              T,\n              L,\n              _,\n              P,\n              O,\n              V,\n              M,\n              F,\n              I,\n              B,\n              R,\n              j,\n              G,\n              H = this.getFromEnv(\"chartConfig\"),\n              W = this.getFromEnv(\"smartLabel\"),\n              z = this.getFromEnv(\"animationManager\"),\n              U = H.dataLabelStyle,\n              J = this.config,\n              K = (this.config.JSONData.data || []).length,\n              q = this.components.data,\n              Y = this.getContainer(\"labelGroup\"),\n              X = this.graphics.tlLabelContainer,\n              Q = this.graphics.blLabelContainer,\n              Z = this.graphics.trLabelContainer,\n              $ = this.graphics.brLabelContainer;\n\n          for (z.setAnimation({\n            el: Y,\n            attr: {\n              opacity: 1\n            },\n            component: this,\n            label: \"text\"\n          }), X || (X = this.graphics.tlLabelContainer = k({\n            name: \"tlLabel\"\n          }, Y, this)), Q || (Q = this.graphics.blLabelContainer = k({\n            name: \"blLabel\"\n          }, Y, this)), Z || (Z = this.graphics.trLabelContainer = k({\n            name: \"trLabel\"\n          }, Y, this)), $ || ($ = this.graphics.brLabelContainer = k({\n            name: \"brLabel\"\n          }, Y, this)), c = J.tlLabelStyle, u = J.trLabelStyle, p = J.blLabelStyle, h = J.brLabelStyle, d = {\n            fontFamily: c.fontFamily,\n            fontSize: c.fontSize,\n            lineHeight: c.lineHeight,\n            fontWeight: c.fontWeight,\n            fontStyle: c.fontStyle\n          }, f = {\n            fontFamily: u.fontFamily,\n            fontSize: u.fontSize,\n            lineHeight: u.lineHeight,\n            fontWeight: u.fontWeight,\n            fontStyle: u.fontStyle\n          }, x = {\n            fontFamily: p.fontFamily,\n            fontSize: p.fontSize,\n            lineHeight: p.lineHeight,\n            fontWeight: p.fontWeight,\n            fontStyle: p.fontStyle\n          }, C = {\n            fontFamily: h.fontFamily,\n            fontSize: h.fontSize,\n            lineHeight: h.lineHeight,\n            fontWeight: h.fontWeight,\n            fontStyle: h.fontStyle\n          }, W.useEllipsesOnOverflow(H.useEllipsesWhenOverflow), W.setStyle(U), X.css(d), Q.css(x), Z.css(f), $.css(C), t = 0; t < K; t++) {\n            void 0 !== (e = q[t]) && e.graphics && (G = (j = e && e.config).setValue, J.mapByCategory || null !== G ? (o = j.displayValue, N = e.graphics.element, S = e._width, E = e._height, A = e._xPos, D = e._yPos, W.setStyle(U), o = (T = W.getSmartText(o, S, E, !1)).text, w(o) && o !== r.BLANK && j.showValue ? (a = D + .5 * E, n = A + .5 * S, s = {\n              text: o,\n              title: T.tooltext || r.BLANKSTRING,\n              visibility: j.visible ? \"visible\" : g,\n              fill: U.color,\n              direction: j.textDirection,\n              x: n,\n              y: a,\n              \"text-bound\": [U.backgroundColor, U.borderColor, U.borderThickness, U.borderPadding, U.borderRadius, U.borderDash]\n            }, N ? e.graphics.valEle = z.setAnimation({\n              el: e.graphics.valEle || \"text\",\n              container: Y,\n              component: this,\n              label: \"text\",\n              attr: s\n            }) : e.graphics.valEle && (e.graphics.valEle = z.setAnimation({\n              el: e.graphics.valEle,\n              component: this\n            })), L = j.tlLabel, _ = j.trLabel, P = j.blLabel, O = j.brLabel, V = w(L) && L !== r.BLANK, M = w(_) && _ !== r.BLANK, F = w(P) && P !== r.BLANK, I = w(O) && O !== r.BLANK, B = S * (V && M ? .5 : .9), R = .5 * (E - (T && T.height || 0)), i = D + 4, V ? (W.setStyle(c), l = A, s = {\n              text: o = (T = W.getSmartText(L, B, R, !1)).text,\n              title: T.tooltext || r.BLANKSTRING,\n              visibility: j.visible ? \"visible\" : g,\n              fill: c.color,\n              \"text-anchor\": m,\n              \"vertical-align\": v,\n              direction: j.textDirection,\n              x: l + 4,\n              y: i,\n              \"text-bound\": [c.backgroundColor, c.borderColor, c.borderThickness, c.borderPadding, c.borderRadius, c.borderDash]\n            }, e.graphics.tlLabel = z.setAnimation({\n              el: e.graphics.tlLabel || \"text\",\n              component: this,\n              attr: Object.assign(s, d),\n              container: X\n            })) : e.graphics.tlLabel && (e.graphics.tlLabel = z.setAnimation({\n              el: e.graphics.tlLabel,\n              component: this\n            })), M ? (W.setStyle(u), l = A + S, s = {\n              text: o = (T = W.getSmartText(_, B, R, !1)).text,\n              title: T.tooltext || r.BLANKSTRING,\n              visibility: j.visible ? \"visible\" : g,\n              fill: u.color,\n              \"text-anchor\": b,\n              \"vertical-align\": v,\n              direction: j.textDirection,\n              x: l - 4,\n              y: i,\n              \"text-bound\": [u.backgroundColor, u.borderColor, u.borderThickness, u.borderPadding, u.borderRadius, u.borderDash]\n            }, e.graphics.trLabel = z.setAnimation({\n              el: e.graphics.trLabel || \"text\",\n              attr: Object.assign(s, f),\n              container: Z,\n              component: this\n            })) : e.graphics.trLabel && (e.graphics.trLabel = z.setAnimation({\n              el: e.graphics.trLabel,\n              component: this\n            })), i = D + E - 4, F ? (W.setStyle(p), l = A, s = {\n              text: o = (T = W.getSmartText(P, B, R, !1)).text,\n              title: T.tooltext || r.BLANKSTRING,\n              visibility: j.visible ? \"visible\" : g,\n              fill: p.color,\n              \"text-anchor\": m,\n              \"vertical-align\": y,\n              direction: j.textDirection,\n              x: l + 4,\n              y: i,\n              \"text-bound\": [p.backgroundColor, p.borderColor, p.borderThickness, p.borderPadding, p.borderRadius, p.borderDash]\n            }, e.graphics.blLabel = z.setAnimation({\n              el: e.graphics.blLabel || \"text\",\n              component: this,\n              container: Q,\n              attr: Object.assign(s, x)\n            })) : e.graphics.blLabel && (e.graphics.blLabel = z.setAnimation({\n              el: e.graphics.blLabel,\n              component: this\n            })), I ? (W.setStyle(p), l = A + S - 4, s = {\n              text: o = (T = W.getSmartText(O, B, R, !1)).text,\n              title: T.tooltext || r.BLANKSTRING,\n              visibility: j.visible ? \"visible\" : g,\n              fill: h.color,\n              \"text-anchor\": b,\n              \"vertical-align\": y,\n              direction: j.textDirection,\n              x: l,\n              y: i,\n              \"text-bound\": [h.backgroundColor, h.borderColor, h.borderThickness, h.borderPadding, h.borderRadius, h.borderDash]\n            }, e.graphics.brLabel = z.setAnimation({\n              el: e.graphics.brLabel || \"text\",\n              attr: Object.assign(s, C),\n              container: $,\n              component: this\n            })) : e.graphics.brLabel && (e.graphics.brLabel = z.setAnimation({\n              el: e.graphics.brLabel,\n              component: this\n            }))) : this.removeLabels(e)) : this.removeLabels(e));\n          }\n\n          this.labelDrawn = !0;\n        }, t.prototype.removeLabels = function (e) {\n          var t = this.getFromEnv(\"animationManager\");\n          e.graphics.valEle && (e.graphics.valEle = t.setAnimation({\n            el: e.graphics.valEle,\n            component: this\n          })), e.graphics.tlLabel && (e.graphics.tlLabel = t.setAnimation({\n            el: e.graphics.tlLabel,\n            component: this\n          })), e.graphics.trLabel && (e.graphics.trLabel = t.setAnimation({\n            el: e.graphics.trLabel,\n            component: this\n          })), e.graphics.blLabel && (e.graphics.blLabel = t.setAnimation({\n            el: e.graphics.blLabel,\n            component: this\n          })), e.graphics.brLabel && (e.graphics.brLabel = t.setAnimation({\n            el: e.graphics.brLabel,\n            component: this\n          }));\n        }, t.prototype.removeDataElems = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.getFromEnv(\"animationManager\"),\n              n = this.components,\n              i = n.removeDataArr,\n              l = n.pool || (n.pool = {\n            element: [],\n            hotElement: [],\n            label: []\n          }),\n              s = i.length;\n\n          for (a = 0; a < s; a++) {\n            if (e = i[0], i.splice(0, 1), e && e.graphics) {\n              for (t in o = e.graphics) {\n                o[t] && (o[t] = r.setAnimation({\n                  el: o[t],\n                  component: this\n                }));\n              }\n\n              e.graphics.element && (l.element = l.element.concat(e.graphics.element)), e.graphics.hotElement && (l.hotElement = l.hotElement.concat(e.graphics.hotElement)), e.graphics.label && (l.label = l.label.concat(e.graphics.label));\n            }\n          }\n\n          n.pool = l;\n        }, t.prototype.getAxisValuePadding = function () {\n          return this.config.defaultPadding;\n        }, t.prototype.getDataLimits = function () {\n          var e,\n              t,\n              o = this.components.data,\n              a = this.config,\n              r = o.length,\n              n = -Infinity,\n              i = +Infinity;\n\n          for (e = 0; e < r; e++) {\n            o[e] && Object.keys(o[e]).length && void 0 !== (t = o[e].config.setValue) && null !== t && (n = S(n, t), i = E(i, t));\n          }\n\n          return a.maxValue = n, a.minValue = i, {\n            max: a.maxValue,\n            min: a.minValue\n          };\n        }, t.prototype.trimData = function (e) {\n          if (this.config.JSONData) {\n            var t = this.config,\n                o = t && t.context,\n                a = o && o.prevCatlen,\n                r = this.getFromEnv(\"xAxis\").getTicksLen(),\n                n = a - r,\n                i = t.JSONData,\n                l = i.data && i.data.length,\n                s = e.data && e.data.length || 0,\n                c = l - s,\n                u = void 0,\n                p = void 0;\n            n > c ? (u = n, p = r) : (u = c, p = s), u > 0 && this.removeData(p, u, !1);\n          }\n        }, t.prototype.draw = function () {\n          var e = this.config,\n              t = this.getFromEnv(\"xAxis\"),\n              o = t.getPixel(0),\n              a = t.getPixel(1),\n              r = this.getFromEnv(\"groupMaxWidth\"),\n              n = e.drawn;\n          r || (r = A(a - o), this.addToEnv(\"groupMaxWidth\", r)), !n && this.createContainer(), t.getState(\"scrolling\") || this.createCoordinates(), this.drawPlots();\n        }, t.prototype.createContainer = function () {\n          var e,\n              t,\n              o = this.getType(),\n              a = this.groupName,\n              r = this.getFromEnv(\"chart\"),\n              n = this.getLinkedParent(),\n              i = a || this.dsGroup || o;\n          !n.getChildContainer(i + \"VcanvasGroup\") && (i = \"default\"), e = n.getChildContainer(i + \"VcanvasGroup\"), t = n.getChildContainer(i + \"ShadowVcanvasGroup\"), !this.getContainer(\"shadowGroup\") && this.addContainer(\"shadowGroup\", k({\n            name: \"shadow-group\"\n          }, t, this)), !this.getContainer(\"errorShadowGroup\") && this.addContainer(\"errorShadowGroup\", k({\n            name: \"error-shadow-group\"\n          }, t, this)), !this.getContainer(\"commonElemsGroup\") && this.addContainer(\"commonElemsGroup\", k({\n            name: \"common-elems-group\"\n          }, e, this)), !this.getContainer(\"plotGroup\") && this.addContainer(\"plotGroup\", k({\n            name: \"plot-group\"\n          }, e, this)), !this.getContainer(\"errorPlotGroup\") && this.addContainer(\"errorPlotGroup\", k({\n            name: \"error-plot-group\"\n          }, e, this)), r.hasAnchor && this.getContainer(\"errorPlotGroup\").insertBefore(this.getContainer(\"plotGroup\")), !this.getContainer(\"labelGroup\") && this.addContainer(\"labelGroup\", k({\n            name: \"label-group\",\n            \"class\": \"fusioncharts-datalabels\"\n          }, n.getChildContainer(\"vcanvasLabelGroup\"), this));\n        }, t.prototype.createCoordinates = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              l = this.components.data,\n              s = this.getFromEnv(\"chart\"),\n              c = s.isBar,\n              u = this.getFromEnv(\"yAxis\"),\n              p = this.getFromEnv(\"xAxis\"),\n              h = u.getAxisBase(),\n              d = u.getPixel(h),\n              g = p.config.isVertical,\n              f = s.config.xDepth || 0,\n              m = s.config.yDepth || 0,\n              v = l.length,\n              b = this.components,\n              y = this.getLinkedParent(),\n              x = y.getstackConf && y.getstackConf(),\n              w = b.data;\n\n          for (!c && (f = -f), c && (m = -m), a = 0; a < v; a++) {\n            t = (e = w[a]) && e.config, void 0 !== e && (o = t._b, r = p.getPixel(x && x[a].x || t._x) + f, n = u.getPixel(t._y) + m, i = (o ? u.getPixel(o) : d) + m, g ? (t._Px = n, t._Py = r, t._Pby = r, t._Pbx = i) : (t._Px = r, t._Py = n, t._Pby = i, t._Pbx = r), this.getLineShift && (t._Py += this.getLineShift(\"y\")));\n          }\n        }, t.prototype._decideTooltipType = function (e, t) {\n          var o = this.getLinkedParent(),\n              a = this.getFromEnv(\"chart\").config.drawTrendRegion,\n              r = this.components,\n              n = this.getFromEnv(\"toolTipController\"),\n              i = r.data[e],\n              l = i && (i.config.finalTooltext || i.config.toolText),\n              s = i && (i.graphics.element || this.graphics.sharedAnchor.element),\n              c = this.config.currentToolTip,\n              u = t.originalEvent;\n          a && s ? this.config.currentToolTip = o._drawTooltip(e, this.config.index, u, c) : l && !a && (c ? n.draw(u, l, c) : c = this.config.currentToolTip = n.draw(u, l));\n        }, t.prototype._firePlotEvent = function (e, t, o) {\n          var a,\n              r = this.getFromEnv(\"chart\"),\n              n = this.components,\n              i = this.getFromEnv(\"toolTipController\"),\n              l = n.data[t],\n              s = l.graphics.element,\n              c = this.config.currentToolTip;\n          if (s) switch (a = l.config.setLink, e) {\n            case \"mouseover\":\n              this._decideTooltipType(t, o), function (e, t, o, a, r) {\n                var n = t.graphics,\n                    i = e.getFromEnv(\"animationManager\"),\n                    l = n && n.element,\n                    s = l && l.getData();\n                !0 !== s.draged && (i.setAnimationState(\"mouseOver\"), l && 0 !== s.showHoverEffect && i.setAnimation({\n                  el: l,\n                  attr: l.getData().setRolloverAttr,\n                  component: r\n                }), !a && l && e.plotEventHandler(l, o, \"DataPlotRollOver\"));\n              }(r, l, o, void 0, this), a && (s.node.style.cursor = \"pointer\");\n              break;\n\n            case \"mouseout\":\n              i.hide(c), function (e, t, o, a, r) {\n                var n = t.graphics,\n                    i = e.getFromEnv(\"animationManager\"),\n                    l = n && n.element,\n                    s = l && l.getData();\n                !0 !== s.draged && (i.setAnimationState(\"mouseOut\"), l && 0 !== s.showHoverEffect && i.setAnimation({\n                  el: l,\n                  attr: l.getData().setRolloutAttr,\n                  component: r\n                }), !a && l && e.plotEventHandler(l, o, \"DataPlotRollOut\"));\n              }(r, l, o, void 0, this), a && (s.node.style.cursor = x);\n              break;\n\n            case \"click\":\n              r.plotEventHandler(s, o);\n              break;\n\n            case \"mousemove\":\n              this._decideTooltipType(t, o);\n\n          }\n        }, t.prototype.removeData = function (e, t, o) {\n          var a,\n              r,\n              n,\n              i = this.getFromEnv(\"chart\"),\n              l = this.components,\n              s = l.data,\n              c = l.removeDataArr || (l.removeDataArr = []),\n              u = this.config,\n              p = this.maxminFlag;\n\n          for (void 0 === t && (t = 1), (e = e || 0) + t !== s.length && i.isRealTime ? 0 !== e && void 0 !== e || (this.endPosition = !1) : this.endPosition = !0, l.removeDataArr = c = c.concat(s.splice(e, t)), a = (n = c.length) - 1; a >= 0; a--) {\n            if (c[a]) {\n              if ((r = c[a].config).setValue !== u.maxValue && r.setValue !== u.minValue || (p = this.maxminFlag = !0), r._x -= t, p) break;\n            } else c.splice(a, 1);\n          }\n\n          this.removeDataLen = n, this.resetCatPos && this.resetCatPos(), p && this.getDataLimits && this.getDataLimits(), o && this.asyncDraw();\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = D;\n    },\n    574: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = {\n        \"initial.dataset.heatMap\": function initialDatasetHeatMap() {\n          return {\n            \"rect.appearing\": function rectAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"text.appearing\": function textAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }];\n            },\n            \"*\": null\n          };\n        }\n      };\n    },\n    575: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(131);\n\n      function n(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var i = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.setState(\"visible\", !0), o.getDataLimits = null, o;\n        }\n\n        return n(t, e), t.prototype.getType = function () {\n          return \"group\";\n        }, t.prototype.getName = function () {\n          return \"heatMapGroup\";\n        }, t.prototype.createContainer = function () {\n          var e = void 0,\n              t = this.getLinkedParent(),\n              o = this.getFromEnv(\"animationManager\"),\n              a = void 0,\n              r = t.getChildContainer();\n\n          for (e in r) {\n            a = r[e], !this.getChildContainer(e) && this.addChildContainer(e, o.setAnimation({\n              el: \"group\",\n              attr: {\n                name: \"manager-\" + e\n              },\n              container: a,\n              component: this,\n              label: \"group\"\n            }));\n          }\n        }, t.prototype.getLimits = function (e) {\n          var t = +Infinity,\n              o = -Infinity,\n              a = void 0,\n              r = 0,\n              n = function n(e) {\n            o = Math.max(o, e.max), t = Math.min(t, e.min);\n          };\n\n          return this._mapChildren(function (t) {\n            t.getState(\"removed\") || !1 === t.getState(\"visible\") ? e && (a = t.getDataLimits(e), n(a)) : (r++, a = t.getDataLimits(e), n(a));\n          }), r ? this.setState(\"visible\", !0) : this.setState(\"visible\", !1), this.config.range || (this.config.range = {}, this.config.range.min = this.config.dataMin, this.config.range.max = this.config.dataMax), {\n            max: o,\n            min: t\n          };\n        }, t.prototype.draw = function () {\n          var e = this.getLimits(!0);\n          this.addToEnv(\"datasetMinValue\", e.min), this.addToEnv(\"datasetMaxValue\", e.max), this.createContainer();\n        }, t.prototype.getAxisValuePadding = function () {\n          var e = {},\n              t = -Infinity,\n              o = -Infinity,\n              a = -Infinity,\n              r = -Infinity;\n          return this._mapChildren(function (n) {\n            n.getState(\"removed\") || (e = n.getAxisValuePadding && n.getAxisValuePadding() || {}, t = Math.max(t, e.left || -Infinity), o = Math.max(o, e.right || -Infinity), a = Math.max(a, e.top || -Infinity), r = Math.max(r, e.bottom || -Infinity));\n          }), t === -Infinity && (t = 0), o === -Infinity && (o = 0), a === -Infinity && (a = 0), r === -Infinity && (r = 0), this.config.padding || (this.config.padding = {}, this.config.padding.left = t, this.config.padding.right = o, this.config.padding.top = a, this.config.padding.bottom = r), {\n            left: t,\n            right: o,\n            top: a,\n            bottom: r\n          };\n        }, t;\n      }(((a = r) && a.__esModule ? a : {\n        \"default\": a\n      })[\"default\"]);\n\n      t[\"default\"] = i;\n    },\n    576: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t = e.getChildren(\"canvas\")[0],\n            o = t.getChildren(\"axisRefVisualCartesian\")[0],\n            a = {\n          zoomable: !0,\n          pannable: !0\n        },\n            n = e._feedAxesRawData(),\n            l = void 0,\n            s = void 0,\n            c = function c() {\n          return o.asyncDraw();\n        };\n\n        (0, r.componentFactory)(e, i[\"default\"], \"yAxis\", 1, n.yAxisConf), (0, r.componentFactory)(e, i[\"default\"], \"xAxis\", 1, n.xAxisConf), l = e.getChildren(\"yAxis\")[0], s = e.getChildren(\"xAxis\")[0], l.setLinkedItem(\"canvas\", t), s.setLinkedItem(\"canvas\", t), o.setLinkedItem(l.getId(), l), o.setLinkedItem(s.getId(), s), o.addExtEventListener(\"visiblerangeset\", c, s), o.addExtEventListener(\"visiblerangeset\", c, l), t.attachAxis(s, !1, e.zoomX ? a : {}), t.attachAxis(l, !0, e.zoomY ? a : {}), e._setCategories();\n      };\n      var a,\n          r = o(118),\n          n = o(321),\n          i = (a = n) && a.__esModule ? a : {\n        \"default\": a\n      };\n    },\n    584: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = s(o(427)),\n          r = s(o(585)),\n          n = s(o(588)),\n          i = s(o(592)),\n          l = o(118);\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var u = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.registerFactory(\"canvas\", i[\"default\"]), o.registerFactory(\"axis\", n[\"default\"], [\"canvas\"]), o;\n        }\n\n        return c(t, e), t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this);\n\n          var t = this.config;\n          t.axisType = \"polar\", t.axisValuePadding = 10, t.gridLineWidth = 1, t.showRadarBorder = 1, t.showvalues = 0, t.radarBorderThickness = 2, t.skipCanvasDrawing = !0, t.useplotgradientcolor = 0, t.plotfillalpha = 50;\n        }, t.prototype.setAxisDimention = function () {\n          var e = this.getChildren(\"yAxis\") && this.getChildren(\"yAxis\")[0],\n              t = this.config;\n          e && e.setAxisDimention({\n            x: t.canvasLeft + t.canvasWidth / 2,\n            y: t.canvasTop,\n            axisLength: t.canvasHeight / 2\n          });\n        }, t.prototype._feedAxesRawData = function () {\n          var e,\n              t,\n              o = this.getFromEnv(\"dataSource\");\n          return e = this.getSpecificxAxisConf(), t = this.getSpecificyAxisConf(), e.vtrendlines = o.vtrendlines, t.trendlines = o.trendlines, {\n            xAxisConf: [e],\n            yAxisConf: [t]\n          };\n        }, t.prototype.getSpecificxAxisConf = function () {\n          var e = this.getFromEnv(\"chart-attrib\"),\n              t = this.config,\n              o = this.getBasexAxisConf();\n          return o.isReverse = t.reverseXAxis, o.axisLineColor = (0, l.pluck)(e.xaxislinecolor, e.axislinecolor, \"#000000\"), o.showAlternateGridColor = (0, l.pluckNumber)(e.showalternatevgridcolor, 1), o.numDivLines = e.numvdivlines, o.axisName = e.xaxisname, o.setAdaptiveMin = e.setadaptivexmin, o.showLimits = e.showvlimits, o.showDivLineValues = (0, l.pluckNumber)(e.showvdivlinevalues, e.showvdivlinevalues), o.zeroPlaneThickness = e.vzeroplanethickness, o.zeroPlaneAlpha = e.vzeroplanealpha, o.showZeroPlaneValue = e.showvzeroplanevalue, o.showAxisLine = (0, l.pluckNumber)(e.showxaxisline, e.showaxislines, e.drawAxisLines, 0), o.showRadarBorder = e.showradarborder, o.radarBorderColor = e.radarbordercolor, o.radarBorderThickness = e.radarborderthickness, o.radarBorderAlpha = e.radarborderalpha, o.radarFillColor = e.radarfillcolor, o.radarFillAlpha = e.radarfillalpha, o.radarSpikeColor = e.radarspikecolor, o.radarSpikeThickness = e.radarspikethickness, o.radarSpikeAlpha = e.radarspikealpha, o.radarInLineAlpha = e.radarinlinealpha, o.showTooltip = (0, l.pluckNumber)(e.showtooltip, 1), o;\n        }, t.prototype.getSpecificyAxisConf = function () {\n          var e = this.getFromEnv(\"chart-attrib\"),\n              t = this.config,\n              o = this.config.is3D ? l.chartPaletteStr.chart3D : l.chartPaletteStr.chart2D,\n              a = t.isInverse,\n              r = this.getFromEnv(\"color-manager\");\n          return {\n            isVertical: !0,\n            isReverse: !a,\n            isOpposit: !1,\n            outCanfontFamily: (0, l.pluck)(e.outcnvbasefont, e.basefont, \"Verdana,sans\"),\n            outCanfontSize: (0, l.pluckFontSize)(e.outcnvbasefontsize, e.basefontsize, 10),\n            outCancolor: (0, l.pluck)(e.outcnvbasefontcolor, e.basefontcolor, r.getColor(o.baseFontColor)).replace(/^#? ([a-f0-9]+)/gi, \"#$1\"),\n            axisNamePadding: e.yaxisnamepadding,\n            axisValuePadding: e.yaxisvaluespadding,\n            axisNameFont: e.yaxisnamefont,\n            axisNameFontSize: e.yaxisnamefontsize,\n            axisNameFontColor: e.yaxisnamefontcolor,\n            axisNameFontBold: e.yaxisnamefontbold,\n            axisNameFontItalic: e.yaxisnamefontitalic,\n            axisNameBgColor: e.yaxisnamebgcolor,\n            axisNameBorderColor: e.yaxisnamebordercolor,\n            axisNameAlpha: e.yaxisnamealpha,\n            axisNameFontAlpha: e.yaxisnamefontalpha,\n            axisNameBgAlpha: e.yaxisnamebgalpha,\n            axisNameBorderAlpha: e.yaxisnameborderalpha,\n            axisNameBorderPadding: e.yaxisnameborderpadding,\n            axisNameBorderRadius: e.yaxisnameborderradius,\n            axisNameBorderThickness: e.yaxisnameborderthickness,\n            axisNameBorderDashed: e.yaxisnameborderdashed,\n            axisNameBorderDashLen: e.yaxisnameborderdashlen,\n            axisNameBorderDashGap: e.yaxisnameborderdashgap,\n            axisNameWidth: e.yaxisnamewidth,\n            useEllipsesWhenOverflow: e.useellipseswhenoverflow,\n            rotateAxisName: (0, l.pluckNumber)(e.rotateyaxisname, 1),\n            divLineColor: (0, l.pluck)(e.divlinecolor, r.getColor(o.divLineColor)),\n            divLineAlpha: (0, l.pluck)(e.divlinealpha, r.getColor(\"divLineAlpha\")),\n            divLineThickness: (0, l.pluckNumber)(e.divlinethickness, 1),\n            divLineIsDashed: Boolean((0, l.pluckNumber)(e.divlinedashed, e.divlineisdashed, 0)),\n            divLineDashLen: (0, l.pluckNumber)(e.divlinedashlen, 4),\n            divLineDashGap: (0, l.pluckNumber)(e.divlinedashgap, 2),\n            showAlternateGridColor: (0, l.pluckNumber)(e.showalternatehgridcolor, 1),\n            alternateGridColor: (0, l.pluck)(e.alternatehgridcolor, r.getColor(\"altHGridColor\")),\n            alternateGridAlpha: (0, l.pluck)(e.alternatehgridalpha, r.getColor(\"altHGridAlpha\")),\n            numDivLines: e.numdivlines,\n            axisMinValue: e.yaxisminvalue,\n            axisMaxValue: e.yaxismaxvalue,\n            setAdaptiveMin: e.setadaptiveymin,\n            adjustDiv: e.adjustvdiv,\n            labelStep: e.yaxisvaluesstep,\n            showAxisValues: (0, l.pluckNumber)(e.showyaxisvalues, e.showyaxisvalue),\n            showLimits: (0, l.pluckNumber)(e.showyaxislimits, e.showlimits, this.showLimits),\n            showDivLineValues: (0, l.pluckNumber)(e.showdivlinevalues, e.showdivlinevalue),\n            zeroPlaneColor: e.zeroplanecolor,\n            zeroPlaneThickness: (0, l.pluckNumber)(e.zeroplanethickness, e.divlinethickness, 2),\n            zeroPlaneAlpha: e.zeroplanealpha,\n            showZeroPlaneValue: e.showzeroplanevalue,\n            trendlineColor: e.trendlinecolor,\n            trendlineToolText: e.trendlinetooltext,\n            trendlineThickness: e.trendlinethickness,\n            trendlineAlpha: e.trendlinealpha,\n            showTrendlinesOnTop: e.showtrendlinesontop,\n            axisLineThickness: (0, l.pluckNumber)(e.yaxislinethickness, e.axislinethickness, 1),\n            axisLineAlpha: (0, l.pluckNumber)(e.yaxislinealpha, e.axislinealpha, 100),\n            axisLineColor: (0, l.pluck)(e.yaxislinecolor, e.axislinecolor, \"#000000\"),\n            showTooltip: (0, l.pluckNumber)(e.showtooltip, 1)\n          };\n        }, t.prototype._spaceManager = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              i,\n              s = this.config,\n              c = s.radarBorderThickness,\n              u = s.legendposition,\n              p = this.getChildren(\"xAxis\") && this.getChildren(\"xAxis\")[0],\n              h = (this.getChildren(\"yAxis\") && this.getChildren(\"yAxis\") || [])[0],\n              d = s.hasLegend,\n              g = this.getChildren(\"legend\") && this.getChildren(\"legend\")[0],\n              f = l.preDefStr.POSITION_BOTTOM,\n              m = Math,\n              v = m.min,\n              b = m.abs;\n          r = u === f ? .3 * s.canvasHeight : .3 * s.canvasWidth, !1 !== d && p && s.showLegend && this._allocateSpace(g._manageLegendPosition(r)), a = .7 * s.canvasHeight, o = .7 * s.canvasWidth, p && this._allocateSpace(p.placeAxis(o, a)), o = .7 * s.canvasWidth, h && h.placeAxis(o), e = .225 * s.availableHeight, t = this._manageActionBarSpace && (this._manageActionBarSpace(e) || {}), this._allocateSpace(t), n = s.radarradius > 0 ? 2 * s.radarradius : v(s.canvasHeight, s.canvasWidth), s.canvasHeight > n && (i = b((s.canvasHeight - n) / 2), this._allocateSpace({\n            top: i,\n            bottom: i\n          })), s.canvasWidth > n && (i = b((s.canvasWidth - n) / 2), this._allocateSpace({\n            left: i,\n            right: i\n          })), a = u === f ? .6 * s.availableHeight : .6 * s.availableWidth, this._manageChartMenuBar(a), h.setAxisDimention({\n            x: s.canvasLeft + s.canvasWidth / 2 - c / 2,\n            y: s.canvasTop,\n            axisLength: s.canvasHeight / 2\n          }), p.setAxisConfig({\n            radius: v(s.canvasWidth / 2, s.canvasHeight / 2) - c / 2\n          }), p.setAxisDimention({\n            x: s.canvasLeft + s.canvasWidth / 2,\n            y: s.canvasTop + s.canvasHeight / 2\n          });\n        }, t.getName = function () {\n          return \"Radar\";\n        }, t.prototype.getName = function () {\n          return \"Radar\";\n        }, t.prototype.getDSdef = function () {\n          return r[\"default\"];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = u;\n    },\n    585: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = c(o(347)),\n          r = c(o(586)),\n          n = o(125),\n          i = o(587),\n          l = o(118),\n          s = o(122);\n\n      function c(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function u(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var p = l.regex.dropHash;\n      (0, n.addDep)({\n        name: \"radarAnimation\",\n        type: \"animationRule\",\n        extension: r[\"default\"]\n      });\n\n      var h = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return u(t, e), t.prototype.getName = function () {\n          return \"radar\";\n        }, t.prototype.createCoordinates = function () {\n          var e,\n              t,\n              o,\n              a,\n              r,\n              n,\n              l,\n              s,\n              c = this.components.data,\n              u = this.getFromEnv(\"chart\").config,\n              p = this.getFromEnv(\"yAxis\"),\n              h = this.getFromEnv(\"xAxis\"),\n              d = c.length,\n              g = this.components.data;\n\n          for (o = 0; o < d; o++) {\n            s = (t = (e = g[o]) && e.config).setValue, void 0 !== e && (l = p.getPixel(s + 0), r = (n = (0, i.getCoordinates)({\n              radius: u.canvasTop + u.canvasHeight / 2 - l,\n              theta: o\n            }, h)).y, a = n.x, t._Px = a, t._Py = r, t._Pbx = a, t._Pby = r);\n          }\n        }, t.prototype.getLinePath = function (e, t, o) {\n          var a,\n              r,\n              n,\n              l,\n              s,\n              c = this.getFromEnv(\"chart\").config,\n              u = {},\n              p = u.lastValidValue || !1,\n              h = u.temp || [],\n              d = u.temp2 || [],\n              g = u.pathArr || [],\n              f = e.length,\n              m = u.pointsJoined || 0,\n              v = t && t.begin || 0,\n              b = t && t.end || f,\n              y = c.viewPortConfig.step || 1,\n              x = this.getFromEnv(\"yAxis\"),\n              w = this.getFromEnv(\"xAxis\"),\n              k = x.getPixel(0),\n              C = (this.removeDataLen, []);\n\n          for (0, C = C.concat(e), a = v; a < b + 0; a += y) {\n            (s = C[a]) && (null === (r = s.config).setValue || r && !0 === r.isSkipped ? (n = (0, i.getCoordinates)({\n              theta: w.getLimit().min\n            }, w).x, l = x.getPixel(x.config.axisRange.min)) : (n = r._Px, l = r._Py), \"zero\" === o ? l = k : \"base\" === o && (l = r._Pby), p ? (h.length && (g = g.concat(h), h = [], m++), g.push([\"L\", n, l])) : (h.push([\"M\", n, l]), m = 0, p = !0));\n          }\n\n          return \"Z\" !== g[g.length - 1] && m > 0 && g.push(\"Z\"), {\n            pathArr: g,\n            path2Arr: [],\n            lastValidValue: p,\n            pointsJoined: m,\n            temp: h,\n            temp2: d,\n            getPathArr: function getPathArr() {\n              var e = this.pathArr,\n                  t = this.path2Arr;\n              return e.length || t.length ? e.concat(t) : [];\n            }\n          };\n        }, t.prototype.configureAttributes = function (t) {\n          if (!t) return !1;\n          this.trimData(t), this.JSONData = t;\n          var o = this.config,\n              a = this.getFromEnv(\"chart\"),\n              r = this.index,\n              n = a.getFromEnv(\"dataSource\").chart,\n              i = this.getFromEnv(\"color-manager\"),\n              s = this.JSONData,\n              c = i.getPlotColor(r);\n          e.prototype.configureAttributes.call(this, t), o.defaultPadding = {\n            left: 0,\n            right: 0\n          }, o.plotfillcolor = (0, l.pluck)(s.color, n.plotfillcolor, c), o.plotbordercolor = (0, l.pluck)(s.plotbordercolor, n.plotbordercolor, n.areabordercolor, c).split(\",\")[0], o.fillColor = {\n            color: o.plotfillcolor + (o.plotgradientcolor ? \",\" + o.plotgradientcolor : l.BLANKSTRING),\n            alpha: o.plotfillalpha,\n            angle: o.plotfillangle\n          }, o.legendSymbolColor = o.plotfillcolor;\n        }, t.prototype._getHoveredPlot = function (e, t) {\n          var o,\n              a,\n              r,\n              n,\n              l = this.getFromEnv(\"xAxis\"),\n              s = this.components.data,\n              c = s.length,\n              u = this.config,\n              p = 360 / c;\n\n          for (a = Math.floor(Math.max((0, i.getPlotFromPixel)({\n            x: e - u.maxRadius,\n            y: t\n          }, l) / p - 1, 0)), n = Math.floor(Math.max((0, i.getPlotFromPixel)({\n            x: e + u.maxRadius,\n            y: t\n          }, l) / p, c - 1)); n >= a && (!(o = s[n]) || !(r = this.isWithinShape(o, n, e, t))); n--) {\n            ;\n          }\n\n          return r;\n        }, t.prototype._contextChanged = function () {\n          this.config.context || (this.config.context = {});\n          var t,\n              o,\n              a = this.config.context,\n              r = this.getFromEnv(\"xAxis\"),\n              n = a.axisCenterX;\n          return t = !((o = r.config.axisDimention.centerX) === n), a.axisCenterX = o, t || e.prototype._contextChanged.call(this);\n        }, t.prototype.getPlotInCategoryAt = function (e, t) {\n          var o = this.components.data,\n              a = this.getFromEnv(\"xAxis\"),\n              r = this.getState(\"visible\"),\n              n = Math.round((0, i.getPlotFromPixel)({\n            x: e,\n            y: t\n          }, a)),\n              l = o.find(function (e, t, o) {\n            var r,\n                l,\n                s,\n                c,\n                u = void 0,\n                p = void 0;\n            return 0 === t ? (u = o[t + 1], p = o[o.length - 1]) : t === o.length - 1 ? (u = o[0], p = o[o.length - 2]) : (u = o[t + 1], p = o[t - 1]), r = (0, i.getPlotFromPixel)({\n              x: e.config._Px,\n              y: e.config._Py\n            }, a), l = t === o.length - 1 ? 360 : (0, i.getPlotFromPixel)({\n              x: u.config._Px,\n              y: u.config._Py\n            }, a), s = (0, i.getPlotFromPixel)({\n              x: p.config._Px,\n              y: p.config._Py\n            }, a), n <= 0 + (c = (l - r) / 2) ? n >= 0 && n <= 0 + c : n > 360 - c ? n >= 360 - c && n <= 360 : n >= s + c && n <= l - c;\n          }),\n              s = this._getHoveredPlot(e, t);\n\n          return r && s ? s : !(!r || !l) && {\n            pointIndex: l._index,\n            hovered: !1,\n            pointObj: l\n          };\n        }, t.prototype._addLegend = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.config,\n              n = this.getFromEnv(\"chart-attrib\"),\n              i = this.getFromEnv(\"legend\"),\n              c = r.legendSymbolColor,\n              u = (0, l.pluckNumber)(n.use3dlighting, n.useplotgradientcolor, 1);\n          e = (0, s.getLightColor)(c, 60).replace(p, l.HASHSTRING), t = u ? {\n            FCcolor: {\n              color: c + \",\" + c + \",\" + (0, s.getLightColor)(c, 40) + \",\" + c + \",\" + c,\n              ratio: \"0,70,30\",\n              angle: 270,\n              alpha: \"100,100,100,100,100\"\n            }\n          } : {\n            FCcolor: {\n              color: c,\n              angle: 0,\n              ratio: \"0\",\n              alpha: \"100\"\n            }\n          }, o = {\n            enabled: r.includeInLegend,\n            type: this.type,\n            label: (0, l.getFirstValue)(this.JSONData.seriesname)\n          }, r.includeinlegend ? ((a = i.getItem(this.config.legendItemId)) || (this.config.legendItemId = i.createItem(this), a = i.getItem(this.config.legendItemId), this.addExtEventListener(\"click\", function () {\n            a.itemClickFn();\n          }, a)), a.configure(o), a.setStateCosmetics(\"default\", {\n            symbol: {\n              fill: (0, l.toRaphaelColor)(t),\n              rawFillColor: c,\n              stroke: (0, l.toRaphaelColor)(e)\n            }\n          }), this.getState(\"visible\") ? a.removeLegendState(\"hidden\") : a.setLegendState(\"hidden\")) : this.config.legendItemId && i.disposeItem(this.config.legendItemId);\n        }, t.prototype.getOldPath = function (e, t) {\n          var o,\n              a = t.x,\n              r = t.y,\n              n = this.config && this.config.prevLim,\n              i = n.x,\n              s = n.y,\n              c = 0,\n              u = e.pathArr.length,\n              p = function p(e) {\n            return (e = ((e = (e = (e - i.minPixel.x) / (i.maxPixel.x - i.minPixel.x)) * (i.max - i.min) + i.min) - a.min) / (a.max - a.min)) * (a.maxPixel.x - a.minPixel.x) + a.minPixel.x + 1;\n          },\n              h = function h(e) {\n            return e === s.base ? r.base : function (e) {\n              return (e < s.base && e > r.base || e > s.base && e < r.base) && (e = r.base), e - 1;\n            }(e);\n          };\n\n          if (s.min === r.min && i.min === a.min && s.max === r.max && i.max === a.max) return e;\n          if (e = (0, l.extend2)({}, e), !n) return [];\n\n          for (e.pathArr = e.pathArr.slice(0), e.path2Arr = e.path2Arr.slice(0), c = u; c--;) {\n            (o = e.pathArr[c].slice(0))[1] && o.join && (o[1] = p(o[1]), o[2] = h(o[2]), e.pathArr[c] = o);\n          }\n\n          for (c = e.path2Arr.length; c--;) {\n            (o = e.path2Arr[c].slice(0))[1] && o.join && (o[1] = p(o[1]), o[2] = h(o[2]), e.path2Arr[c] = o);\n          }\n\n          return e;\n        }, t.prototype._setConfigure = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.config,\n              n = this.config.JSONData.data || [],\n              i = this.getFromEnv(\"xAxis\").getTicksLen();\n\n          for (r.imageCount = 0, (o = this.components.data) || (o = this.components.data = []), r.maxRadius = -Infinity, a = 0; a < i; a++) {\n            t = o[a], e = n && n[a] || {}, t || (t = o[a] = {}), t.config || (o[a].config = {}), t.graphics || (t.graphics = {}), this._plotConfigure(a, e);\n          }\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = h;\n    },\n    586: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = o(587);\n      t[\"default\"] = {\n        \"initial.dataset.radar\": function initialDatasetRadar() {\n          return {\n            \"anchor.appearing\": function anchorAppearing() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                startEnd: {\n                  start: .5,\n                  end: 1\n                },\n                slot: \"plot\"\n              }];\n            },\n            \"anchor.updating\": function anchorUpdating() {\n              return [{\n                initialAttr: {\n                  opacity: 0\n                },\n                finalAttr: {\n                  opacity: 1\n                },\n                slot: \"final\"\n              }];\n            },\n            \"anchor.disappearing\": function anchorDisappearing() {\n              return [{\n                finalAttr: {\n                  opacity: 0,\n                  \"fill-opacity\": 0,\n                  \"stroke-opacity\": 0\n                },\n                slot: \"final\"\n              }];\n            },\n            \"line.appearing\": function lineAppearing(e) {\n              var t = e.component,\n                  o = t.getFromEnv(\"xAxis\"),\n                  r = t.getFromEnv(\"yAxis\"),\n                  n = o.getTicksLen(),\n                  i = t.getFromEnv(\"chartConfig\"),\n                  l = e.attr,\n                  s = i.canvasTop + i.canvasHeight / 2,\n                  c = [],\n                  u = void 0;\n\n              for (u = 0; u < n; u++) {\n                c.push(u ? \"L\" : \"M\"), c.push((0, a.getCoordinates)({\n                  radius: s,\n                  theta: 0\n                }, o).x), c.push(r.getPixel(0));\n              }\n\n              return c.push(\"Z\"), [{\n                initialAttr: {\n                  opacity: 0,\n                  path: c\n                },\n                finalAttr: {\n                  opacity: 1,\n                  path: l.path\n                },\n                startEnd: {\n                  start: 0,\n                  end: .5\n                },\n                slot: \"middle\"\n              }];\n            },\n            \"label.appearing\": [{\n              initialAttr: {\n                opacity: 0\n              },\n              finalAttr: {\n                opacity: 1\n              },\n              slot: \"final\"\n            }],\n            \"*\": null\n          };\n        }\n      };\n    },\n    588: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t = e.getChildren(\"canvas\")[0],\n            o = e._feedAxesRawData(),\n            i = t.getChildren(\"axisRefVisualPolar\")[0],\n            l = void 0,\n            s = void 0,\n            c = function c() {\n          return i.asyncDraw();\n        };\n\n        (0, n.componentFactory)(e, a[\"default\"], \"yAxis\", 1, o.yAxisConf), (0, n.componentFactory)(e, r[\"default\"], \"xAxis\", 1, o.xAxisConf), l = e.getChildren(\"yAxis\")[0], s = e.getChildren(\"xAxis\")[0], l.setLinkedItem(\"canvas\", t), i.setLinkedItem(l.getId(), l), i.setLinkedItem(s.getId(), s), i.addExtEventListener(\"visiblerangeset\", c, s), i.addExtEventListener(\"visiblerangeset\", c, l), t.attachAxis(s, !1, {}), t.attachAxis(l, !0, {}), e._setCategories();\n      };\n      var a = i(o(292)),\n          r = i(o(589)),\n          n = o(118);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n    },\n    589: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = d(o(295)),\n          r = o(118),\n          n = o(122),\n          i = o(587),\n          l = d(o(298)),\n          s = d(o(313)),\n          c = d(o(590)),\n          u = o(125),\n          p = d(o(322)),\n          h = o(301);\n\n      function d(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function g(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var f = r.preDefStr.POSITION_MIDDLE,\n          m = r.preDefStr.POSITION_START,\n          v = r.preDefStr.POSITION_TOP,\n          b = r.preDefStr.POSITION_BOTTOM,\n          y = r.preDefStr.POSITION_END,\n          x = Math,\n          w = x.min,\n          k = x.PI,\n          C = 2 * k;\n      (0, u.addDep)({\n        name: \"polarAnimation\",\n        type: \"animationRule\",\n        extension: c[\"default\"]\n      });\n\n      var N = function (e) {\n        function t() {\n          !function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t);\n\n          var o = function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.call(this));\n\n          return o.config.scale = new p[\"default\"](), o.config.referenceInfo = [], o;\n        }\n\n        return g(t, e), t.prototype.getName = function () {\n          return \"polarCategory\";\n        }, t.prototype.__setDefaultConfig = function () {\n          e.prototype.__setDefaultConfig.call(this), this.config.drawPlotBands = !1, this.config.forceZeroTick = !1;\n        }, t.prototype.configureAttributes = function (t) {\n          var o = this.config,\n              a = t,\n              i = this.getFromEnv(\"chart\").getFromEnv(\"dataSource\").chart,\n              l = this.getFromEnv(\"color-manager\");\n          e.prototype.configureAttributes.call(this, t), o.gridLineColor = (0, n.convertColor)((0, r.pluck)(a.radarSpikeColor, l.getColor(\"divLineColor\")), (0, r.pluckNumber)(a.radarSpikeAlpha, a.radarInLineAlpha, l.getColor(\"divLineAlpha\"))), o.radarSpikeThickness = (0, r.pluckNumber)(i.radarspikethickness, 1);\n        }, t.prototype.setAxisDimention = function (e) {\n          var t,\n              o = this.getScale(),\n              a = this.config,\n              n = this.getFromEnv(\"chart\").config,\n              i = a.startAngle || -k / 2,\n              l = a.totalAngle || -C,\n              s = i + l,\n              c = l / ((a.tickValues.tickValue || []).length || 1),\n              u = a.axisDimention || (a.axisDimention = {});\n          u.opposite = (0, r.pluckNumber)(e.opposite, u.opposite), u.centerX = (0, r.pluckNumber)(e.x, u.x, n.canvasLeft), u.centerY = (0, r.pluckNumber)(e.y, u.y, n.canvasTop), u.axisLength = C, s -= c, t = a.clockWise ? [s, i] : [i, s], o.setRange(t);\n        }, t.prototype._parseCategoryPlotLine = function () {\n          var e,\n              t,\n              o,\n              a = this.config,\n              r = a.tickValues.tickValue,\n              n = a.gridLineColor,\n              i = a.radarSpikeThickness,\n              l = a.referenceInfo;\n          if (e = {\n            stroke: n,\n            \"stroke-width\": i\n          }, (!r[0] || void 0 === r[0].x && void 0 === r[0].y) && a.lines.isDraw && a.numDivLines) for (t = 0; t < r.length; ++t) {\n            o = t, l.push({\n              from: o,\n              type: \"line\",\n              layer: 1,\n              attr: e\n            });\n          }\n        }, t.prototype.placeAxis = function (e, t) {\n          var o,\n              a,\n              n,\n              i,\n              l,\n              s,\n              c,\n              u,\n              p = this.config,\n              h = this.getFromEnv(\"chart\"),\n              d = h.getFromEnv(\"smartLabel\"),\n              g = p.labels.style,\n              f = h.getFromEnv(\"dataSource\").categories,\n              m = p.labelPadding = (0, r.pluckNumber)(p.rawAttr.axisValuePadding, 10),\n              v = p.useEllipsesWhenOverflow,\n              b = 0,\n              y = 0,\n              x = 0,\n              k = 0,\n              C = t / 2,\n              N = t / 2,\n              S = e / 2,\n              E = e / 2,\n              A = p.tickValues && p.tickValues.tickValue;\n\n          if (p.labels.isDraw = 1, p.labels.drawNormalVal = 1, p.labels.drawLimitVal = 1, this.components || (this.components = {}), this.components.labels = [], p.showLabels) {\n            if (f) {\n              var D = f[0];\n              l = {\n                fontFamily: D.font,\n                fontSize: D.fontsize,\n                color: D.fontcolor\n              };\n            }\n\n            for (o = 0, a = A.length; o < a; o++) {\n              s = {\n                fontFamily: (n = A[o]).font,\n                fontSize: n.fontsize,\n                fontWeight: n.fontbold ? \"bold\" : \"normal\",\n                fontStyle: n.fontitalic ? \"italic\" : \"normal\"\n              }, c = {\n                fontFamily: (0, r.pluck)(s.fontFamily, l.fontFamily, g.fontFamily),\n                fontSize: (0, r.pluck)(s.fontSize, l.fontSize, g.fontSize),\n                fontWeight: (0, r.pluck)(s.fontWeight, g.fontWeight),\n                fontStyle: (0, r.pluck)(s.fontStyle, g.fontStyle)\n              }, u = (0, r.setLineHeight)(c), d.useEllipsesOnOverflow(h.config.useEllipsesWhenOverflow), d.setStyle(c), void 0 === n.oriLabel && (n.oriLabel = n.label), 0 === o ? (i = d.getSmartText(n.oriLabel, e, w(u, C), v), n.label = i.text, n.tooltext = i.tooltext, i.width += m, i.height += m, i.height > b && (k = b = i.height)) : o === a / 2 ? (i = d.getSmartText(n.oriLabel, e, w(u, N), v), n.label = i.text, n.tooltext = i.tooltext, i.width += m, i.height += m, i.height > k && (k = i.height)) : o < a / 2 ? (i = d.getSmartText(n.oriLabel, E, u, v), n.label = i.text, n.tooltext = i.tooltext, i.width += m, i.height += m, i.width > y && (y = i.width)) : (i = d.getSmartText(n.oriLabel, S, u, v), n.label = i.text, n.tooltext = i.tooltext, i.width += m, i.height += m, i.width > x && (x = i.width)), this.components.labels.push({\n                config: {\n                  width: i.width,\n                  height: i.height,\n                  props: {\n                    label: {\n                      attr: {}\n                    }\n                  }\n                }\n              });\n            }\n          } else for (o = 0, a = A.length; o < a; o++) {\n            this.components.labels.push({\n              config: {\n                width: 0,\n                height: 0,\n                props: {\n                  label: {\n                    attr: {}\n                  }\n                }\n              }\n            });\n          }\n\n          return {\n            top: b,\n            left: y,\n            right: x,\n            bottom: k\n          };\n        }, t.prototype._drawComponents = function () {\n          var e = this.config;\n          e.drawLabels && e.hasCategory && this._drawCategory();\n        }, t.prototype.allocatePosition = function () {\n          var e = this.config;\n          e.drawLabels && e.hasCategory && this._parseCategory();\n        }, t.prototype._parseCategory = function () {\n          var e,\n              t,\n              o,\n              a,\n              l,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d,\n              g,\n              x,\n              w,\n              k,\n              C,\n              N,\n              S,\n              E = this.config,\n              A = this.getFromEnv(\"chart\"),\n              D = E.isOpposit,\n              T = E.labels,\n              L = T.style,\n              _ = this.config.categoryLabel || (this.config.categoryLabel = {}),\n              P = A.getFromEnv(\"dataSource\").categories,\n              O = E.tickValues.tickValue,\n              V = E.labelPadding,\n              M = {},\n              F = {},\n              I = E.axisDimention.centerX,\n              B = E.axisDimention.centerY,\n              R = this.getScale();\n\n          if (w = (0, r.pluckNumber)(E.radius, 0), 0, t = O ? O.length - 1 : 0, E.labels.isDraw) {\n            if (P) {\n              var j = P[0];\n              M.fontFamily = j.font, M.fontSize = j.fontsize, M.color = j.fontcolor;\n            }\n\n            for (e = 0; e <= t; e++) {\n              o = O[e], d = (0, r.pluckNumber)(o.x, o.y, e), (E.labels.drawNormalVal || E.labels.drawLimitVal && (0 === e || d === t)) && (E.labels.drawNormalVal || 0 === d || d === t) && (E.labels.drawLimitVal || 0 !== d && d !== t) && (F = {\n                fontFamily: (0, r.pluck)(o.font, o.labelfont),\n                fontSize: (0, r.pluck)(o.fontsize, o.labelfontsize),\n                fontWeight: (0, r.pluckNumber)(o.fontbold, o.labelfontbold, 0) ? \"bold\" : void 0,\n                fontStyle: (0, r.pluckNumber)(o.fontitalic, o.labelfontitalic, 0) ? \"italic\" : void 0\n              }, p = (0, n.convertColor)((0, r.pluck)(o.fontcolor, o.labelfontcolor, M.color, L.color), (0, r.pluckNumber)(o.labelalpha, E.rawAttr.labelFontAlpha, 100)), (c = {\n                fontFamily: (0, r.pluck)(F.fontFamily, M.fontFamily, L.fontFamily),\n                fontSize: (0, r.pluck)(F.fontSize, M.fontSize, L.fontSize),\n                fontWeight: (0, r.pluck)(F.fontWeight, L.fontWeight),\n                fontStyle: (0, r.pluck)(F.fontStyle, L.fontStyle)\n              }).lineHeight = (0, r.setLineHeight)(c), c.lineHeight && -1 !== (l = c.lineHeight).indexOf(\"px\") && (l = l.replace(/px/i, \"\"), l = parseFloat(l)), C = R.getRangeValue(d), (h = (0, i.polarToCartesian)(w + V, C)).x += I, h.y += B, g = h.x, x = h.y, a = o.label || \"\", 0 !== (0, r.pluckNumber)(o.showlabel, 1) && 0 !== E.showLabels || (a = \"\"), s = o.labelPadding || 0, u = {\n                fill: p,\n                \"line-height\": l,\n                \"font-size\": L.fontSize,\n                text: a,\n                cursor: o.link ? \"pointer\" : \"default\",\n                x: g,\n                y: x\n              }, s && (u.y += s), u[\"vertical-align\"] = D ? b : v, 0 === e ? (u[\"text-anchor\"] = f, u[\"vertical-align\"] = b) : e === (t + 1) / 2 ? (u[\"text-anchor\"] = f, u[\"vertical-align\"] = v) : e < (t + 1) / 2 ? (u[\"text-anchor\"] = y, u[\"vertical-align\"] = f) : (u[\"text-anchor\"] = m, u[\"vertical-align\"] = f), C = R.getRangeValue(d), (k = (0, i.polarToCartesian)(w, C)).x += I, k.y += B, T.shiftX && (u.x += T.shiftX), T.shiftY && (u.y += T.shiftY), (_ = E.categoryLabel = _ || {})[S = \"Label\" + e] = _[S] || {}, _[S].config = _[S].config || {}, _[S].config.labelBox = N = {\n                label: a,\n                lineHeight: c.lineHeight,\n                border: (0, r.pluckNumber)(o.borderthickness, o.labelborderthickness) ? (0, r.pluckNumber)(o.borderthickness, o.labelborderthickness, 1) + \"px solid\" : \"\",\n                borderColor: o.bordercolor || o.labelbordercolor ? (0, n.convertColor)(o.bordercolor || o.labelbordercolor, (0, r.pluckNumber)(o.borderalpha, o.labelborderalpha, o.alpha, o.labelalpha, 100)) : r.BLANKSTRING,\n                borderThickness: (0, r.pluckNumber)(o.borderthickness, o.labelborderthickness),\n                borderPadding: (0, r.pluckNumber)(o.borderpadding, o.labelborderpadding),\n                borderRadius: (0, r.pluckNumber)(o.borderradius, o.labelborderradius),\n                backgroundColor: o.bgcolor || o.labelbgcolor ? (0, n.convertColor)(o.bgcolor || o.labelbgcolor, (0, r.pluckNumber)(o.bgalpha, o.labelbgalpha, o.alpha, o.labelalpha, 100)) : r.BLANKSTRING,\n                borderDash: (0, r.pluckNumber)(o.borderdashed, o.labelborderdashed, 0) ? (0, r.getDashStyle)((0, r.pluckNumber)(o.borderdashlen, o.labelborderdashlen, 4), (0, r.pluckNumber)(o.borderdashgap, o.labelborderdashgap, 2)) : 0 === (0, r.pluckNumber)(o.borderdashed, o.labelborderdashed) ? \"none\" : L.borderDash\n              }, _[S].config.labelBox[\"text-bound\"] = a ? [(0, r.pluck)(N.backgroundColor, L.backgroundColor), (0, r.pluck)(N.borderColor, L.borderColor), (0, r.pluck)(N.borderThickness, L.borderThickness), (0, r.pluck)(N.borderPadding, L.borderPadding), (0, r.pluck)(N.borderRadius, L.borderRadius), (0, r.pluck)(N.borderDash, L.borderDash)] : [], u[\"text-bound\"] = _[S].config.labelBox[\"text-bound\"], this.components.labels[e].config.props.label.css = c, this.components.labels[e].config.props.label.attr = Object.assign(this.components.labels[e].config.props.label.attr, u));\n            }\n          }\n        }, t.prototype._drawCategory = function () {\n          var e,\n              t,\n              o,\n              a,\n              n,\n              i,\n              s,\n              c,\n              u,\n              p,\n              h,\n              d = this,\n              g = d.config,\n              f = d.getFromEnv(\"chart\"),\n              m = f.getFromEnv(\"animationManager\"),\n              v = g.labels.style,\n              b = g.axisContainer,\n              y = g.tickValues.tickValue,\n              x = function x(e) {\n            return function (t) {\n              f.plotEventHandler(this, t, e);\n            };\n          },\n              w = d.getFromEnv(\"toolTipController\"),\n              k = 0,\n              C = [];\n\n          if (0, t = y ? y.length - 1 : 0, g.labels.isDraw) {\n            for (e = 0, k = 0; e <= t; e++) {\n              o = y[e], c = (0, r.pluckNumber)(o.x, o.y, e), (g.labels.drawNormalVal || g.labels.drawLimitVal && (0 === e || c === t)) && (g.labels.drawNormalVal || 0 === c || c === t) && (g.labels.drawLimitVal || 0 !== c && c !== t) && (p = \"Label\" + e, C.push(p), s = d.components.labels[e].config.props.label.attr, i = d.components.labels[e].config.props.label.css, n = d.getGraphicalElement(p), a = m.setAnimation({\n                css: i,\n                el: n || \"text\",\n                attr: s,\n                container: b,\n                component: d,\n                label: \"polarLabel\"\n              }), g.showTooltip && o.tooltext ? w.enableToolTip(a, o.tooltext) : w.disableToolTip(a), a.data(\"eventArgs\", {\n                link: o.link || o.labellink || v.labelLink,\n                text: s.text,\n                index: k\n              }), n || (d.addGraphicalElement(p, a), a.click(x(\"datalabelclick\")).hover(x(\"dataLabelRollOver\"), x(\"dataLabelRollOut\"))), k += 1);\n            }\n\n            g.labelMap = g.labelMap || [], h = (0, l[\"default\"])(g.labelMap, C);\n          } else h = C;\n\n          g.labelMap = C, function (t) {\n            for (e = 0; e < t.length; ++e) {\n              (u = d.getGraphicalElement(t[e])) && d.removeGraphicalElement(u);\n            }\n          }(h);\n        }, t.prototype.getTranslation = function () {\n          if (this) return 0;\n        }, t.prototype.getReferenceInfo = function () {\n          return this.config.referenceInfo;\n        }, t.prototype.setVisibleConfig = function (e, t) {\n          var o,\n              a = this.config,\n              r = this.getScale();\n          return !(e >= t || e < a.axisRange.min || t > a.axisRange.max) && (o = r.setDomain([e, t]).getDomain(), a.visibleMin = o[0], a.visibleMax = o[1], this.clearReferenceInfo(), this._parseReferenceVisuals(), this.fireEvent(\"visiblerangeset\", {\n            minValue: e,\n            maxValue: t\n          }), this.asyncDraw(), !0);\n        }, t.prototype._parseReferenceVisuals = function () {\n          this.config.drawPlotlines && this._parseCategoryPlotLine();\n        }, t.prototype.clearReferenceInfo = function () {\n          this.config.referenceInfo = [];\n        }, t.prototype._setAxisRange = function (e) {\n          var t,\n              o = e.min,\n              a = e.max,\n              r = this.config,\n              n = r.axisRange,\n              i = e.divGap;\n          o > a || (t = (a - o) / (r.categoryNumDivLines + 1), this.getScale().setDomain([o, a]), r.ticks = (0, s[\"default\"])(o, a, t).concat(a), r._allTicks = r.ticks.slice(), n.min = o, n.max = a, n.tickInterval = i || t, this.setVisibleConfig(n.min, n.max));\n        }, t;\n      }(a[\"default\"]);\n\n      N.prototype.setTickValues = h.setTickValues, N.prototype.shiftLabels = h.shiftLabels, N.prototype._createContainer = h._createContainer, N.prototype.setAxisPadding = h.setAxisPadding, N.prototype.getPixel = h.getPixel, N.prototype.getLabel = h.getLabel, t[\"default\"] = N;\n    },\n    590: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(591),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"initial.axis.polar\": function initialAxisPolar() {\n          return {\n            \"path.appearing\": n[\"default\"],\n            \"text.appearing\": n[\"default\"]\n          };\n        }\n      };\n    },\n    592: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0, t[\"default\"] = function (e) {\n        var t = void 0;\n        (0, n.componentFactory)(e, a[\"default\"], \"canvas\", e.config.showVolumeChart ? 2 : 1);\n\n        for (var o = 0, i = (t = e.getChildren(\"canvas\")).length; o < i; o++) {\n          t[o].configure(), (0, n.componentFactory)(t[o], r[\"default\"], \"axisRefVisualPolar\");\n        }\n      };\n      var a = i(o(593)),\n          r = i(o(594)),\n          n = o(118);\n\n      function i(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n    },\n    593: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(263),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      },\n          i = o(587),\n          l = o(118),\n          s = o(122);\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      var u = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.getName = function () {\n          return \"polarCanvas\";\n        }, t.prototype.getType = function () {\n          return \"canvas\";\n        }, t.prototype.configureAttributes = function () {\n          e.prototype.configureAttributes.call(this);\n          var t = this.config,\n              o = this.getFromEnv(\"chart\"),\n              a = o.getFromEnv(\"dataSource\").chart,\n              r = o.getFromEnv(\"color-manager\");\n          t.radarBorderColor = (0, s.convertColor)((0, l.pluck)(a.radarbordercolor, r.getColor(\"divLineColor\")), (0, l.pluckNumber)(a.radarborderalpha, 100)), t.radarFillColor = (0, s.convertColor)((0, l.pluck)(a.radarfillcolor, r.getColor(\"altHGridColor\")), (0, l.pluckNumber)(a.radarfillalpha, r.getColor(\"altHGridAlpha\"))), t.radarBorderThickness = (0, l.pluckNumber)(a.radarborderthickness, 2), t.showRadarBorder = (0, l.pluckNumber)(a.showradarborder, 1);\n        }, t.prototype.draw = function () {\n          this.createGroup(), this.drawCanvas();\n        }, t.prototype.drawCanvas = function () {\n          var e,\n              t,\n              o,\n              a,\n              r = this.config,\n              n = this.getFromEnv(\"chart\"),\n              s = n.config,\n              c = n.getChildren(\"xAxis\")[0],\n              u = n.getFromEnv(\"animationManager\"),\n              p = this.getContainer(\"radarBorderContainer\"),\n              h = this.getContainer(\"canvasGroup\"),\n              d = c.config,\n              g = {\n            stroke: r.radarBorderColor,\n            fill: r.radarFillColor,\n            \"stroke-width\": r.radarBorderThickness,\n            path: []\n          },\n              f = void 0,\n              m = d.tickValues.tickValue,\n              v = void 0,\n              b = c.getScale(),\n              y = void 0,\n              x = this.getGraphicalElement(\"radarBorder\"),\n              w = d.axisDimention.centerX,\n              k = d.axisDimention.centerY;\n\n          if (o = (0, l.pluckNumber)(d.radius, 0), 0, t = m ? m.length - 1 : 0, r.canvasLeft = r.canvasLeft || s.canvasLeft, r.canvasTop = r.canvasTop || s.canvasTop, r.canvasWidth = r.canvasWidth || s.canvasWidth, r.canvasHeight = r.canvasHeight || s.canvasHeight, 0 !== r.showRadarBorder) {\n            for (g.path.push(\"M\"), f = 0; f <= t; f++) {\n              v = b.getRangeValue(f), (y = (0, i.polarToCartesian)(o, v)).x += w, y.y += k, g.path.push(y.x, y.y, \"L\");\n            }\n\n            g.path.pop(), g.path.push(\"Z\");\n          }\n\n          e = u.setAnimation({\n            el: p || \"group\",\n            attr: {\n              name: \"radarBorderContainer\"\n            },\n            container: h,\n            component: this,\n            label: \"group\"\n          }), p || this.addContainer(\"radarBorderContainer\", e), a = u.setAnimation({\n            el: x || \"path\",\n            attr: g,\n            container: e,\n            component: c,\n            label: \"path\"\n          }), x || this.addGraphicalElement(\"radarBorder\", a);\n        }, t;\n      }(n[\"default\"]);\n\n      t[\"default\"] = u;\n    },\n    594: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a = s(o(324)),\n          r = o(587),\n          n = o(118),\n          i = o(125),\n          l = s(o(595));\n\n      function s(e) {\n        return e && e.__esModule ? e : {\n          \"default\": e\n        };\n      }\n\n      function c(e, t) {\n        if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function, not \" + typeof t);\n        e.prototype = Object.create(t && t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : function (e, t) {\n          for (var o = Object.getOwnPropertyNames(t), a = 0; a < o.length; a++) {\n            var r = o[a],\n                n = Object.getOwnPropertyDescriptor(t, r);\n            n && n.configurable && e[r] === undefined && Object.defineProperty(e, r, n);\n          }\n        }(e, t));\n      }\n\n      (0, i.addDep)({\n        name: \"axisRefPolarAnimation\",\n        type: \"animationRule\",\n        extension: l[\"default\"]\n      });\n\n      var u = function (e) {\n        function t() {\n          return function (e, t) {\n            if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n          }(this, t), function (e, t) {\n            if (!e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            return !t || \"object\" != typeof t && \"function\" != typeof t ? e : t;\n          }(this, e.apply(this, arguments));\n        }\n\n        return c(t, e), t.prototype.getType = function () {\n          return \"axisRefVisuals\";\n        }, t.prototype.getName = function () {\n          return \"axisRefVisualsPolar\";\n        }, t.prototype.createLine = function (e, t) {\n          return \"polarCategory\" === t.getName() ? this.createNormalLine(e, t) : \"numeric\" === t.getName() ? this.createRadialLine(e, t) : void 0;\n        }, t.prototype.createRadialLine = function (e, t) {\n          var o,\n              a,\n              n = this.getFromEnv(\"xAxis\")[0],\n              i = n.config.tickValues.tickValue,\n              l = t,\n              s = this.config.containers[e.layer],\n              c = this.getFromEnv(\"animationManager\"),\n              u = this.getFromEnv(\"toolTipController\"),\n              p = void 0,\n              h = void 0,\n              d = e.attr,\n              g = [\"M\"],\n              f = void 0,\n              m = l.getId() + \"_\" + (e.id || e.from),\n              v = e.handlers,\n              b = this.getGraphicalElement(m);\n\n          for (a = function (e, t) {\n            var o = e.getScale(),\n                a = e.config.axisRange;\n            return Math.abs(o.getRangeValue(t) - o.getRangeValue(a.min));\n          }(l, e.from), 0, o = i ? i.length - 1 : 0, p = 0; p <= o; p++) {\n            f = (0, r.getCoordinates)({\n              radius: a,\n              theta: p\n            }, n), g.push(f.x, f.y, \"L\");\n          }\n\n          for (h in g.pop(), g.push(\"Z\"), d.path = g, b = this.addGraphicalElement(m, c.setAnimation({\n            container: s,\n            el: b || \"path\",\n            attr: d,\n            component: this,\n            label: \"path\"\n          })), e.toolText ? u.enableToolTip(b, e.toolText) : u.disableToolTip(b), v) {\n            v.hasOwnProperty(h) && b.on(h, v[h].bind(t));\n          }\n\n          return [m];\n        }, t.prototype.createNormalLine = function (e, t) {\n          var o,\n              a = this.config,\n              i = t.config,\n              l = (0, n.pluckNumber)(i.radius, 0),\n              s = [\"M\"],\n              c = a.containers[e.layer],\n              u = this.getFromEnv(\"animationManager\"),\n              p = this.getFromEnv(\"toolTipController\"),\n              h = void 0,\n              d = i.axisDimention.centerX,\n              g = i.axisDimention.centerY,\n              f = t.getId() + \"_\" + (e.id || e.from),\n              m = e.handlers,\n              v = this.getGraphicalElement(f);\n\n          for (h in s.push(d, g, \"L\"), o = (0, r.getCoordinates)({\n            radius: l,\n            theta: e.from\n          }, t), s.push(o.x, o.y), e.attr.path = s, v = this.addGraphicalElement(f, u.setAnimation({\n            container: c,\n            el: v || \"path\",\n            attr: e.attr,\n            component: this,\n            label: \"path\"\n          })), e.toolText ? p.enableToolTip(v, e.toolText) : p.disableToolTip(v), m) {\n            m.hasOwnProperty(h) && v.on(h, m[h].bind(t));\n          }\n\n          return [f];\n        }, t.prototype.createBand = function () {\n          return [];\n        }, t;\n      }(a[\"default\"]);\n\n      t[\"default\"] = u;\n    },\n    595: function _(e, t, o) {\n      \"use strict\";\n\n      t.__esModule = !0;\n      var a,\n          r = o(591),\n          n = (a = r) && a.__esModule ? a : {\n        \"default\": a\n      };\n      t[\"default\"] = {\n        \"initial.axis.axisRefVisualsPolar\": function initialAxisAxisRefVisualsPolar() {\n          return {\n            \"path.appearing\": n[\"default\"],\n            \"text.appearing\": n[\"default\"]\n          };\n        }\n      };\n    }\n  }]);\n});","map":null,"metadata":{},"sourceType":"script"}