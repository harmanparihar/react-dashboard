{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.default = plotComponentFactory;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // The naming convention is:\n//   - events are attached as `'plotly_' + eventName.toLowerCase()`\n//   - react props are `'on' + eventName`\n\n\nvar eventNames = ['AfterExport', 'AfterPlot', 'Animated', 'AnimatingFrame', 'AnimationInterrupted', 'AutoSize', 'BeforeExport', 'ButtonClicked', 'Click', 'ClickAnnotation', 'Deselect', 'DoubleClick', 'Framework', 'Hover', 'LegendClick', 'LegendDoubleClick', 'Relayout', 'Restyle', 'Redraw', 'Selected', 'Selecting', 'SliderChange', 'SliderEnd', 'SliderStart', 'Transitioning', 'TransitionInterrupted', 'Unhover'];\nvar updateEvents = ['plotly_restyle', 'plotly_redraw', 'plotly_relayout', 'plotly_doubleclick', 'plotly_animated']; // Check if a window is available since SSR (server-side rendering)\n// breaks unnecessarily if you try to use it server-side.\n\nvar isBrowser = typeof window !== 'undefined';\n\nfunction plotComponentFactory(Plotly) {\n  var PlotlyComponent = function (_Component) {\n    _inherits(PlotlyComponent, _Component);\n\n    function PlotlyComponent(props) {\n      _classCallCheck(this, PlotlyComponent);\n\n      var _this = _possibleConstructorReturn(this, (PlotlyComponent.__proto__ || Object.getPrototypeOf(PlotlyComponent)).call(this, props));\n\n      _this.p = Promise.resolve();\n      _this.resizeHandler = null;\n      _this.handlers = {};\n      _this.syncWindowResize = _this.syncWindowResize.bind(_this);\n      _this.syncEventHandlers = _this.syncEventHandlers.bind(_this);\n      _this.attachUpdateEvents = _this.attachUpdateEvents.bind(_this);\n      _this.getRef = _this.getRef.bind(_this);\n      _this.handleUpdate = _this.handleUpdate.bind(_this);\n      _this.figureCallback = _this.figureCallback.bind(_this);\n      return _this;\n    }\n\n    _createClass(PlotlyComponent, [{\n      key: 'componentDidMount',\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        this.p = this.p.then(function () {\n          return Plotly.newPlot(_this2.el, {\n            data: _this2.props.data,\n            layout: _this2.props.layout,\n            config: _this2.props.config,\n            frames: _this2.props.frames\n          });\n        }).then(function () {\n          return _this2.syncWindowResize(null, true);\n        }).then(this.syncEventHandlers).then(this.attachUpdateEvents).then(function () {\n          return _this2.figureCallback(_this2.props.onInitialized);\n        }).catch(function (err) {\n          console.error('Error while plotting:', err);\n          return _this2.props.onError && _this2.props.onError(err);\n        });\n      }\n    }, {\n      key: 'componentWillUpdate',\n      value: function componentWillUpdate(nextProps) {\n        var _this3 = this;\n\n        if (nextProps.revision !== void 0 && nextProps.revision === this.props.revision) {\n          // if revision is set and unchanged, do nothing\n          return;\n        }\n\n        var numPrevFrames = this.props.frames && this.props.frames.length ? this.props.frames.length : 0;\n        var numNextFrames = nextProps.frames && nextProps.frames.length ? nextProps.frames.length : 0;\n\n        if (nextProps.layout === this.props.layout && nextProps.data === this.props.data && nextProps.config === this.props.config && numNextFrames === numPrevFrames) {\n          // prevent infinite loops when component is re-rendered after onUpdate\n          // frames *always* changes identity so fall back to check length only :(\n          return;\n        }\n\n        this.p = this.p.then(function () {\n          return Plotly.react(_this3.el, {\n            data: nextProps.data,\n            layout: nextProps.layout,\n            config: nextProps.config,\n            frames: nextProps.frames\n          });\n        }).then(function () {\n          return _this3.syncEventHandlers(nextProps);\n        }).then(function () {\n          return _this3.syncWindowResize(nextProps);\n        }).then(function () {\n          return _this3.figureCallback(nextProps.onUpdate);\n        }).catch(function (err) {\n          console.error('Error while plotting:', err);\n          _this3.props.onError && _this3.props.onError(err);\n        });\n      }\n    }, {\n      key: 'componentWillUnmount',\n      value: function componentWillUnmount() {\n        this.figureCallback(this.props.onPurge);\n\n        if (this.resizeHandler && isBrowser) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n\n        this.removeUpdateEvents();\n        Plotly.purge(this.el);\n      }\n    }, {\n      key: 'attachUpdateEvents',\n      value: function attachUpdateEvents() {\n        if (!this.el || !this.el.removeListener) return;\n\n        for (var i = 0; i < updateEvents.length; i++) {\n          this.el.on(updateEvents[i], this.handleUpdate);\n        }\n      }\n    }, {\n      key: 'removeUpdateEvents',\n      value: function removeUpdateEvents() {\n        if (!this.el || !this.el.removeListener) return;\n\n        for (var i = 0; i < updateEvents.length; i++) {\n          this.el.removeListener(updateEvents[i], this.handleUpdate);\n        }\n      }\n    }, {\n      key: 'handleUpdate',\n      value: function handleUpdate() {\n        this.figureCallback(this.props.onUpdate);\n      }\n    }, {\n      key: 'figureCallback',\n      value: function figureCallback(callback) {\n        if (typeof callback === 'function') {\n          var _el = this.el,\n              data = _el.data,\n              layout = _el.layout;\n          var frames = this.el._transitionData ? this.el._transitionData._frames : null;\n          var figure = {\n            data: data,\n            layout: layout,\n            frames: frames\n          }; // for extra clarity!\n\n          callback(figure, this.el);\n        }\n      }\n    }, {\n      key: 'syncWindowResize',\n      value: function syncWindowResize(propsIn, invoke) {\n        var _this4 = this;\n\n        var props = propsIn || this.props;\n        if (!isBrowser) return;\n\n        if (props.useResizeHandler && !this.resizeHandler) {\n          this.resizeHandler = function () {\n            return Plotly.Plots.resize(_this4.el);\n          };\n\n          window.addEventListener('resize', this.resizeHandler);\n\n          if (invoke) {\n            this.resizeHandler();\n          }\n        } else if (!props.useResizeHandler && this.resizeHandler) {\n          window.removeEventListener('resize', this.resizeHandler);\n          this.resizeHandler = null;\n        }\n      }\n    }, {\n      key: 'getRef',\n      value: function getRef(el) {\n        this.el = el;\n\n        if (this.props.debug && isBrowser) {\n          window.gd = this.el;\n        }\n      } // Attach and remove event handlers as they're added or removed from props:\n\n    }, {\n      key: 'syncEventHandlers',\n      value: function syncEventHandlers(propsIn) {\n        // Allow use of nextProps if passed explicitly:\n        var props = propsIn || this.props;\n\n        for (var i = 0; i < eventNames.length; i++) {\n          var eventName = eventNames[i];\n          var prop = props['on' + eventName];\n          var hasHandler = !!this.handlers[eventName];\n\n          if (prop && !hasHandler) {\n            this.handlers[eventName] = prop;\n            this.el.on('plotly_' + eventName.toLowerCase(), this.handlers[eventName]);\n          } else if (!prop && hasHandler) {\n            // Needs to be removed:\n            this.el.removeListener('plotly_' + eventName.toLowerCase(), this.handlers[eventName]);\n            delete this.handlers[eventName];\n          }\n        }\n      }\n    }, {\n      key: 'render',\n      value: function render() {\n        return _react2.default.createElement('div', {\n          id: this.props.divId,\n          style: this.props.style,\n          ref: this.getRef,\n          className: this.props.className\n        });\n      }\n    }]);\n\n    return PlotlyComponent;\n  }(_react.Component);\n\n  PlotlyComponent.propTypes = {\n    data: _propTypes2.default.arrayOf(_propTypes2.default.object),\n    config: _propTypes2.default.object,\n    layout: _propTypes2.default.object,\n    frames: _propTypes2.default.arrayOf(_propTypes2.default.object),\n    revision: _propTypes2.default.number,\n    onInitialized: _propTypes2.default.func,\n    onPurge: _propTypes2.default.func,\n    onError: _propTypes2.default.func,\n    onUpdate: _propTypes2.default.func,\n    debug: _propTypes2.default.bool,\n    style: _propTypes2.default.object,\n    className: _propTypes2.default.string,\n    useResizeHandler: _propTypes2.default.bool,\n    divId: _propTypes2.default.string\n  };\n\n  for (var i = 0; i < eventNames.length; i++) {\n    PlotlyComponent.propTypes['on' + eventNames[i]] = _propTypes2.default.func;\n  }\n\n  PlotlyComponent.defaultProps = {\n    debug: false,\n    useResizeHandler: false,\n    data: [],\n    style: {\n      position: 'relative',\n      display: 'inline-block'\n    }\n  };\n  return PlotlyComponent;\n}\n\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}